{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "view-in-github",
        "colab_type": "text"
      },
      "source": [
        "<a href=\"https://colab.research.google.com/github/eflatlan/CNN_PID/blob/models_sacved/resolved%20mip%20problem\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 225,
      "metadata": {
        "id": "mrPLFO_92Cvr",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "e178ae5c-f274-4193-9d6c-0721d1e84fd9"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Requirement already satisfied: h5py in /usr/local/lib/python3.10/dist-packages (3.9.0)\n",
            "Requirement already satisfied: numpy in /usr/local/lib/python3.10/dist-packages (1.23.5)\n",
            "Drive already mounted at /content/drive; to attempt to forcibly remount, call drive.mount(\"/content/drive\", force_remount=True).\n",
            "The tensorboard extension is already loaded. To reload it, use:\n",
            "  %reload_ext tensorboard\n"
          ]
        }
      ],
      "source": [
        "!pip install h5py numpy\n",
        "\n",
        "import os\n",
        "import h5py\n",
        "import numpy as np\n",
        "import tensorflow as tf\n",
        "\n",
        "from google.colab import drive\n",
        "drive.mount('/content/drive')\n",
        "%load_ext tensorboard\n",
        "import datetime\n",
        "log_dir = \"logs/fit/\" + datetime.datetime.now().strftime(\"%Y%m%d-%H%M%S\")\n",
        "tensorboard_callback = tf.keras.callbacks.TensorBoard(log_dir=log_dir, histogram_freq=1)\n",
        "%reload_ext tensorboard\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "\n",
        "\n",
        "\n",
        "def expected_num_photons(n, p, pdg):\n",
        "\n",
        "    \"\"\"\n",
        "        filtrer ut tracks som ikke har nok photoner i relevant Ckov-sone fra pdg\n",
        "\n",
        "        Args:\n",
        "            n : refractive index\n",
        "            p : momentum\n",
        "            pdg : pdg-code\n",
        "\n",
        "        Returns :\n",
        "            Limit for evaluation in whole circle and in short side of circle\n",
        "            limit = landa - sqrt(landa)\n",
        "            limit_half = landa/2 - sqrt(landa/2)\n",
        "\n",
        "    \"\"\"\n",
        "    if abs(pdg) == 211:\n",
        "        MASS = 0.1396\n",
        "    if abs(pdg) == 321:\n",
        "        MASS = 0.4937\n",
        "    if abs(pdg) == 2212:\n",
        "        MASS = 0.9383\n",
        "\n",
        "\n",
        "    p_lim = MASS/np.sqrt(n**2 - 1)\n",
        "    p_squared = p ** 2\n",
        "    # The broadcasting here is correct, and will result in a (1000, 5) shape array\n",
        "    p_squared_plus_m_squared = p_squared + MASS ** 2\n",
        "\n",
        "    p_mask = p > p_lim  # Broadcasting comparison\n",
        "    cos_theta_c = np.sqrt((p_squared_plus_m_squared)) / (p * n)\n",
        "    sin_theta_c = np.sin(np.arccos(cos_theta_c))\n",
        "\n",
        "\n",
        "    # 15 photons @ sin^2 = 0.4\n",
        "    NUM_EXPECTED_PHOTONS_SATURATION = 15\n",
        "    num_expected_photons = sin_theta_c ** 2 * NUM_EXPECTED_PHOTONS_SATURATION / 0.4\n",
        "\n",
        "    limit_evaluate = np.floor(num_expected_photons - np.sqrt(num_expected_photons)) # poisson distribution mean - std\n",
        "    limit_evaluate_half = np.floor(num_expected_photons/2 - np.sqrt(num_expected_photons/2)) # poisson distribution mean - std\n",
        "\n",
        "    return limit_evaluate, limit_evaluate_half"
      ],
      "metadata": {
        "id": "DnXiyknxiOij"
      },
      "execution_count": 226,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "mass_Pion = 0.1396\n",
        "mass_Kaon = 0.4937\n",
        "mass_Proton = 0.938\n",
        "mass_Pion_sq = mass_Pion * mass_Pion\n",
        "mass_Kaon_sq = mass_Kaon * mass_Kaon\n",
        "mass_Proton_sq = mass_Proton * mass_Proton\n",
        "\n",
        "\n",
        "def calculate_cherenkov_tracks(p, n):\n",
        "    p_sq = np.power(p, 2)\n",
        "\n",
        "    # Calculations for min_ckov using n_min\n",
        "    cos_ckov_denom = p * n\n",
        "    cos_ckov_Pion = np.sqrt(p_sq + mass_Pion_sq) / cos_ckov_denom\n",
        "    cos_ckov_Kaon = np.sqrt(p_sq + mass_Kaon_sq) / cos_ckov_denom\n",
        "    cos_ckov_Proton = np.sqrt(p_sq + mass_Proton_sq) / cos_ckov_denom\n",
        "\n",
        "    pion_ckov = np.arccos(cos_ckov_Pion)#.reshape(-1, 1)\n",
        "    kaon_ckov = np.arccos(cos_ckov_Kaon)#.reshape(-1, 1)\n",
        "    proton_ckov = np.arccos(cos_ckov_Proton)#.reshape(-1,1)\n"
      ],
      "metadata": {
        "id": "Ltcrf5nO6mNW"
      },
      "execution_count": 227,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "def train(train_dataset, val_dataset,  model, optimizer,\n",
        "          train_acc_metric, val_acc_metric,\n",
        "          epochs=10,  log_step=200, val_log_step=50):\n",
        "\n",
        "    for epoch in range(epochs):\n",
        "        print(\"\\nStart of epoch %d\" % (epoch,))\n",
        "\n",
        "        train_loss = []\n",
        "        val_loss = []\n",
        "\n",
        "        # Iterate over the batches of the dataset\n",
        "        for step, (x_batch_train, y_batch_train) in enumerate(train_dataset):\n",
        "            loss_value = train_step(x_batch_train, y_batch_train,\n",
        "                                    model, optimizer,\n",
        "                                    loss_fn, train_acc_metric)\n",
        "            train_loss.append(float(loss_value))\n",
        "\n",
        "        # Run a validation loop at the end of each epoch\n",
        "        for step, (x_batch_val, y_batch_val) in enumerate(val_dataset):\n",
        "            val_loss_value = test_step(x_batch_val, y_batch_val,\n",
        "                                       model, loss_fn,\n",
        "                                       val_acc_metric)\n",
        "            val_loss.append(float(val_loss_value))\n",
        "\n",
        "        # Display metrics at the end of each epoch\n",
        "        train_acc = train_acc_metric.result()\n",
        "        print(\"Training acc over epoch: %.4f\" % (float(train_acc),))\n",
        "\n",
        "        val_acc = val_acc_metric.result()\n",
        "        print(\"Validation acc: %.4f\" % (float(val_acc),))\n",
        "\n",
        "        # Reset metrics at the end of each epoch\n",
        "        train_acc_metric.reset_states()\n",
        "        val_acc_metric.reset_states()\n",
        "\n",
        "        # ‚≠ê: log metrics using wandb.log\n",
        "        wandb.log({'epochs': epoch,\n",
        "                   'loss': np.mean(train_loss),\n",
        "                   'acc': float(train_acc),\n",
        "                   'val_loss': np.mean(val_loss),\n",
        "                   'val_acc':float(val_acc)})"
      ],
      "metadata": {
        "id": "H99OfkuMVK8D"
      },
      "execution_count": 228,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "sweep_config = {\n",
        "  'method': 'random',\n",
        "  'metric': {\n",
        "      'name': 'val_loss',\n",
        "      'goal': 'minimize'\n",
        "  },\n",
        "  'early_terminate':{\n",
        "      'type': 'hyperband',\n",
        "      'min_iter': 5\n",
        "  },\n",
        "  'parameters': {\n",
        "      'batch_size': {\n",
        "          'values': [32, 64, 128, 256]\n",
        "      },\n",
        "      'learning_rate':{\n",
        "          'values': [0.01, 0.005, 0.001, 0.0005, 0.0001]\n",
        "      }\n",
        "  }\n",
        "}"
      ],
      "metadata": {
        "id": "0Asb2Aq9WnwT"
      },
      "execution_count": 229,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "%%capture\n",
        "!pip install wandb\n",
        "import wandb\n",
        "from wandb.keras import WandbCallback\n"
      ],
      "metadata": {
        "id": "cGebGJvvUyks"
      },
      "execution_count": 230,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [],
      "metadata": {
        "id": "RZwQcFysU1wd"
      },
      "execution_count": 230,
      "outputs": []
    },
    {
      "cell_type": "code",
      "execution_count": 231,
      "metadata": {
        "id": "9ZXvEwR7tcRC",
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 507
        },
        "outputId": "d0e3af50-55be-48fa-a456-0222a91dfd62"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "(1000, 5)\n",
            "(1000, 5)\n"
          ]
        },
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "<Figure size 640x480 with 1 Axes>"
            ],
            "image/png": "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\n"
          },
          "metadata": {}
        }
      ],
      "source": [
        "p = np.linspace(.5, 5, 1000)[:, None]  # Reshape p to be a column vector for broadcasting\n",
        "n = 1.3\n",
        "MASS_ELECTRON = 0.000511\n",
        "MASS_MUON = 0.1057\n",
        "MASS_PION = 0.1396\n",
        "MASS_KAON = 0.4937\n",
        "MASS_PROTON = 0.9383\n",
        "masses = np.array([MASS_ELECTRON, MASS_MUON, MASS_PION, MASS_KAON, MASS_PROTON])\n",
        "\n",
        "p_lim = masses/np.sqrt(n**2 - 1)\n",
        "p_squared = p ** 2\n",
        "# The broadcasting here is correct, and will result in a (1000, 5) shape array\n",
        "p_squared_plus_m_squared = p_squared + masses ** 2\n",
        "\n",
        "p_mask = p > p_lim  # Broadcasting comparison\n",
        "cos_theta_c_hyps = np.sqrt((p_squared_plus_m_squared)) / (p * n)\n",
        "#theta_c_hyps = np.arccos(cos_theta_c_hyps)\n",
        "\n",
        "print(f\"{cos_theta_c_hyps.shape}\")\n",
        "theta_c_hyps = np.zeros_like(cos_theta_c_hyps)\n",
        "theta_c_hyps[p_mask] = np.arccos(cos_theta_c_hyps[p_mask])\n",
        "print(f\"{theta_c_hyps.shape}\")\n",
        "\n",
        "import matplotlib.pyplot as plt\n",
        "# Plotting\n",
        "species_names = ['Electron', 'Muon', 'Pion', 'Kaon', 'Proton']\n",
        "for i in range(theta_c_hyps.shape[1]):  # Loop over the number of species\n",
        "    plt.plot(p.flatten(), theta_c_hyps[:, i], label=species_names[i])\n",
        "\n",
        "plt.xlabel('Momentum (GeV/c)')\n",
        "plt.ylabel('Cherenkov Angle (rad)')\n",
        "plt.title('Cherenkov Angle vs. Momentum for Various Particles')\n",
        "plt.legend()\n",
        "plt.grid(True)\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 232,
      "metadata": {
        "id": "cSJ8n2YH2Kop"
      },
      "outputs": [],
      "source": [
        "def assign_attributes_from_group(data_dict, group, key, index_particle):\n",
        "    \"\"\"Assign attributes from the HDF5 group to the corresponding data_dict.\"\"\"\n",
        "    #print(f\" reading assign_attributes_from_group:  index_particle {index_particle } key {key} | FILL {group.attrs[key]}\")\n",
        "    data_dict[key][index_particle] = group.attrs[key]\n",
        "\n",
        "    #assign_attributes_from_group(event_data_dict, group, key, num_tracks_in_event)\n",
        "\n",
        "#assign_values_from_group(values_data_dict, group, key, index_particle, actual_length)\n",
        "\n",
        "def assign_values_from_group(data_dict, group, key, index_particle, actual_length):\n",
        "\n",
        "    if index_particle >= data_dict[key].shape[0]:\n",
        "        raise ValueError(f\"Index {index_particle} is out of bounds for data_dict[{key}] with shape {data_dict[key].shape}\")\n",
        "\n",
        "\n",
        "    # Assign the values\n",
        "    #print(f\"assign_values_from_group group{key} {group[key][...]}\")\n",
        "    try:\n",
        "        data_dict[key][index_particle, :actual_length] = group[key][...]\n",
        "    except Exception as e:\n",
        "        print(f\"An error occurred while assigning values to data_dict[{key}]: {e}\")\n",
        "        print(f\"group[key][...].shape {group[key][...].shape}\")\n",
        "        print(f\"index_particle {index_particle} | actual_length {actual_length}\")\n",
        "\n",
        "        raise\n",
        "    #print(f\"assign_values_from_group  data_dict{key} { data_dict[key][index_particle, :actual_length]}\")\n",
        "\n",
        "# assign_particle_dict(particle_dict, group, key, index_particle)\n",
        "\n",
        "\n",
        "def assign_particle_dict(particle_dict, group, key, index_particle):\n",
        "    #print(f\" reading assign_particle_dict:  index_particle {index_particle } key {key}\")\n",
        "    #print(f\" reading assign_particle_dict:   {group.attrs[key]}\")\n",
        "\n",
        "    particle_dict[key][index_particle] = group.attrs[key]\n",
        "    #print(f\"  particle_dict[key][index_particle]:   {particle_dict[key][index_particle]}\")\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 233,
      "metadata": {
        "id": "APUgd22_ffd2"
      },
      "outputs": [],
      "source": [
        "from tensorflow.keras.callbacks import Callback\n",
        "\n",
        "class GradualBatchSizeIncrease(Callback):\n",
        "    def __init__(self, start_size=16, max_size=256, increase_factor=2, interval=20):\n",
        "        super(GradualBatchSizeIncrease, self).__init__()\n",
        "        self.batch_size = start_size\n",
        "        self.max_size = max_size\n",
        "        self.increase_factor = increase_factor\n",
        "        self.interval = interval\n",
        "\n",
        "    def on_epoch_end(self, epoch, logs=None):\n",
        "        if (epoch + 1) % self.interval == 0 and self.batch_size < self.max_size:\n",
        "            self.batch_size = min(self.batch_size * self.increase_factor, self.max_size)\n",
        "            self.model.batch_size = self.batch_size\n",
        "            print(f\"\\nEpoch {epoch + 1}: Increasing batch size to {self.batch_size}.\\n\")\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 234,
      "metadata": {
        "id": "_clF1C9YOo3R"
      },
      "outputs": [],
      "source": [
        "#!wget https://raw.githubusercontent.com/eflatlan/CNN_PID/dev_floatmap/helper_functions.py\n",
        "#from helper_functions.py import print_points, plot_mapsm"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 235,
      "metadata": {
        "id": "aSJDNxh4mNUH"
      },
      "outputs": [],
      "source": [
        "# Particle masses in GeV/c^2\n",
        "MASS_ELECTRON = 0.000511\n",
        "MASS_MUON = 0.1057\n",
        "MASS_PION = 0.1396\n",
        "MASS_KAON = 0.4937\n",
        "MASS_PROTON = 0.9383\n",
        "masses = np.array([MASS_ELECTRON, MASS_MUON, MASS_PION, MASS_KAON, MASS_PROTON])\n",
        "masses = masses.reshape(1, 5)\n",
        "\n",
        "\n",
        "\n",
        "def calc_ckov_hyp_arrays(event_data_dict):\n",
        "\t\t\"\"\"\n",
        "\t\t# Calculate the ckov hyps\n",
        "\t\t# shape : num_tracks_in_event, 5 || : 5 species\n",
        "\t\ttheta_c_hyps = calc_ckov_hyp_arrays(momentums, ref_indexes)\n",
        "\t\t\"\"\"\n",
        "\t\t# fiels in event_data_dict\n",
        "\t\t#\t\t'Momentum': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t#\t\t'RefractiveIndex': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t# cos_theta_c = np.sqrt(p^2 + m^2)/(p*n)\n",
        "\t\tverbose = False\n",
        "\n",
        "\t\tif verbose:\n",
        "\t\t\tprint(f\"calc_ckov_hyp_arrays\")\n",
        "\n",
        "\t\tCluCharge  = event_data_dict['CluCharge']#  # Flattening to 1D if necessary\n",
        "\t\tif verbose:\n",
        "\t\t\tprint(f\" CluCharge  {CluCharge.flatten() } \")\n",
        "\n",
        "\t\tpdg  = event_data_dict['TrackPdg']#.flatten()  # Flattening to 1D if necessary\n",
        "\n",
        "\t\tif verbose:\n",
        "\t\t\tprint(f\" pdg  {pdg.flatten()  } \")\n",
        "\n",
        "\n",
        "\t\tmomentums = event_data_dict['Momentum']#.flatten()  # Flattening to 1D if necessary\n",
        "\t\tif verbose:\n",
        "\t\t\tprint(f\" momentums {momentums.flatten()} \")\n",
        "\n",
        "\t\trefractive_indices = event_data_dict['RefractiveIndex']#.flatten()  # Flattening to 1D if necessary\n",
        "\n",
        "\t\tif verbose:\n",
        "\t\t\tprint(f\" shape momentums {momentums.shape} | refractive_indices {refractive_indices.shape}\")\n",
        "\n",
        "\n",
        "\n",
        "\t\tmomentums = np.tile(momentums, (1, 5))\n",
        "\t\trefractive_indices = np.tile(refractive_indices, (1, 5))\n",
        "\n",
        "\t\tif verbose:\n",
        "\t\t\tprint(f\" shape momentums {momentums.shape} | refractive_indices {refractive_indices.shape}\")\n",
        "\n",
        "\t\t# to see ckov radiation per specie\n",
        "\t\t# if p > p_lim for a given specie : set mask to 0\n",
        "\n",
        "\t\t#print(f\" refractive_indices {refractive_indices} \")\n",
        "\n",
        "\t\tp_lim = masses/np.sqrt(refractive_indices**2 - 1)\n",
        "\n",
        "\t\tmasses_shaped =  np.tile(masses, (9, 1))\n",
        "\n",
        "\t\t#print(f\"shape p_lim {p_lim.shape} | shape masses_shaped {masses_shaped.shape}\")\n",
        "\n",
        "\n",
        "\t\tp_mask = momentums > p_lim\n",
        "\t\t#print(f\"shape p_lim {p_lim.shape} | shape p_mask {p_mask.shape} | shape momentums {momentums.shape}\")\n",
        "\t\t# the mask to check for radiation is now if p_mask is 1, if its 1 its radiation\n",
        "\n",
        "\n",
        "\t\tp_squared = momentums ** 2\n",
        "\t\tp_squared_plus_m_squared = p_squared + masses_shaped ** 2  # Broadcasting to shape (len(momentums), 5)\n",
        "\t\t#print(f\"shape p_squared {p_squared.shape} | shape p_squared_plus_m_squared {p_squared_plus_m_squared.shape} \")\n",
        "\n",
        "\t\t# Calculate cos(theta_c) for all hypotheses\n",
        "\t\tcos_theta_c_hyps = np.sqrt(p_squared_plus_m_squared) / (momentums * refractive_indices)\n",
        "\t\t#print(f\"shape p_squared {p_squared.shape} | shape cos_theta_c_hyps {cos_theta_c_hyps.shape} \")\n",
        "\n",
        "\t\t# Calculate theta_c from cos(theta_c)\n",
        "\t\t# Note: Where cos(theta_c) > 1 due to numerical issues, it implies no Cherenkov radiation is possible\n",
        "\t\t#\n",
        "\t\t# So we can clip the values to 1 to avoid NaNs from the arccos function\n",
        "\n",
        "\t\ttheta_c_hyps = np.zeros_like(cos_theta_c_hyps)\n",
        "\t\ttheta_c_hyps[p_mask] = np.arccos(cos_theta_c_hyps[p_mask])\n",
        "\t\t# print(f\" momentums {momentums} \")\n",
        "\t\t# print(f\" masses_shaped {masses_shaped} \")\n",
        "\n",
        "\t\t# print(f\" theta_c_hyps {theta_c_hyps} \")\n",
        "\t\t# print(f\" cos_theta_c_hyps {cos_theta_c_hyps} \")\n",
        "\t\t# print(f\" p_mask {p_mask} \")\n",
        "\n",
        "\t\treturn theta_c_hyps\n",
        "\n",
        "\n",
        "def calc_species_prob(theta_c_hyps, sigma_ring_padded, theta_cer_padded, mip_mask):\n",
        "\n",
        "\n",
        "\t\tverbose = False\n",
        "\n",
        "\t\tif verbose:\n",
        "\t\t\tprint(f\"shape of mip_mask : {mip_mask.shape}\")\n",
        "\n",
        "\t\t\"\"\"\n",
        "\t\tCalculate the species probability per photon per track, and also compute the\n",
        "\t\tlikelihood per track and across all tracks.\n",
        "\n",
        "\t\tArgs:\n",
        "\t\ttheta_c_hyps (np.array): Cherenkov angles per species, shape (n_tracks_max, 5).\n",
        "\t\tsigma_ring_padded (np.array): Standard deviations, shape (max_length, 1).\n",
        "\t\ttheta_cer_padded (np.array): Cherenkov angles, shape (max_length, 1).\n",
        "\t\tmip_mask : mask of size geq 3 AND charge geq 200\n",
        "\n",
        "\n",
        "\n",
        "\t\tReturns:\n",
        "\t\ttuple: A tuple containing:\n",
        "\t\t\t\t- p_specie_per_track: The probability of each species per photon per track,\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape (n_tracks_max, max_length, 5).\n",
        "\t\t\t\t- L_track: The likelihood of each photon per track, shape (n_tracks_max, max_length).\n",
        "\t\t\t\t- L_all_tracks: The likelihood of each photon across all tracks, shape (max_length,).\n",
        "\t\t\"\"\"\n",
        "\n",
        "\t\t#momentums = np.tile(momentums, (1, 5))\n",
        "\n",
        "\t\t# Expand the dimensions of theta_c_hyps to broadcast across the max_length dimension\n",
        "\t\ttheta_c_hyps_expanded = np.repeat(theta_c_hyps[:, np.newaxis, :], repeats=theta_cer_padded.shape[0], axis=1)  # (9, 550, 5)\n",
        "\n",
        "\t\tif verbose:\n",
        "\t\t\tprint(f\"shape of theta_c_hyps_expanded : {theta_c_hyps_expanded.shape}\")\n",
        "\n",
        "\n",
        "\t\tmip_mask = mip_mask.T\n",
        "\t\tmip_mask =  np.repeat(mip_mask[:, :, np.newaxis], repeats=theta_c_hyps.shape[1], axis=2) # shape will be (1, max_length, 1)\n",
        "\n",
        "\n",
        "\t\tif verbose:\n",
        "\t\t\tprint(f\"shape of mip_mask : {mip_mask.shape}\")\n",
        "\n",
        "\n",
        "\t\tsigma_ring_padded = sigma_ring_padded.T\n",
        "\n",
        "\t\ttheta_cer_padded = theta_cer_padded.T\n",
        "\n",
        "\t\tif verbose:\n",
        "\t\t\tprint(f\"shape of theta_cer_padded : {theta_cer_padded.shape}\")\n",
        "\n",
        "\n",
        "\t\t## \t\tmasses_shaped =  np.tile(masses, (9, 1))\n",
        "\n",
        "\t\t# Ensure sigma_ring_padded and theta_cer_padded are expanded to have a last dimension of 1 for broadcasting\n",
        "\t\tsigma_ring_padded_expanded =  np.repeat(sigma_ring_padded[:, :, np.newaxis], repeats=theta_c_hyps.shape[1], axis=2) # shape will be (1, max_length, 1)\n",
        "\t\ttheta_cer_padded_expanded =  np.repeat(theta_cer_padded[:, :, np.newaxis], repeats=theta_c_hyps.shape[1], axis=2) # shape will be (1, max_length, 1)\n",
        "\n",
        "\t\tif verbose:\n",
        "\t\t\tprint(f\"shape of theta_cer_padded_expanded : {theta_cer_padded_expanded.shape}\")\n",
        "\t\t\tprint(f\"shape of sigma_ring_padded_expanded : {sigma_ring_padded_expanded.shape}\")\n",
        "\n",
        "\t\t# Calculate the z-score\n",
        "\t\tnum_tracks = sigma_ring_padded_expanded.shape[0]\n",
        "\n",
        "\t\tmip_mask =  np.repeat(mip_mask[:, :, :], repeats=num_tracks, axis=0) # shape will be (1, max_length, 1)\n",
        "\n",
        "\t\tif verbose:\n",
        "\t\t\tprint(f\"shape of mip_mask : {mip_mask.shape}\")\n",
        "\n",
        "\n",
        "\t\ttheta_cer_padded_expanded =  np.repeat(theta_cer_padded[:, :, np.newaxis], repeats=theta_c_hyps.shape[1], axis=2) # shape will be (1, max_length, 1)\n",
        "\n",
        "\n",
        "\t\t#\t\t# The shape of z will be (n_tracks, max_length, 5) after broadcasting\n",
        "\n",
        "\t\t#z_track_number[<number>, :] = # take sum of all other tracks\n",
        "\t\t# sum of [n_tracks, :, 5] # so sum over the 5 dimensions and the number of tracks !\n",
        "\t\t# also count the numbers\n",
        "\t\t#print(f\"theta_c_hyps_expanded: {theta_c_hyps_expanded[:5,:10,:5]}\")\n",
        "\n",
        "\t\tsigma_mask = (sigma_ring_padded_expanded > 0) & (sigma_ring_padded_expanded < 10)\n",
        "\t\ttheta_mask = theta_cer_padded_expanded >= 0\n",
        "\n",
        "\n",
        "\t\tsigma_ring_padded_expanded[~sigma_mask] = 0\n",
        "\t\ttheta_cer_padded_expanded[~theta_mask] = 0\n",
        "\n",
        "\t\t# Now z_sum_over_tracks_and_species will have the shape (max_length,)\n",
        "\t\t#print(f\"theta_c_hyps_expanded: {theta_c_hyps_expanded[:5,:,:5]}\")\n",
        "\n",
        "\n",
        "\t\tsigma_ring_padded_expanded = np.clip(sigma_ring_padded_expanded, 0, 0.02) #\n",
        "\n",
        "\n",
        "\t\t# shape : n_tracks x n_photons x n_species # n_species : 5\n",
        "\t\t# print(f\"sigma_ring_padded_expandeds: {sigma_ring_padded_expanded[:5,:10,:5]}\")\n",
        "\t\t# print(f\"theta_cer_padded_expanded: {theta_cer_padded_expanded[:5,:10,:5]}\")\n",
        "\n",
        "\t\tz = (theta_c_hyps_expanded[:num_tracks,:,:] - theta_cer_padded_expanded) / sigma_ring_padded_expanded  # Broadcasting\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\t\t# only accept +- 2 std-devs\n",
        "\t\tz_mask = (z < 2) & (z > -2)\n",
        "\t\tz[mip_mask == True] = 0\n",
        "\n",
        "\t\tz[z_mask == False] = 0\n",
        "\n",
        "\n",
        "\n",
        "\t\tvalid_counts_per_photon = np.count_nonzero(z, axis=(0, 2))\n",
        "\n",
        "\n",
        "\t\tif verbose or True:\n",
        "\t\t\tprint(f\"shape of theta_c_hyps_expanded: {theta_c_hyps_expanded.shape}\")\n",
        "\t\t\tprint(f\"shape of theta_cer_padded_expanded: {theta_cer_padded_expanded.shape}\")\n",
        "\t\t\tprint(f\"shape of sigma_ring_padded_expanded: {sigma_ring_padded_expanded.shape}\")\n",
        "\n",
        "\t\t\tprint(f\"shape of z-score array: {z.shape}\")\n",
        "\t\t\tprint(f\"SHAPE  Valid counts per photon: {valid_counts_per_photon.shape}\")\n",
        "\n",
        "\t\t#print(f\"Valid counts per photon:  {valid_counts_per_photon[:5]}\")\n",
        "\n",
        "\t\t#HM = sum_i  1/(1/z_i) # harmomic mean\n",
        "\t\t# probability :\n",
        "\t\t# w_i = e^{-z_i} /(Sum_(i=1...n)e^{-z_j}) # weight\n",
        "\n",
        "\t\tfrom scipy.stats import norm\n",
        "\t\t# p-value from error-function of z-score\n",
        "\n",
        "\t\t#print(f\"mip_mask array: {mip_mask[:5,:10,:5]}\")\n",
        "\n",
        "\t\t#print(f\"z-score array: {z[:5,:10,:5]}\")\n",
        "\n",
        "\t\t# find related x-score med andre tracks\n",
        "\t\tp_value = norm.pdf(z)\n",
        "\n",
        "\n",
        "\n",
        "\t\tprint(f\"nonzero p_value: {np.count_nonzero(p_value)}\")\n",
        "\n",
        "\t\tnonzero_count_vector = np.count_nonzero(p_value, axis=(0, 1))\n",
        "\n",
        "\t\t# Reshaping to 5x1 if necessary\n",
        "\t\tnonzero_count_vector_5x1 = nonzero_count_vector.reshape(-1, 1)\n",
        "\t\tprint(f\"nonzero p_value: {nonzero_count_vector_5x1}\")\n",
        "\n",
        "\t\tp_value[z_mask == False] = 0\n",
        "\n",
        "\t\tprint(f\"nonzero p_value[z_mask]: {np.count_nonzero(p_value)}\")\n",
        "\n",
        "\n",
        "\t\tnonzero_count_vector = np.count_nonzero(p_value, axis=(0, 1))\n",
        "\n",
        "\t\t# Reshaping to 5x1 if necessary\n",
        "\t\tnonzero_count_vector_5x1 = nonzero_count_vector.reshape(-1, 1)\n",
        "\t\tprint(f\"nonzero p_value[z_mask]: {nonzero_count_vector_5x1}\")\n",
        "\n",
        "\n",
        "\t\t# sett p verdier til MIP til 0\n",
        "\t\tp_value[mip_mask == True] = 0\n",
        "\t\tprint(f\"nonzero p_value[mip_mask]: {np.count_nonzero(p_value)}\")\n",
        "\n",
        "\t\tnonzero_count_vector = np.count_nonzero(p_value, axis=(0, 1))\n",
        "\n",
        "\t\t# Reshaping to 5x1 if necessary\n",
        "\t\tnonzero_count_vector_5x1 = nonzero_count_vector.reshape(-1, 1)\n",
        "\t\tprint(f\"nonzero p_value[mip_mask]: {nonzero_count_vector_5x1}\")\n",
        "\n",
        "\t\tif verbose:\n",
        "\n",
        "\t\t\tprint(f\"shape of z-score array: {z.shape}\")\n",
        "\t\t\tprint(f\"SHAPE  Valid counts per photon: {valid_counts_per_photon.shape}\")\n",
        "\n",
        "\t\t#print(f\"p_value-score array: {p_value[:5,:,:5]}\")\n",
        "\t\t# Normalize these likelihoods to get the probability of each species within a track (p_specie)\n",
        "\t\t# (num_tracks, num_photons, num_species) -> (num_tracks, num_photons, num_species)\n",
        "\t\tp_specie_per_track = p_value / np.sum(p_value, axis=2, keepdims=True)\n",
        "\t\t#print(f\"p_specie_per_track-score array: {p_specie_per_track[:5,:10,:5]}\")\n",
        "\n",
        "\n",
        "\t\t# L_track : likelihood : sum of species-likelihood per track\n",
        "\t\tL_track = np.sum(p_value, axis=2)  # Shape: (num_tracks, num_photons)\n",
        "\t\t#print(f\"L_track array: {L_track[:10,:5]}\")\n",
        "\n",
        "\t\t# Sum L_track across all tracks for each photon:\n",
        "\t\t# This represents the total likelihood of each photon being part of any track\n",
        "\t\tL_all_tracks = np.sum(L_track, axis=0)  # Shape: (num_photons,)\n",
        "\n",
        "\t\treturn p_specie_per_track, L_track, L_all_tracks, z_mask\n",
        "\n",
        "\t\t# def\tcalc_species_prob(theta_c_hyps, sigma_ring_padded, theta_cer_padded)\n",
        "\t\t# \t\t\"\"\"\n",
        "\t\t# \t\t\t\t# max_length, num_tracks_in_event, 5 : probability per photon per track\n",
        "\n",
        "\t\t# \t\t\"\"\"\n",
        "\t\t# \t\tprint(f\"shape theta_c_hyps {theta_c_hyps.shape} |  sigma_ring_padded {sigma_ring_padded.shape} } |  theta_cer_padded {theta_cer_padded.shape} \")\n",
        "\t\t# \t\tz = (theta_c_hyps - theta_cer_padded) / sigma_ring_padded\n",
        "\n",
        "\n",
        "def pad_and_stack2(sequences, max_length=None):\n",
        "\ttry:\n",
        "\t\t# Try padding, if max_length is not None, pad or truncate to that length\n",
        "\t\tpadded_sequences = pad_sequences(sequences, maxlen=max_length, padding='post', dtype='float32')  # Changed dtype to 'floar32'\n",
        "\t\t#print(\"padded ok\")\n",
        "\texcept ValueError:\n",
        "\t\t# Fallback: manually pad with zeros\n",
        "\t\tmax_len = max_length if max_length is not None else max(len(seq) for seq in sequences)\n",
        "\t\tpadded_sequences = np.array([np.pad(seq, (0, max_len - len(seq)), 'constant', constant_values=0) for seq in sequences])\n",
        "\t\t#print(\"revert to other pad\")\n",
        "\n",
        "\treturn padded_sequences\n",
        "\n",
        "\n",
        "def pad_and_stack3(sequences, max_length=None):\n",
        "\t\t# Check if sequences is a single numpy array and not a list of sequences.\n",
        "\t\t# If it's a single array, wrap it in a list.\n",
        "\t\tif isinstance(sequences, np.ndarray) and sequences.ndim == 1:\n",
        "\t\t\t\tsequences = [sequences]  # Wrap the single array in a list to create a list of sequences.\n",
        "\n",
        "\t\ttry:\n",
        "\t\t\t\t# Try padding, if max_length is not None, pad or truncate to that length.\n",
        "\t\t\t\tpadded_sequences = pad_sequences(sequences, maxlen=max_length, padding='post', dtype='float32')  # dtype was corrected to 'float32'.\n",
        "\t\t\t\t#print(\"padded ok\")\n",
        "\t\texcept ValueError as e:\n",
        "\t\t\t\tprint(f\"pad_and_stack3 : ValueError: {e}\")  # Print the error for debugging.\n",
        "\t\t\t\t# Fallback: manually pad with zeros if there's an error.\n",
        "\t\t\t\tmax_len = max_length if max_length is not None else max(len(seq) for seq in sequences)\n",
        "\t\t\t\tpadded_sequences = np.array([np.pad(seq, (0, max_len - len(seq)), 'constant', constant_values=0) for seq in sequences])\n",
        "\t\t\t\t#print(\"reverted to manual padding\")\n",
        "\n",
        "\t\tif padded_sequences.shape[1] == max_length:\n",
        "\t\t\t\tpadded_sequences = padded_sequences.transpose()\n",
        "\n",
        "\n",
        "\t\treturn padded_sequences\n",
        "\n",
        "import numpy as np\n",
        "import numpy as np\n",
        "\n",
        "\n",
        "\n",
        "# \t\tclassify_candidates_with_pad_sequences2(other_tracks_dict, event_data_dict, values_data_dict, all_events_data, index_particle, num_tracks_in_event, max_clu_in_event, max_clu_in_event)\n",
        "\n",
        "def classify_candidates_with_pad_sequences2(other_tracks_dict, event_data_dict, values_data_dict, all_events_data, index_particle, num_tracks_in_event, max_clu_in_event, SPECIES_DICTIONARY, INDEX_VALID_PION, INDEX_VALID_PROTON, INDEX_VALID_KAON):\n",
        "\n",
        "\t\tprint(\"\\n\\n ====================== \\n\\n\")\n",
        "\t\tPION_data = SPECIES_DICTIONARY[\"PION_data\"]\n",
        "\t\tKAON_data = SPECIES_DICTIONARY[\"KAON_data\"]\n",
        "\t\tPROTON_data = SPECIES_DICTIONARY[\"PROTON_data\"]\n",
        "\n",
        "\n",
        "\t\tverbose = False\n",
        "\t\t\"\"\"\n",
        "\n",
        "\t\tDict to be filled :\n",
        "\t\tother_tracks_dict\n",
        "\t\t{\n",
        "\t\t\t'Momentum': np.zeros((num_particles, max_tracks_in_event)),\n",
        "\t\t\t\t\t'RefractiveIndex': np.zeros((num_particles, max_tracks_in_event)),\n",
        "\t\t\t\t\t'xRad': np.zeros((num_particles, max_tracks_in_event)),\n",
        "\t\t\t\t\t'yRad': np.zeros((num_particles, max_tracks_in_event)),\n",
        "\t\t\t\t\t'xMip': np.zeros((num_particles, max_tracks_in_event)),\n",
        "\t\t\t\t\t'yMip': np.zeros((num_particles, max_tracks_in_event)),\n",
        "\t\t\t\t\t'ThetaP': np.zeros((num_particles, max_tracks_in_event)),\n",
        "\t\t\t\t\t'PhiP': np.zeros((num_particles, max_tracks_in_event)),\n",
        "\t\t\t\t\t'CluCharge': np.zeros((num_particles, max_tracks_in_event)),\n",
        "\t\t\t\t\t'CluSize': np.zeros((num_particles, max_tracks_in_event)),\n",
        "\t\t\t\t\t'TrackPdg': np.zeros((num_particles, max_tracks_in_event)),\n",
        "\t\t\t\t\t'ckovReconstructed': np.zeros((num_particles, max_tracks_in_event))\n",
        "\t\t\t}\n",
        "\n",
        "\n",
        "\t\t\t# just tbs\n",
        "\t\t\tevent_data_dict = {\n",
        "\t\t\t\t\t'Momentum': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t\t'RefractiveIndex': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t\t'xRad': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t\t'yRad': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t\t'xMip': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t\t'yMip': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t\t'ThetaP': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t\t'PhiP': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t\t'CluCharge': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t\t'CluSize': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t\t'TrackPdg': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t\t'ckovReconstructed': np.zeros((max_tracks_in_event, 1))\n",
        "\t\t\t}\n",
        "\n",
        "\t\t\"\"\"\n",
        "\n",
        "\n",
        "#\tclassify_candidates_with_pad_sequences2(other_tracks_dict, event_data_dict, values_data_dict, index_particle, num_tracks_in_event, max_clu_in_event)\n",
        "\n",
        "\n",
        "\t\t# values_data_dict = {\n",
        "\t\t#     --> same for tracks :\n",
        "\t\t# \t\t'xValues': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t# \t\t'yValues': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t# \t\t'chi2Values': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t# \t\t'qValues': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t# \t\t'xeValues': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t# \t\t'yeValues': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t# \t\t'sizeClu': np.zeros((num_particles, max_clu_in_event))\n",
        "\n",
        "\t\t#     --> indivdual for tracks\n",
        "\t\t#     'candStatusValues': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t# \t\t'phiCerValues': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t# \t\t'thetaCerValues': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t# \t\t'sigmaRingValues': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t# }\n",
        "\n",
        "\t\t# Calculate the starting index for slicing\n",
        "\n",
        "\n",
        "\t\tindex_start = index_particle - num_tracks_in_event\n",
        "\n",
        "\t\t# hvis num_tracks_in_event > 0 : pga python slicing\n",
        "\t\tindex_end = index_particle + 1\n",
        "\n",
        "\t\t#print(f\"other_tracks_dict some_key shape {np.array(other_tracks_dict['Momentum']).shape} | event_data_dict some_key shape {np.array(event_data_dict['Momentum']).shape}\")\n",
        "\t\ttheta_c_hyps = calc_ckov_hyp_arrays(event_data_dict)\n",
        "\n",
        "\t\tmax_tracks_in_event = theta_c_hyps.shape[0]\n",
        "\n",
        "\n",
        "\t\tif verbose : print(f\"classify_candidates_with_pad_sequences2  | : index_start: {index_start}, index_particle: {index_particle}, num_tracks_in_event: {num_tracks_in_event}\")\n",
        "\t\tif verbose : print(f\"theta_c_hyps {theta_c_hyps}\")\n",
        "\n",
        "\n",
        "\t\t# Function to fill the dictionary for index N\n",
        "\t\tdef fill_dict_for_index_N(SPECIE_data, INDEX, pions, kaons, protons, index_of_track): # litt d√∏d atm, pion_kaon_proton_dict er internt i denne og hadron_candidate_dict er eksternt :)\n",
        "\t\t\tcandidate_dict = SPECIE_data[\"CANDIDATES\"]\n",
        "\t\t\tprint(f\"fill_dict_for_index_N reading index {index_of_track}\")\n",
        "\n",
        "\t\t\tpions_of_track = pions[:, index_of_track, :]  #\n",
        "\t\t\tkaons_of_track = kaons[:, index_of_track, :]  #\n",
        "\t\t\tproton_of_track = protons[:, index_of_track, :]  #\n",
        "\n",
        "\t\t\tfor key in candidate_dict.keys():\n",
        "\t\t\t\tprint(f\"key {key}\")\n",
        "\t\t\t\tauto = candidate_dict[key]\n",
        "\n",
        "\n",
        "\n",
        "\t\t\ttry:\n",
        "\t\t\t\tpions = candidate_dict['PIONS']  # Access the 'PIONS' data\n",
        "\t\t\t\tkaons = candidate_dict['KAONS']  # Access the 'PIONS' data\n",
        "\t\t\t\tprotons = candidate_dict['PROTONS']  # Access the 'PIONS' data\n",
        "\t\t\texcept Exception as e:\n",
        "\t\t\t\tprint(f\"An error occurred: {e}\")\n",
        "\n",
        "\n",
        "\t\t\t#print(f\"keys ok\")\n",
        "\n",
        "\n",
        "\t\t\t# Assign the data to the dictionary\n",
        "\t\t\tkeys = list(protons.keys())\n",
        "\t\t\t# for i, key in enumerate(keys):\n",
        "\t\t\t# \tprint(f\"key {key}\")\n",
        "\n",
        "\t\t\tfor i, key in enumerate(keys):\n",
        "\t\t\t\t#print(f\"key {key}\")\n",
        "\t\t\t\t# Assign the value to the entire row N\n",
        "\n",
        "\t\t\t\t# print(f\"shape pions_of_track {(np.array(pions_of_track)).shape}\")\n",
        "\t\t\t\t# print(f\"shape pions[key] {(np.array(pions[key])).shape}\")\n",
        "\n",
        "\n",
        "\t\t\t\t# print(f\"SHAPE pions_of_track[:, i] {(np.array( pions_of_track[:, i])).shape}\")\n",
        "\t\t\t\t# print(f\"SHAPE pions[key][INDEX, :] {(np.array(pions[key][INDEX, :])).shape}\")\n",
        "\n",
        "\n",
        "\t\t\t\t# try:\n",
        "\t\t\t\t# \tprint(f\"pions_of_track[:, i] {pions_of_track[:, i]}\")\n",
        "\t\t\t\t# except Exception as e:\n",
        "\t\t\t\t# \tprint(f\"pions_of_track An error occurred: {e}\")\n",
        "\n",
        "\n",
        "\t\t\t\ttry:\n",
        "\t\t\t\t\tpions[key][INDEX, :] = pions_of_track[:, i]\n",
        "\t\t\t\texcept Exception as e:\n",
        "\t\t\t\t\tprint(f\"An error occurred: {e}\")\n",
        "\t\t\t\tkaons[key][INDEX, :] = kaons_of_track[:, i]\n",
        "\t\t\t\tprotons[key][INDEX, :] = proton_of_track[:, i]\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\t\t# fill OTHER_TRACK of SPECIE_data\n",
        "\t\tdef fill_other_tracks(SPECIE_data, INDEX):\n",
        "\t\t\tother_tracks = SPECIE_data[\"OTHER_TRACK\"]\n",
        "\t\t\t# Iterate over the keys in event_data_dict\n",
        "\t\t\tfor key in event_data_dict:\n",
        "\n",
        "\t\t\t\tif key in event_data_dict:\n",
        "\t\t\t\t\t# Check the shape before assignment\n",
        "\t\t\t\t\t#print(f\"Shape of target: {other_tracks_dict[key][index_start, :].shape}\")\n",
        "\t\t\t\t\t#print(f\"Shape of data to assign: {event_data_dict[key].T.shape}\")\n",
        "\n",
        "\t\t\t\t\t# Perform the assignment\n",
        "\t\t\t\t\t#print(f\"Target slice before assignment: {other_tracks_dict[key][index_start, :]}\")\n",
        "\t\t\t\t\ttry:\n",
        "\t\t\t\t\t\tother_tracks[key][INDEX, :] = event_data_dict[key].T\n",
        "\t\t\t\t\texcept Exception as e:\n",
        "\t\t\t\t\t\tprint(f\"fill_other_tracks _ An error occurred: {e} | for key  {key}, filling w shape {(event_data_dict[key]).shape}\")\n",
        "\t\t\t\t\t#print(f\"To be assigned: {event_data_dict[key].T}\")\n",
        "\n",
        "\t\t\t\t\t# After assignment\n",
        "\t\t\t\t\t#print(f\"Target slice after assignment: {other_tracks_dict[key][index_start, :]}\")\n",
        "\t\t\t\telse:\n",
        "\t\t\t\t\tprint(f\"Warning: Key {key} not found in event_data_dict.\")\n",
        "\n",
        "\n",
        "\t\t\tother_tracks['CkovTheoretical'][INDEX, :] = theta_c_hyps[:, 2:] # theta_c_hyps should be shape ((max_tracks_in_event, 3))\n",
        "\n",
        "\n",
        "\n",
        "\t\t# fill CURRENT_TRACK of CURRENT_TRACK\n",
        "\t\tdef fill_current_track(SPECIE_data, INDEX, index_of_track, mip_to_model):\n",
        "\t\t\tcurrent_track = SPECIE_data[\"CURRENT_TRACK\"]\n",
        "\t\t\t# Iterate over the keys in event_data_dict\n",
        "\t\t\tfor key in event_data_dict:\n",
        "\n",
        "\t\t\t\tif key in event_data_dict:\n",
        "\t\t\t\t\t# Check the shape before assignment\n",
        "\t\t\t\t\t#print(f\"Shape of target: {other_tracks_dict[key][index_start, :].shape}\")\n",
        "\t\t\t\t\t#print(f\"Shape of data to assign: {event_data_dict[key].T.shape}\")\n",
        "\n",
        "\t\t\t\t\t# Perform the assignment\n",
        "\t\t\t\t\t#print(f\"Target slice before assignment: {other_tracks_dict[key][index_start, :]}\")\n",
        "\n",
        "\t\t\t\t\ttry:\n",
        "\t\t\t\t\t\tcurrent_track[key][INDEX, :] = event_data_dict[key][index_of_track, :]\n",
        "\t\t\t\t\texcept Exception as e:\n",
        "\n",
        "\t\t\t\t\t\tprint(f\"fill_current_track _ An error occurred: {e} | for key  {key}, filling w shape {(event_data_dict[key][index_of_track, :]).shape}\")\n",
        "\t\t\t\t\t# After assignment\n",
        "\t\t\t\t\t#print(f\"Target slice after assignment: {other_tracks_dict[key][index_start, :]}\")\n",
        "\t\t\t\telse:\n",
        "\t\t\t\t\tprint(f\"Warning: Key {key} not found in event_data_dict.\")\n",
        "\n",
        "\n",
        "\t\t\ttry:\n",
        "\t\t\t\tcurrent_track['CkovTheoretical'][INDEX, :] = theta_c_hyps[index_of_track, 2:] # theta_c_hyps should be shape ((max_tracks_in_event, 3))\n",
        "\t\t\texcept Exception as e:\n",
        "\t\t\t\tprint(f\"fill_current_track _ An error occurred: {e} | for current_track['CkovTheoretical'][INDEX, :],  w shape {(current_track['CkovTheoretical'][INDEX, :]).shape}\")\n",
        "\n",
        "\n",
        "\t\t\ttry:\n",
        "\t\t\t\tcurrent_track['MIPS'][INDEX, :] = mip_to_model[:,0,:] # high_charge_size should be shape ((max_num_mips_all_events, 4))\n",
        "\t\t\texcept Exception as e:\n",
        "\t\t\t\tprint(f\"fill_current_track _ An error occurred: {e} | for current_track['MIPS'][INDEX, :],  w shape {(current_track['MIPS'][INDEX, :]).shape}\")\n",
        "\n",
        "\n",
        "\n",
        "\t\t# Iterate over the keys in other_tracks_dict\n",
        "\t\tfor key in other_tracks_dict:\n",
        "\n",
        "\t\t\t\tif key in event_data_dict:  # Check if the key exists in event_data_dict\n",
        "\t\t\t\t\t\t#other_tracks_dict[key][index_start:index_particle, :num_tracks_in_event] = event_data_dict[key]\n",
        "\n",
        "\t\t\t\t\t\t# Check the resulting shapes\n",
        "\t\t\t\t\t\tif index_start == index_particle and num_tracks_in_event == 0:\n",
        "\t\t\t\t\t\t\t\t# Check the shape before assignment\n",
        "\t\t\t\t\t\t\t\t#print(f\"Shape of target: {other_tracks_dict[key][index_start, :].shape}\")\n",
        "\t\t\t\t\t\t\t\t#print(f\"Shape of data to assign: {event_data_dict[key].T.shape}\")\n",
        "\n",
        "\t\t\t\t\t\t\t\t# Perform the assignment\n",
        "\t\t\t\t\t\t\t\t#print(f\"Target slice before assignment: {other_tracks_dict[key][index_start, :]}\")\n",
        "\n",
        "\t\t\t\t\t\t\t\tother_tracks_dict[key][index_start, :] = event_data_dict[key].T\n",
        "\n",
        "\n",
        "\t\t\t\t\t\t\t\t#print(f\"To be assigned: {event_data_dict[key].T}\")\n",
        "\n",
        "\t\t\t\t\t\t\t\t# After assignment\n",
        "\t\t\t\t\t\t\t\t#print(f\"Target slice after assignment: {other_tracks_dict[key][index_start, :]}\")\n",
        "\n",
        "\n",
        "\t\t\t\t\t\telif index_start < index_particle and num_tracks_in_event > 0:\n",
        "\t\t\t\t\t\t\t\t# Check the shape before assignment\n",
        "\t\t\t\t\t\t\t\t#print(f\"Shape of target: {other_tracks_dict[key][index_start:index_particle, :].shape}\")\n",
        "\t\t\t\t\t\t\t\t#print(f\"Shape of data to assign: {event_data_dict[key].T.shape}\")\n",
        "\n",
        "\t\t\t\t\t\t\t\t# Perform the assignment\n",
        "\t\t\t\t\t\t\t\t#print(f\"Target slice before assignment: {other_tracks_dict[key][index_start:index_particle, :]}\")\n",
        "\t\t\t\t\t\t\t\t#print(f\"To be assigned: {event_data_dict[key].T}\")\n",
        "\n",
        "\t\t\t\t\t\t\t\t# Assignment operation\n",
        "\t\t\t\t\t\t\t\tother_tracks_dict[key][index_start:index_end, :] = event_data_dict[key].T\n",
        "\n",
        "\t\t\t\t\t\t\t\t# After assignment\n",
        "\t\t\t\t\t\t\t\t#print(f\"Target slice after assignment: {other_tracks_dict[key][index_start:index_particle, :]}\")\n",
        "\t\t\t\t\t\telse:\n",
        "\t\t\t\t\t\t\t\tprint(\"Invalid indices for broadcasting.\")\n",
        "\t\t\t\t\t\t# Before assignment\n",
        "\n",
        "\n",
        "\t\t\t\telse:\n",
        "\t\t\t\t\t\tprint(f\"Warning: Key {key} not found in event_data_dict.\")\n",
        "\n",
        "\t\t# values_data_dict = {\n",
        "\t\t# \t\t'x_values': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t# \t\t'y_values': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t# \t\t'chi2_values': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t# \t\t'q_values': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t# \t\t'xe_values': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t# \t\t'ye_values': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t# \t\t'candStatusCkov_values': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t# \t\t'phiCerValues': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t# \t\t'thetaCerValues': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t# \t\t'sigmaRingValues': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t# \t\t'mSize_values': np.zeros((num_particles, max_clu_in_event))\n",
        "\t\t# }\n",
        "\n",
        "\n",
        "\n",
        "\t\t# Ensure x_values_data has the right dimension\n",
        "\t\t#if np.ndim(x_values_data) == 1:\n",
        "\t\t#\tx_values_data = np.expand_dims(x_values_data, axis=-1)\n",
        "\t\t#print(f\"classify_candidates_with_pad_sequences2 : Trying to pad values ... \")\n",
        "\t\tauto = values_data_dict['x_values'][index_start, :]\n",
        "\t\tx_padded, y_padded, q_padded, size_padded = (np.zeros((max_clu_in_event, 1)) for _ in range(4))\n",
        "\t\t#print(f\"x_padded shape : {x_padded.shape}\")\n",
        "\t\t#print(f\"index_start: {index_start}, index_particle: {index_particle}, num_tracks_in_event: {num_tracks_in_event}\")\n",
        "\n",
        "\t\t# Pad the sequences\n",
        "\t\t# these fields should be the same for all tracks from index_start to index_particle\n",
        "\t\t#print(f\"Trying to pad : {values_data_dict['x_values'][index_start, :].shape}\")\n",
        "\n",
        "\t\tx_padded = pad_and_stack3(values_data_dict['x_values'][index_start, :], max_length=max_clu_in_event)\n",
        "\t\ty_padded = pad_and_stack3(values_data_dict['y_values'][index_start, :], max_length=max_clu_in_event)\n",
        "\t\tq_padded = pad_and_stack3(values_data_dict['q_values'][index_start, :], max_length=max_clu_in_event)\n",
        "\t\tsize_padded = pad_and_stack3(values_data_dict['mSize_values'][index_start, :], max_length=max_clu_in_event)\n",
        "\n",
        "\n",
        "\t\t#print(f\"shape x_padded {x_padded.shape}\")\n",
        "\t\t# print(f\"shape y_padded {y_padded.shape}\")\n",
        "\t\t# print(f\"shape q_padded {q_padded.shape}\")\n",
        "\n",
        "\n",
        "\t\tif num_tracks_in_event > 0:\n",
        "\t\t\t\t#print(f\"Trying to pad : candStatus_padded {values_data_dict['candStatusCkov_values'][index_start:index_particle, :].shape}\")\n",
        "\n",
        "\t\t\t\tif verbose: print(f\"candStatus_padded \")\n",
        "\t\t\t\tcandStatus_padded = np.zeros((max_clu_in_event, num_tracks_in_event))\n",
        "\t\t\t\tif verbose: print(f\"candStatus_padded pad_and_stack3 \")\n",
        "\n",
        "\t\t\t\tcandStatus_padded = pad_and_stack3(values_data_dict['candStatusCkov_values'][index_start:index_end, :], max_length=max_clu_in_event).astype(int)\n",
        "\t\t\t\tif verbose: print(f\"phi_cer_padded pad_and_stack3 \")\n",
        "\n",
        "\t\t\t\tphi_cer_padded = pad_and_stack3(values_data_dict['phiCerValues'][index_start:index_end, :], max_length=max_clu_in_event)\n",
        "\t\t\t\tif verbose: print(f\"theta_cer_padded pad_and_stack3 \")\n",
        "\n",
        "\n",
        "\t\t\t\ttheta_cer_padded = pad_and_stack3(values_data_dict['thetaCerValues'][index_start:index_end, :], max_length=max_clu_in_event)\n",
        "\n",
        "\t\t\t\tif verbose: print(f\"sigma_ring_padded pad_and_stack3 \")\n",
        "\n",
        "\t\t\t\tsigma_ring_padded = pad_and_stack3(values_data_dict['sigmaRingValues'][index_start:index_end, :], max_length=max_clu_in_event)\n",
        "\n",
        "\n",
        "\n",
        "\t\t\t\t# for key in event_data_dict:\n",
        "\t\t\t\t#     print(f\"event_data_dict : key : {key} { event_data_dict[key].flatten() }\")\n",
        "\n",
        "\n",
        "\t\telse :\n",
        "\t\t\t\tif verbose: print(f\"candStatus_padded pad_and_stack3 \")\n",
        "\n",
        "\t\t\t\t#print(f\"Trying to pad : candStatus_padded {values_data_dict['candStatusCkov_values'][index_start, :].shape}\")\n",
        "\t\t\t\tcandStatus_padded = np.zeros((max_clu_in_event, 1))\n",
        "\n",
        "\t\t\t\tif verbose: print(f\"candStatus_padded pad_and_stack3 \")\n",
        "\n",
        "\n",
        "\t\t\t\t# print(f\"Trying to pad : candStatus_padded {values_data_dict['candStatus_padded'][index_start, :].shape}\")\n",
        "\n",
        "\n",
        "\n",
        "\t\t\t\tcandStatus_padded = pad_and_stack3(values_data_dict['candStatusCkov_values'][index_start, :], max_length=max_clu_in_event).astype(int)\n",
        "\n",
        "\t\t\t\tif verbose: print(f\"phi_cer_padded = event_data3 \")\n",
        "\n",
        "\t\t\t\tphi_cer_padded = pad_and_stack3(values_data_dict['phiCerValues'][index_start, :], max_length=max_clu_in_event)\n",
        "\t\t\t\tif verbose: print(f\"theta_cer_padded = event_data3 \")\n",
        "\n",
        "\n",
        "\t\t\t\ttheta_cer_padded = pad_and_stack3(values_data_dict['thetaCerValues'][index_start, :], max_length=max_clu_in_event)\n",
        "\n",
        "\t\t\t\tif verbose: print(f\"sigma_ring_padded = event_data3 \")\n",
        "\n",
        "\t\t\t\tsigma_ring_padded = pad_and_stack3(values_data_dict['sigmaRingValues'][index_start, :], max_length=max_clu_in_event)\n",
        "\t\t\t\tif verbose: print(f\"size = event_data3 \")\n",
        "\n",
        "\n",
        "\n",
        "\t\t# check if MIP\n",
        "\t\tmip_mask_condition = (q_padded >= 200) & (size_padded >= 3)\n",
        "\t\ttrue_count_mip = np.sum(mip_mask_condition)\n",
        "\n",
        "\t\tprint(f\"mip_mask_condition  {mip_mask_condition[:20].T}\")\n",
        "\t\tprint(f\"q_padded  {q_padded[:20].T}\")\n",
        "\t\tprint(f\"values_data_dict q_values  {values_data_dict['q_values'][index_start, :20].T}\")\n",
        "\n",
        "\t\tprint(f\"size_padded  {size_padded[:20].T}\")\n",
        "\t\tprint(f\"values_data_dict mSize_values  {values_data_dict['mSize_values'][index_start, :20].T}\")\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\t\tverbose = False\n",
        "\n",
        "\t\t#if verbose: print(f\"size_padded >= 3n count_nonzero {np.count_nonzero(size_padded >= 30)}\")\n",
        "\t\t# if verbose: print(f\"size_padded >= 1 count_nonzero {np.count_nonzero(size_padded >= 1)}\")\n",
        "\t\t# if verbose: print(f\"size_padded >= 2 count_nonzero {np.count_nonzero(size_padded >= 2)}\")\n",
        "\t\t# if verbose: print(f\"size_padded >= 3n count_nonzero {np.count_nonzero(size_padded >= 3)}\")\n",
        "\t\t# if verbose: print(f\"size_padded >= 4 count_nonzero {np.count_nonzero(size_padded >= 4)}\")\n",
        "\t\t# if verbose: print(f\"q_padded >= 200n count_nonzero {np.count_nonzero(q_padded >= 200)}\")\n",
        "\t\tif verbose: print(f\"mip_mask_condition count_nonzero {np.count_nonzero(mip_mask_condition)}\")\n",
        "\t\tprint(f\"mip_mask_condition true_count_mip {true_count_mip}\")\n",
        "\n",
        "\t\tnum_features = 12 # added phi theta sigma\n",
        "\n",
        "\t\tnum_dims = candStatus_padded.shape[1]\n",
        "\t\t#print(f\"num_dims num_dims {num_dims}\")\n",
        "\t\tif verbose: print(f\"shape candStatus_padded {candStatus_padded.shape}\")\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\t\tif num_dims != 1:\n",
        "\n",
        "\t\t\tcondition_broadcasted = np.tile(mip_mask_condition, (1, num_dims))\n",
        "\n",
        "\n",
        "\t\t\tif verbose: print(f\"shape candStatus_padded {candStatus_padded.shape}\")\n",
        "\n",
        "\t\t\thigh_charge_size = np.zeros_like(candStatus_padded)\n",
        "\t\t\thigh_charge_size[condition_broadcasted] = 1\n",
        "\t\t\tcandStatus_padded[condition_broadcasted] = 1\n",
        "\n",
        "\t\t\tx_padded = np.tile(x_padded, (1, num_dims))\n",
        "\t\t\ty_padded = np.tile(y_padded, (1, num_dims))\n",
        "\t\t\tq_padded = np.tile(q_padded, (1, num_dims))\n",
        "\t\t\tsize_padded = np.tile(size_padded, (1, num_dims))\n",
        "\n",
        "\t\t\tif verbose: print(f\"shape candStatus_padded {candStatus_padded.shape}\")\n",
        "\n",
        "\t\telse :\n",
        "\t\t\thigh_charge_size = np.zeros_like(candStatus_padded)\n",
        "\t\t\thigh_charge_size[mip_mask_condition] = 1\n",
        "\t\t\tcandStatus_padded[mip_mask_condition] = 1\n",
        "\n",
        "\n",
        "\t\t#candStatus_padded = pad_and_stack(candStatus_values_data, max_length=max_clu_in_event).astype(int)\n",
        "\n",
        "\t\t# ef : store info of high charge/size clusters to learn patterns about Feedback?\n",
        "\t\t#\tcandStatus_padded[(q_padded >= 150) & (size_padded >= 3)] = 1\n",
        "\n",
        "\t  \t# also use these to filter out other MIPs (also the ones that is not matched with track)\n",
        "\n",
        "\n",
        "\n",
        "\t\t# Modify candStatus based on charge and size threshold\n",
        "\t\t# candStatus_padded[outside_fiducial_zones] = 0\n",
        "\n",
        "\t\t# Define masks for different particle statuses\n",
        "\t\tproton_values = [2, 4, 6, 8]\n",
        "\t\tkaon_values = [3, 5, 7, 8]\n",
        "\t\tpion_values = [5, 6, 7, 8]\n",
        "\n",
        "\n",
        "\t\t#print(f\"shape candStatus_padded {candStatus_padded.shape}\")\n",
        "\n",
        "\t\tproton_mask = np.isin(candStatus_padded, proton_values)\n",
        "\t\tproton_mask = np.tile(proton_mask[:, :, np.newaxis], (1, 1, num_features))\n",
        "\n",
        "\t\tkaon_mask = np.isin(candStatus_padded, kaon_values)\n",
        "\t\tkaon_mask = np.tile(kaon_mask[:, :, np.newaxis], (1, 1, num_features))\n",
        "\n",
        "\n",
        "\t\tpion_mask = np.isin(candStatus_padded, pion_values)\n",
        "\t\tpion_mask = np.tile(pion_mask[:, :, np.newaxis], (1, 1, num_features))\n",
        "\n",
        "\t\t#print(f\"shape protonmask {proton_mask.shape}\")\n",
        "\n",
        "\t\t# Stack the data into a single array\n",
        "\t\tverbose = False\n",
        "\t\tif verbose: print(f\"x_padded shape {x_padded.shape}\")\n",
        "\t\tif verbose: print(f\"sigma_ring_padded shape {sigma_ring_padded.shape}\")\n",
        "\n",
        "\n",
        "\n",
        "\t\t# Calculate the ckov hyps\n",
        "\t\t# shape : num_tracks_in_event, 5 || : 5 species\n",
        "\n",
        "\t\t# print(f\"sigma_ring_padded shape {sigma_ring_padded.shape}\")\n",
        "\n",
        "\t\t# q_padded_flat = q_padded.flatten()\n",
        "\t\t# fig, axs = plt.subplots(1, 2, figsize=(12, 5))  # 1 row, 2 columns\n",
        "\n",
        "\t\t# # First histogram (original data)\n",
        "\t\t# axs[0].hist(q_padded_flat, range=(1, 1000), bins=30, alpha=0.7, color='blue')\n",
        "\t\t# axs[0].set_title('Histogram of q_padded')\n",
        "\t\t# axs[0].set_xlabel('Value')\n",
        "\t\t# axs[0].set_ylabel('Frequency')\n",
        "\n",
        "\t\t# # Apply conditions for the second histogram\n",
        "\t\t# q = q_padded.copy()\n",
        "\t\t# if num_dims != 1:\n",
        "\t\t# \t\tq[condition_broadcasted == False] = 0\n",
        "\t\t# else:\n",
        "\t\t# \t\tq[mip_mask_condition == False] = 0\n",
        "\n",
        "\t\t# q_flat = q.flatten()\n",
        "\n",
        "\t\t# # Second histogram (conditioned data)\n",
        "\t\t# axs[1].hist(q_flat, range=(10, 1000), bins=30, alpha=0.7, color='blue')\n",
        "\t\t# axs[1].set_title('Histogram of q after conditions applied')\n",
        "\t\t# axs[1].set_xlabel('Value')\n",
        "\t\t# axs[1].set_ylabel('Frequency')\n",
        "\t\t# plt.show()\n",
        "\n",
        "\n",
        "\t\t# plt.hist(size_padded.flatten(), bins=13, alpha=0.7, color='blue')  # Adjust the number of bins as needed\n",
        "\t\t# plt.title('Histogram of size_padded')\n",
        "\t\t# plt.xlabel('Value')\n",
        "\t\t# plt.ylabel('Frequency')\n",
        "\n",
        "\t\t# # Show the plot\n",
        "\t\t# plt.show()\n",
        "\n",
        "\n",
        "\t\t# plt.hist(theta_cer_padded.flatten(),range = (0.1,0.9), bins=50, alpha=0.7, color='blue')  # Adjust the number of bins as needed\n",
        "\t\t# plt.title('Histogram of theta_cer_padded')\n",
        "\t\t# plt.xlabel('Value')\n",
        "\t\t# plt.ylabel('Frequency')\n",
        "\n",
        "\t\t# # Show the plot\n",
        "\t\t# plt.show()\n",
        "\n",
        "\t\t# fig, axs = plt.subplots(1, 2, figsize=(12, 5))  # 1 row, 2 columns\n",
        "\n",
        "\t\t# # Plot histogram for range -3.14 to -0.01\n",
        "\t\t# axs[0].hist(phi_cer_padded.flatten(), range=(-3.14, -0.01), bins=157, alpha=0.7, color='blue')\n",
        "\t\t# axs[0].set_title('Histogram of phi_cer_padded (-3.14 to -0.01)')\n",
        "\t\t# axs[0].set_xlabel('Value')\n",
        "\t\t# axs[0].set_ylabel('Frequency')\n",
        "\n",
        "\t\t# # Plot histogram for range 0.01 to 3.14\n",
        "\t\t# axs[1].hist(phi_cer_padded.flatten(), range=(0.01, 3.14), bins=157, alpha=0.7, color='blue')\n",
        "\t\t# axs[1].set_title('Histogram of phi_cer_padded (0.01 to 3.14)')\n",
        "\t\t# axs[1].set_xlabel('Value')\n",
        "\t\t# axs[1].set_ylabel('Frequency')\n",
        "\t\t# plt.show()\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\t\t# # Second histogram (conditioned data)\n",
        "\t\t# plt.hist(sigma_ring_padded.flatten(), range=(0.001, 0.025), bins=200, alpha=0.7, color='blue')\n",
        "\t\t# plt.title('Histogram of sigma_ring_padded')\n",
        "\t\t# plt.xlabel('Value')\n",
        "\t\t# plt.ylabel('Frequency')\n",
        "\t\t# plt.show()\n",
        "\n",
        "\t\tverbose = False\n",
        "\n",
        "\n",
        "\n",
        "\t\t# hypothetical ckov values #Shape = num_tracks x num_species\n",
        "\t\ttheta_c_hyps = calc_ckov_hyp_arrays(event_data_dict)\n",
        "\n",
        "\n",
        "\n",
        "\t\t# max_length, num_tracks_in_event, 5 : probability per photon per track\n",
        "\t\tp_specie_per_track, L_track, L_all_tracks, z_mask = calc_species_prob(theta_c_hyps, sigma_ring_padded, theta_cer_padded, mip_mask_condition)\n",
        "\n",
        "\t\tverbose = False#True\n",
        "\n",
        "\t\tif verbose:\n",
        "\t\t\tprint(f\"p_specie_per_track  {p_specie_per_track[:20]}\")\n",
        "\t\t\tprint(f\"L_track  {L_track[:20, 0].T}\")\n",
        "\t\t\tprint(f\"L_all_tracks  {L_all_tracks[:20].T}\")\n",
        "\n",
        "\t\t\tprint(f\"z_mask  {z_mask[:20]}\")\n",
        "\t\t\tprint(f\"theta_c_hyps  {theta_c_hyps}\")\n",
        "\t\t\tprint(f\"sigma_ring_padded  {sigma_ring_padded[:20].T}\")\n",
        "\t\t\tprint(f\"theta_cer_padded  {theta_cer_padded[:20].T}\")\n",
        "\n",
        "\n",
        "\t\tif verbose:\n",
        "\t\t\tprint(f\"q_padded shape {q_padded.shape}\")\n",
        "\t\t\tprint(f\"sending momentum {event_data_dict['Momentum'].flatten()}\")\n",
        "\t\t\tprint(f\"probs_species = calc_species_prob(theta_c_hyps, sigma_ring_padded, theta_cer_padded)\")\n",
        "\n",
        "\t\t\tprint(f\"theta_c_hyps shape {theta_c_hyps.shape}\")\n",
        "\t\t\tprint(f\"sigma_ring_padded shape {sigma_ring_padded.shape}\")\n",
        "\t\t#print(f\"q_padded shape {q_padded[:50,:]}\")\n",
        "\n",
        "\t\t# max_length : padded, number of photons\n",
        "\t\t# - p_specie_per_track: The probability of each species per photon per track,\n",
        "\t\t#                       shape (n_tracks_max, max_length, 5).\n",
        "\t\t# - L_track: The likelihood of each photon per track, shape (n_tracks_max, max_length).\n",
        "\t\t# - L_all_tracks: The likelihood of each photon across all tracks, shape (max_length,).\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\t\t# find sum of z_score of all other tracks-spedies for the given photon in the track\n",
        "\t\t# also find number of tracks-species\n",
        "\n",
        "\n",
        "\n",
        "\t\t# num_photons, num_tracks, 7\n",
        "\n",
        "\n",
        "\t\t# disse blir feil?\n",
        "\t\tpion_prob_per_specie = p_specie_per_track[:,:,2].T\n",
        "\t\tkaon_prob_per_specie = p_specie_per_track[:,:,3].T\n",
        "\t\tproton_prob_per_specie = p_specie_per_track[:,:,4].T\n",
        "\n",
        "\t\tL_all_tracks = L_all_tracks.T\n",
        "\t\tL_all_tracks = L_all_tracks.reshape(-1, 1)\n",
        "\n",
        "\t\tL_track = L_track.T\n",
        "\n",
        "\t\tif verbose:\n",
        "\t\t\tprint(f\"L_track shape {L_track.shape}\")\n",
        "\t\t\tprint(f\"L_all_tracks shape {L_all_tracks.shape}\")\n",
        "\t\t\tprint(f\"pion_prob_per_specie shape {pion_prob_per_specie.shape}\")\n",
        "\t\t\tprint(f\"theta_c_hyps shape {theta_c_hyps.shape}\")\n",
        "\t\t\tprint(f\"pion_prob_per_specie shape {pion_prob_per_specie.shape}\")\n",
        "\n",
        "\t\t\tprint(f\"p_specie_per_track shape {p_specie_per_track.shape}\")\n",
        "\t\t\tprint(f\"L_track shape {L_track.shape}\")\n",
        "\t\t\tprint(f\"L_all_tracks shape {L_all_tracks.shape}\")\n",
        "\t\t\tprint(f\"theta_c_hyps.shape[0]  {theta_c_hyps.shape[0]}\")\n",
        "\t\tverbose = False\n",
        "\n",
        "\t\tpadded_data = np.zeros((max_clu_in_event, theta_c_hyps.shape[0], num_features))\n",
        "\t\tif verbose: print(f\"padded_data shape {padded_data.shape}\")\n",
        "\n",
        "\n",
        "\t\tif verbose:\n",
        "\t\t\tprint(f\"high_charge_size shape {high_charge_size.shape}\")\n",
        "\t\t\ttemp = \tall_events_data[\"high_charge_size\"][index_start:index_end, :, :]\n",
        "\t\t\tverbose:print(f\"all_events_data shape {temp.shape}\")\n",
        "\n",
        "\n",
        "\n",
        "\t\t# m√• l√∏se at fx L_track er (num_photons, num_tracks) !!\n",
        "\n",
        "\n",
        "\t\t#p_specie_per_track # (n_tracks_max, max_length, n_speciesx)\n",
        "\t\t# L_track # (n_tracks_max, max_length)\n",
        "\t\t#theta_c_hyps # (n_tracks_max, n_speciesx)\n",
        "\t\t# L_all_tracks:(max_length,).\n",
        "\t\t# event_data_dict --: track info of all matches per event (max_tracks_in_event, 1)\n",
        "\t\t# high_charge_size -- padded_data2 # (n_tracks_max, max_length, 4)\n",
        "\n",
        "\n",
        "\n",
        "\t\tprint(f\"high_charge_size  {high_charge_size[:20].T}\")\n",
        "\n",
        "\t\thigh_charge_size = high_charge_size\n",
        "\t\thigh_charge_size = high_charge_size[:,:, np.newaxis]\n",
        "\t\tverbose = False#True\n",
        "\t\tif verbose: print(f\"high_charge_size shape {high_charge_size.shape}\") # (550, 2)\n",
        "\n",
        "\n",
        "\t\tpadded_data2 = np.stack([x_padded, y_padded, q_padded, size_padded], axis=-1)\n",
        "\t\tif verbose: print(f\"padded_data2 shape {padded_data2.shape}\") # (550, 2)\n",
        "\n",
        "\n",
        "\t\thigh_charge_size_exp = np.tile(high_charge_size, (1, 1, 4))\n",
        "\n",
        "\n",
        "\t\tif verbose: print(f\"padded_data2 shape {padded_data2.shape}\")\n",
        "\t\tif verbose: print(f\"high_charge_size_exp shape {high_charge_size_exp.shape}\")\n",
        "\n",
        "\t\tprint(f\"num_tracks_in_event {num_tracks_in_event}\")\n",
        "\n",
        "\t\tnum_rows_to_replace = theta_c_hyps.shape[0]\n",
        "\n",
        "\t\tmip_to_model = np.zeros((max_clu_in_event, 1, 4))\n",
        "\n",
        "\t\tmip_mask_condition1dim = mip_mask_condition\n",
        "\t\tif verbose: print(f\"mip_mask_condition shape {mip_mask_condition.shape}\")\n",
        "\n",
        "\t\tif num_tracks_in_event > 0:\n",
        "\t\t\tflat_mip_mask = mip_mask_condition.flatten()# np.repeat(mip_mask_condition, 4, axis=1)\n",
        "\t\t\tmip_mask_condition = np.repeat(mip_mask_condition, num_tracks_in_event + 1, axis=1)\n",
        "\t\t\tpadded_data2_1DIM = padded_data2[:, 0, :]\n",
        "\n",
        "\n",
        "\t\t\tif verbose: print(f\"padded_data2_1DIM shape {padded_data2_1DIM.shape}\")\n",
        "\n",
        "\t\t\tif verbose: print(f\"flat_mip_mask shape {flat_mip_mask.shape}\")\n",
        "\t\t\tmips =  np.array(padded_data2_1DIM[flat_mip_mask])\n",
        "\t\t\tif verbose: print(f\"mips shape {mips.shape}\")\n",
        "\n",
        "\n",
        "\t\telse :\n",
        "\t\t\tverbose = False\n",
        "\t\t\tpadded_data2_1DIM = padded_data2\n",
        "\t\t\tmips =  np.array(padded_data2[mip_mask_condition])\n",
        "\n",
        "\t\tif verbose: print(f\"mip_to_model shape {mip_to_model.shape}\")\n",
        "\n",
        "\t\tif verbose: print(f\" mip_mask_condition shape { mip_mask_condition.shape}\")\n",
        "\t\tif verbose: print(f\" padded_data2_1DIM shape { padded_data2_1DIM.shape}\")\n",
        "\t\tif verbose: print(f\" padded_data2_1DIM  { padded_data2_1DIM}\")\n",
        "\n",
        "\n",
        "\t\t#mips =  np.array(padded_data2_1DIM[mip_mask_condition1dim])\n",
        "\t\t#\n",
        "\n",
        "\t\t# ERLEND LEFT HERE ;)\n",
        "\t\t# er det nioen av mips som er like?!\n",
        "\n",
        "\n",
        "\t\tif verbose: print(f\" mips shape { mips.shape}\")\n",
        "\t\tif verbose: print(f\" mip_mask_condition1dim shape { mip_mask_condition1dim.shape}\")\n",
        "\t\tif verbose: print(f\" padded_data2_1DIM  shape { padded_data2_1DIM.shape}\")\n",
        "\n",
        "\n",
        "\n",
        "\t\tprint(f\"mips {mips[:20]}\")\n",
        "\t\tmip_to_model[:mips.shape[0], :, :] = mips[:, np.newaxis, :] # ef dette riktig?\n",
        "\t\tif verbose: print(f\" mip_to_model  { mip_to_model}\")\n",
        "\n",
        "\t\tmip_mask_condition_ext = np.repeat(mip_mask_condition[:, :, np.newaxis], num_features, axis=2)\n",
        "\n",
        "\t\tmip_expanded = np.zeros_like(padded_data)\n",
        "\n",
        "\n",
        "\t\tmip_expanded = np.array(mips[:, np.newaxis, : ])\n",
        "\n",
        "\t\tif verbose: print(f\" padded_data2[mip_mask_condition] shape { padded_data2[mip_mask_condition].shape}\")\n",
        "\t\tif verbose: print(f\"mip_expanded shape {mip_expanded.shape}\")\n",
        "\n",
        "\t\tif verbose: print(f\"mip_expanded {mip_expanded}\")\n",
        "\n",
        "\t\t#mip_to_model[:mip_expanded.shape[0], :, :] = mip_expanded\n",
        "\t\t#mip_to_model[high_charge_size_exp] = padded_data2[high_charge_size_exp].reshape(1, -1)\n",
        "\t\t#if verbose: print(f\"mip_to_model  {mip_to_model}\")\n",
        "\n",
        "\n",
        "\t\tverbose = False#True\n",
        "\t\tif verbose: print(f\"mip_to_model shape {mip_to_model.shape}\")\n",
        "\n",
        "\t\tif verbose: print(f\"high_charge_size count_nonzero {np.count_nonzero(high_charge_size)}\")\n",
        "\t\tif verbose: print(f\"mip_mask_condition count_nonzero {np.count_nonzero(mip_mask_condition)}\")\n",
        "\t\tif verbose: print(f\"mip_to_model count_nonzero {np.count_nonzero(mip_to_model)/4}\")\n",
        "\n",
        "\n",
        "\t\t#if verbose: print(f\"q_padded  {q_padded[:10, :]}\")\n",
        "\t\t#if verbose: print(f\"size_padded  {size_padded[:10, :]}\")\n",
        "\t\tpadded_data2[high_charge_size_exp==False] = 0\n",
        "\n",
        "\t\t#if verbose: print(f\"size_padded  {size_padded[:10, :]}\")\n",
        "\n",
        "\n",
        "\t\t#if verbose: print(f\"values_data_dict['q_values'] {values_data_dict['q_values'][index_start, :]}\")\n",
        "\n",
        "\t\t#if verbose: print(f\"q_padded count_nonzero {np.count_nonzero(q_padded)}\")\n",
        "\n",
        "\n",
        "\t\t#if verbose: print(f\"proton_prob_per_specie {proton_prob_per_specie}\")\n",
        "\n",
        "\t\tif verbose: print(f\" mip_to_model  repeated :  { mip_to_model}\")\n",
        "\n",
        "\t\tmip_to_model = np.repeat(mip_to_model, theta_c_hyps.shape[0], axis=1) # ef dette riktig?\n",
        "\t\tif verbose: print(f\"mip_to_model repeated shape {mip_to_model.shape}\")\n",
        "\n",
        "\n",
        "\t\tif verbose: print(f\"q_padded proton_prob_per_specie {np.count_nonzero(proton_prob_per_specie)}\")\n",
        "\n",
        "\t\ttemp = all_events_data[\"high_charge_size\"][index_start:index_end, :, :].shape\n",
        "\t\tif verbose: print(f\"\tall_events_data[] {temp}\")\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\t\t# index_start = index_particle - num_tracks_in_event\n",
        "\n",
        "\t\t#  (num_particles, max_tracks_in_event, 3)\n",
        "\t\ttheta_c_hadron =  theta_c_hyps[:, 2:]\n",
        "\t\textended_theta_c_hadron = np.repeat(theta_c_hadron[np.newaxis, :, :], max_tracks_in_event, axis=0)\n",
        "\t\tif verbose:\n",
        "\t\t\tprint(f\"theta_c_hyps shape {theta_c_hyps.shape}\") # max_tracks_in_event x num_species\n",
        "\n",
        "\t\t\tprint(f\"extended_theta_c_hadron shape {extended_theta_c_hadron.shape}\") # max_tracks_in_event x num_species\n",
        "\n",
        "\t\t\tprint(f\"index_start {index_start} index_end {index_end}\")\n",
        "\n",
        "\t\ttemp2 = all_events_data[\"ckov_hyps_tracks_in_event\"][index_start:index_end, :, :].shape\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\t\t# m√• regne ut :\n",
        "\t\t# per index_start:index_particle : \"normalisert\" e.l. sannsylighet per specie:\n",
        "\t\t# for hver track:\n",
        "\t\t# \thver photon:\n",
        "\t\t# \t\tz_specie = (eta_c - ckov_hyp_specie)/sigma # eta_c sigma for photon\n",
        "\t\t#\n",
        "\t\t#\n",
        "\n",
        "\t\t#print(f\"managed to pad...\")\n",
        "\n",
        "\t\t#print(f\"shape padded_data {padded_data.shape}\")\n",
        "\n",
        "\n",
        "\n",
        "\t\tverbose = False\n",
        "\n",
        "\t\tif verbose:\n",
        "\t\t\tprint(f\"index_start {index_start} index_end {index_end}\")\n",
        "\n",
        "\t\t\t# if num_dims != 1:\n",
        "\t\t\t# \tpadded_data = np.tile(padded_data[:, :, np.newaxis], (1, num_dims, 1))\n",
        "\t\t\tprint(f\"x_padded {x_padded.shape} \")\n",
        "\t\t\tprint(f\"q_padded {q_padded.shape} \")\n",
        "\t\t\tprint(f\"y_padded {y_padded.shape} \")\n",
        "\t\t\tprint(f\"size_padded {size_padded.shape} \")\n",
        "\t\t\tprint(f\"phi_cer_padded {phi_cer_padded.shape} \")\n",
        "\t\t\tprint(f\"theta_cer_padded {theta_cer_padded.shape} \")\n",
        "\t\t\tprint(f\"sigma_ring_padded {sigma_ring_padded.shape} \")\n",
        "\t\t\tprint(f\"pion_prob_per_specie {pion_prob_per_specie.shape} \")\n",
        "\t\t\tprint(f\"kaon_prob_per_specie {kaon_prob_per_specie.shape} \")\n",
        "\t\t\tprint(f\"proton_prob_per_specie {proton_prob_per_specie.shape} \")\n",
        "\t\t\tprint(f\"L_track {L_track.shape} \")\n",
        "\n",
        "\n",
        "\t\t#shapes\n",
        "\t\tif num_tracks_in_event > 0:\n",
        "\t\t\tL_all_tracks = np.repeat(L_all_tracks, num_tracks_in_event + 1, axis=1)\n",
        "\t\tprint(f\"L_all_tracks {L_all_tracks.shape} \")\n",
        "\n",
        "\t\tpadded_data = np.stack([x_padded, y_padded, q_padded, size_padded, phi_cer_padded, theta_cer_padded, sigma_ring_padded, pion_prob_per_specie, kaon_prob_per_specie, proton_prob_per_specie, L_track, L_all_tracks], axis=-1)\n",
        "\n",
        "\n",
        "\t\tverbose = False\n",
        "\t\tif verbose: print(f\"padded_data shape {padded_data.shape}\")\n",
        "\n",
        "\t\t#print(f\"shape padded_data {padded_data.shape}\")\n",
        "\n",
        "\t\t# Create masks for positive and non statuses\n",
        "\t\tpositive_mask = (candStatus_padded > 0).astype(bool)\n",
        "\t\t#print(f\"shape positive_mask {positive_mask.shape}\")\n",
        "\n",
        "\t\tpositive_mask = np.repeat(positive_mask[:, :, np.newaxis], num_features, axis=2)\n",
        "\n",
        "\t\tif verbose: print(f\"positive_mask shape {positive_mask.shape}\")\n",
        "\n",
        "\t\t#print(f\"shape positive_mask {positive_mask.shape}\")\n",
        "\n",
        "\t\tnon_mask = (candStatus_padded <= 1).astype(bool)\n",
        "\t\tnon_mask = np.repeat(non_mask[:, :, np.newaxis], num_features, axis=2)\n",
        "\n",
        "\t\t# Populate particle candidates arrays\n",
        "\t\tpion_candidates = np.zeros_like(padded_data)\n",
        "\t\tkaon_candidates = np.zeros_like(padded_data)\n",
        "\t\tproton_candidates = np.zeros_like(padded_data)\n",
        "\t\tnon_candidates = np.zeros_like(padded_data)\n",
        "\t\tz_mask_rearranged = np.transpose(z_mask, (1, 0, 2))\n",
        "\n",
        "\t\t# print(f\"z_mask_rearranged.shape {z_mask_rearranged.shape}\")\n",
        "\t\t# print(f\"positive_mask.shape {positive_mask.shape}\")\n",
        "\t\t# print(f\"pion_mask.shape {pion_mask.shape}\")\n",
        "\t\t# print(f\"padded_data.shape {padded_data.shape}\")\n",
        "\t\tz_mask_rearranged[:, :, 2]\n",
        "\t\tif verbose : print(f\"z_mask_rearranged[:, :, 2]\")\n",
        "\n",
        "\t\t# masses = np.array([MASS_ELECTRON, MASS_MUON, MASS_PION, MASS_KAON, MASS_PROTON])\n",
        "\t\tpion_mask2 = z_mask_rearranged[:, :, 2]\n",
        "\t\tpion_mask2 = np.repeat(pion_mask2[:, :, np.newaxis], num_features, axis=2)\n",
        "\t\tkaon_mask2 = z_mask_rearranged[:, :, 3]\n",
        "\t\tkaon_mask2 = np.repeat(kaon_mask2[:, :, np.newaxis], num_features, axis=2)\n",
        "\t\tproton_mask2 = z_mask_rearranged[:, :, 4]\n",
        "\t\tproton_mask2 = np.repeat(proton_mask2[:, :, np.newaxis], num_features, axis=2)\n",
        "\n",
        "\n",
        "\t\t# print(f\"mip_mask_condition.shape {mip_mask_condition.shape}\")\n",
        "\n",
        "\t\tprint(f\"pion_mask2.shape {pion_mask2.shape}\")\n",
        "\t\t# print(f\"pion_candidates.shape {pion_candidates.shape}\")\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\t\tpion_candidates[~mip_mask_condition_ext & pion_mask2] = padded_data[~mip_mask_condition_ext & pion_mask2]\n",
        "\t\tkaon_candidates[~mip_mask_condition_ext & kaon_mask2] = padded_data[~mip_mask_condition_ext & kaon_mask2]\n",
        "\t\tproton_candidates[~mip_mask_condition_ext & proton_mask2] = padded_data[~mip_mask_condition_ext & proton_mask2]\n",
        "\n",
        "\n",
        "\n",
        "\t\tif verbose: print(f\"pion_candidates count_nonzero {np.count_nonzero(pion_candidates)}\")\n",
        "\t\tif verbose: print(f\"kaon_candidates count_nonzero {np.count_nonzero(kaon_candidates)}\")\n",
        "\t\tif verbose: print(f\"proton_candidates count_nonzero {np.count_nonzero(proton_candidates)}\")\n",
        "\n",
        "\t\t\"\"\"just tbs\n",
        "\t\tevent_data_dict = {\n",
        "\t\t\t\t'Momentum': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t'RefractiveIndex': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t'xRad': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t'yRad': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t'xMip': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t'yMip': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t'ThetaP': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t'PhiP': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t'CluCharge': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t'CluSize': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t'TrackPdg': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t'ckovReconstructed': np.zeros((max_tracks_in_event, 1))\n",
        "\t\t}\"\"\"\n",
        "\n",
        "\t\tfor index in range(num_tracks_in_event + 1):\n",
        "\t\t\tabs_pdg = abs(event_data_dict['TrackPdg'][index])\n",
        "\t\t\tprint(f\"index {index} of {num_tracks_in_event} : pdg {abs_pdg}\")\n",
        "\n",
        "\n",
        "\n",
        "\t\t\tif abs_pdg not in [211, 321, 2212]:\n",
        "\t\t\t\tprint(f\"\tPDG {abs_pdg} wrong >> skip\")\n",
        "\n",
        "\t\t\t\tcontinue\n",
        "\n",
        "\n",
        "\t\t\tindex_in_event = index_end - index_start\n",
        "\t\t\tif event_data_dict['ckovReconstructed'][index] < 0 :\n",
        "\t\t\t\tprint(f\"PDG {abs_pdg} skip >> ckovRecon {event_data_dict['ckovReconstructed'][index]}\")\n",
        "\t\t\t\tcontinue\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\t\t\tprint(f\"Passed ckovReconstructed and in PDG\")\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\t\t\tnum_pions = np.count_nonzero(pion_candidates[ :, index, 4])\n",
        "\t\t\tnum_kaons = np.count_nonzero(kaon_candidates[ :, index, 4])\n",
        "\t\t\tnum_protons = np.count_nonzero(proton_candidates[ :, index, 4])\n",
        "\t\t\tauto = proton_candidates[ :, index, 4]\n",
        "\t\t\tif verbose:\n",
        "\t\t\t\tprint(f\"auto shape {auto.shape}\")\n",
        "\t\t\t\tprint(f\"proton_candidates shape {proton_candidates.shape}\")\n",
        "\n",
        "\t\t\t\tprint(f\"num_pions count_nonzero {num_pions}\")\n",
        "\t\t\t\tprint(f\"num_kaons count_nonzero {num_kaons}\")\n",
        "\t\t\t\tprint(f\"num_protons count_nonzero {num_protons}\")\n",
        "\n",
        "\n",
        "\n",
        "\t\t\tp = event_data_dict['Momentum'][index]\n",
        "\t\t\tn = event_data_dict['RefractiveIndex'][index]\n",
        "\n",
        "\t\t\tif abs_pdg == 211:\n",
        "\t\t\t\t# were not exceeding Ckov threshold\n",
        "\t\t\t\tif ~threshold_momentum(211, event_data_dict['Momentum'][index] ):\n",
        "\t\t\t\t\tprint(f\"PDG {abs_pdg} did not pass ckov tres\")\n",
        "\t\t\t\t\tcontinue\n",
        "\t\t\t\tprint(f\"PDG {abs_pdg} passed treshold momentum\")\n",
        "\n",
        "\t\t\t\tcond1 = abs(pion_candidates[ :, index, 4]) > np.pi/2\n",
        "\t\t\t\tcond2 = abs(pion_candidates[ :, index, 4]) < np.pi\n",
        "\n",
        "\t\t\t\t# Combine the conditions using logical AND\n",
        "\t\t\t\tin_half = (cond1) & (cond2)\n",
        "\n",
        "\t\t\t\tnum_photon_in_half = np.sum(in_half)\n",
        "\n",
        "\t\t\t\tnon_zero_val = num_pions\n",
        "\t\t\t\tnum_phot_thresh, num_phot_half_thresh = expected_num_photons(n, p, abs_pdg)\n",
        "\t\t\t\t# get phi-cer that is in short side of elipsoid\n",
        "\t\t\t\tif (non_zero_val < num_phot_thresh) | (num_photon_in_half < num_phot_half_thresh) :\n",
        "\t\t\t\t\tcontinue\n",
        "\t\t\t\tprint(f\"PDG {abs_pdg} passed num_phot_thresh\")\n",
        "\n",
        "\n",
        "\n",
        "\t\t\tif abs_pdg == 321:\n",
        "\t\t\t\t# were not exceeding Ckov threshold\n",
        "\t\t\t\tif ~threshold_momentum(321, event_data_dict['Momentum'][index] ):\n",
        "\t\t\t\t\tprint(f\"PDG {abs_pdg} did not pass ckov tres\")\n",
        "\n",
        "\t\t\t\t\tcontinue\n",
        "\n",
        "\t\t\t\tprint(f\"PDG {abs_pdg} passed treshold momentum\")\n",
        "\n",
        "\t\t\t\tnum_phot_thresh, num_phot_half_thresh = expected_num_photons(n, p, abs_pdg)\n",
        "\n",
        "\t\t\t\tnon_zero_val = num_kaons\n",
        "\t\t\t\tcond1 = abs(kaon_candidates[ :, index, 4]) > np.pi/2\n",
        "\t\t\t\tcond2 = abs(kaon_candidates[ :, index, 4]) < np.pi\n",
        "\n",
        "\t\t\t\t# Combine the conditions using logical AND\n",
        "\t\t\t\tin_half = (cond1) & (cond2)\n",
        "\n",
        "\t\t\t\tnum_photon_in_half = np.sum(in_half)\n",
        "\t\t\t\tif (non_zero_val < num_phot_thresh) | (num_photon_in_half < num_phot_half_thresh) :\n",
        "\t\t\t\t\tprint(f\"PDG {abs_pdg} non_zero_val {non_zero_val} < num_phot_thresh {num_phot_thresh}\")\n",
        "\t\t\t\t\tprint(f\"PDG {abs_pdg} num_photon_in_half {num_photon_in_half} < num_phot_half_thresh {num_phot_half_thresh}\")\n",
        "\n",
        "\t\t\t\t\tcontinue\n",
        "\t\t\t\tprint(f\"PDG {abs_pdg} passed num_phot_thresh\")\n",
        "\n",
        "\n",
        "\n",
        "\t\t\tif abs_pdg == 2212:\n",
        "\t\t\t\t# were not exceeding Ckov threshold\n",
        "\t\t\t\tif ~threshold_momentum(2212, event_data_dict['Momentum'][index] ):\n",
        "\t\t\t\t\tprint(f\"PDG {abs_pdg} did not pass ckov tres\")\n",
        "\n",
        "\t\t\t\t\tcontinue\n",
        "\n",
        "\t\t\t\tprint(f\"PDG {abs_pdg} passed treshold momentum\")\n",
        "\n",
        "\t\t\t\tnum_phot_thresh, num_phot_half_thresh = expected_num_photons(n, p, abs_pdg)\n",
        "\n",
        "\t\t\t\tnon_zero_val =  num_protons\n",
        "\t\t\t\t#proton_cnt = proton_cnt + 1\n",
        "\t\t\t\tcond1 = abs(proton_candidates[ :, index, 4]) > np.pi/2\n",
        "\t\t\t\tcond2 = abs(proton_candidates[ :, index, 4]) < np.pi\n",
        "\n",
        "\t\t\t\t# Combine the conditions using logical AND\n",
        "\t\t\t\tin_half = (cond1) & (cond2)\n",
        "\n",
        "\t\t\t\tnum_photon_in_half = np.sum(in_half)\n",
        "\t\t\t\t# bare aksepter hvis det er nok fotoner\n",
        "\t\t\t\tif (non_zero_val < num_phot_thresh) | (num_photon_in_half < num_phot_half_thresh) :\n",
        "\n",
        "\t\t\t\t\tprint(f\"PDG {abs_pdg} non_zero_val {non_zero_val} < num_phot_thresh {num_phot_thresh}\")\n",
        "\t\t\t\t\tprint(f\"PDG {abs_pdg} num_photon_in_half {num_photon_in_half} < num_phot_half_thresh {num_phot_half_thresh}\")\n",
        "\n",
        "\n",
        "\t\t\t\t\tcontinue\n",
        "\t\t\t\tprint(f\"PDG {abs_pdg} passed num_phot_thresh\")\n",
        "\n",
        "\t\t\t#all_events_data[]\n",
        "\n",
        "\n",
        "\t\t\t# def : # litt d√∏d atm, pion_kaon_proton_dict er internt i denne og hadron_candidate_dict er eksternt :)\n",
        "\t\t\t# def fill_dict_event(SPECIE_data, INDEX):\n",
        "\t\t\t# def fill_dict_event(SPECIE_data, INDEX, index_of_track):\n",
        "\n",
        "\n",
        "\t\t\tpion_candidates, kaon_candidates, proton_candidates\n",
        "\n",
        "\t\t\tif abs_pdg == 211:\n",
        "\t\t\t\tSPECIE_data = PION_data\n",
        "\t\t\t\tfill_dict_for_index_N(SPECIE_data, INDEX_VALID_PION, pion_candidates, kaon_candidates, proton_candidates, index)\n",
        "\t\t\t\tfill_other_tracks(SPECIE_data, INDEX_VALID_PION)\n",
        "\t\t\t\tfill_current_track(SPECIE_data, INDEX_VALID_PION, index, mip_to_model)\n",
        "\t\t\t\tINDEX_VALID_PION += 1\n",
        "\n",
        "\n",
        "\t\t\tif abs_pdg == 321:\n",
        "\t\t\t\tSPECIE_data = KAON_data\n",
        "\t\t\t\tfill_dict_for_index_N(SPECIE_data, INDEX_VALID_KAON, pion_candidates, kaon_candidates, proton_candidates, index)\n",
        "\t\t\t\tfill_other_tracks(SPECIE_data, INDEX_VALID_KAON)\n",
        "\t\t\t\tfill_current_track(SPECIE_data, INDEX_VALID_KAON, index, mip_to_model)\n",
        "\t\t\t\tINDEX_VALID_KAON += 1\n",
        "\n",
        "\n",
        "\t\t\tif abs_pdg == 2212:\n",
        "\t\t\t\tSPECIE_data = PROTON_data\n",
        "\t\t\t\tfill_dict_for_index_N(SPECIE_data, INDEX_VALID_PROTON, pion_candidates, kaon_candidates, proton_candidates, index)\n",
        "\t\t\t\tfill_other_tracks(SPECIE_data, INDEX_VALID_PROTON)\n",
        "\t\t\t\tfill_current_track(SPECIE_data, INDEX_VALID_PROTON, index, mip_to_model)\n",
        "\t\t\t\tINDEX_VALID_PROTON += 1\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\t\t\t# everything is ok\n",
        "\n",
        "\t\t\tprint(f\"abs_pdg {abs_pdg} num_pions {num_pions} num_kaons {num_kaons} num_protons {num_protons}\")\n",
        "\n",
        "\n",
        "\n",
        "\t\t# ef > endret fra \t\tproton_candidates[positive_mask & proton_mask] = padded_data[positive_mask & proton_mask]\n",
        "\n",
        "\t\t#proton_candidates[positive_mask & proton_mask] = padded_data[~mip_mask_condition_ext & proton_mask2]\n",
        "\t\tnon_candidates[non_mask] = padded_data[non_mask]\n",
        "\n",
        "\n",
        "\n",
        "\t\treturn pion_candidates, kaon_candidates, proton_candidates, non_candidates, candStatus_padded\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 236,
      "metadata": {
        "id": "aCiVl64YHGlc",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "ae56d607-898a-4d1b-a3df-5875786c3376"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "/bin/bash: line 1: TOKEN: No such file or directory\n",
            "--2023-12-14 12:59:33--  https://raw.githubusercontent.com/eflatlan/CNN_PID/models_sacved/ParticleDataUtils36.py\n",
            "Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 185.199.108.133, 185.199.111.133, 185.199.109.133, ...\n",
            "Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|185.199.108.133|:443... connected.\n",
            "HTTP request sent, awaiting response... 200 OK\n",
            "Length: 21728 (21K) [text/plain]\n",
            "Saving to: ‚ÄòParticleDataUtilsCp.py‚Äô\n",
            "\n",
            "ParticleDataUtilsCp 100%[===================>]  21.22K  --.-KB/s    in 0s      \n",
            "\n",
            "2023-12-14 12:59:33 (66.6 MB/s) - ‚ÄòParticleDataUtilsCp.py‚Äô saved [21728/21728]\n",
            "\n",
            "/bin/bash: line 1: TOKEN: No such file or directory\n",
            "--2023-12-14 12:59:33--  https://raw.githubusercontent.com/eflatlan/CNN_PID/models_sacved/ParticleDataUtils36.py\n",
            "Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 185.199.110.133, 185.199.109.133, 185.199.108.133, ...\n",
            "Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|185.199.110.133|:443... connected.\n",
            "HTTP request sent, awaiting response... 200 OK\n",
            "Length: 21728 (21K) [text/plain]\n",
            "Saving to: ‚ÄòParticleDataUtilsCp.py‚Äô\n",
            "\n",
            "ParticleDataUtilsCp 100%[===================>]  21.22K  --.-KB/s    in 0s      \n",
            "\n",
            "2023-12-14 12:59:33 (91.2 MB/s) - ‚ÄòParticleDataUtilsCp.py‚Äô saved [21728/21728]\n",
            "\n",
            "--2023-12-14 12:59:33--  https://raw.githubusercontent.com/eflatlan/CNN_PID/models_sacved/misc_helper_functions8.py\n",
            "Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 185.199.108.133, 185.199.109.133, 185.199.110.133, ...\n",
            "Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|185.199.108.133|:443... connected.\n",
            "HTTP request sent, awaiting response... 200 OK\n",
            "Length: 33663 (33K) [text/plain]\n",
            "Saving to: ‚Äòmisc_helper_functions.py‚Äô\n",
            "\n",
            "misc_helper_functio 100%[===================>]  32.87K  --.-KB/s    in 0.003s  \n",
            "\n",
            "2023-12-14 12:59:33 (10.9 MB/s) - ‚Äòmisc_helper_functions.py‚Äô saved [33663/33663]\n",
            "\n",
            "<function classify_candidates_with_pad_sequences at 0x7e06136a7e20>\n"
          ]
        }
      ],
      "source": [
        "\n",
        "\n",
        "from tensorflow.keras.callbacks import EarlyStopping\n",
        "\n",
        "# create a callback\n",
        "early_stopping = EarlyStopping(\n",
        "\tmonitor='val_loss', # you can monitor 'val_loss' or 'val_accuracy'\n",
        "\tpatience=20, # stop training if the monitored quantity does not improve for 50 epochs\n",
        "\trestore_best_weights=True, # restore model weights from the epoch with the best value\n",
        ")\n",
        "\n",
        "!git clone https://<TOKEN>@github.com/eflatlan/CNN_PID.git\n",
        "\n",
        "!wget -O ParticleDataUtilsCp.py https://raw.githubusercontent.com/eflatlan/CNN_PID/models_sacved/ParticleDataUtils36.py\n",
        "from ParticleDataUtilsCp import ParticleDataUtils, classify_candidates_with_pad_sequences\n",
        "\n",
        "!git clone https://<TOKEN>@github.com/eflatlan/CNN_PID.git\n",
        "\n",
        "!wget -O ParticleDataUtilsCp.py https://raw.githubusercontent.com/eflatlan/CNN_PID/models_sacved/ParticleDataUtils36.py\n",
        "from ParticleDataUtilsCp import ParticleDataUtils, classify_candidates_with_pad_sequences\n",
        "\n",
        "!wget -O misc_helper_functions.py https://raw.githubusercontent.com/eflatlan/CNN_PID/models_sacved/misc_helper_functions8.py\n",
        "from misc_helper_functions import build_species_layers, build_species_layers2, calculate_theta, filter_data, create_lr_scheduler,plot_lr, extract_neighborhood_map, create_cnn_model # plot_worst\n",
        "from misc_helper_functions import build_species_layers, build_species_layers2, calculate_theta, filter_data, create_lr_scheduler,plot_lr, extract_neighborhood_map, create_cnn_model # plot_worst\n",
        "\n",
        "\n",
        "\n",
        "# from plot_helper_functions import plot_hist\n",
        "\n",
        "# from plot_helper_functions import plot_training_history\n",
        "#from plot_helper_functions import plot_training_history#, plot_dist2mip_histograms, plot_maps\n",
        "\n",
        "\n",
        "print(classify_candidates_with_pad_sequences)\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 248,
      "metadata": {
        "id": "do3H88rMcK92",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "33f52528-04fc-4ae1-8763-c64edc8c1061"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "1000\n"
          ]
        }
      ],
      "source": [
        "import os\n",
        "\n",
        "# create a callback\n",
        "early_stopping = EarlyStopping(\n",
        "    monitor='val_loss', # you can monitor 'val_loss' or 'val_accuracy'\n",
        "    patience=100, # stop training if the monitored quantity does not improve for 50 epochs\n",
        "    restore_best_weights=True, # restore model weights from the epoch with the best value\n",
        ")\n",
        "\n",
        "from tensorflow.keras.preprocessing.sequence import pad_sequences\n",
        "import numpy as np\n",
        "from tensorflow.keras.preprocessing.sequence import pad_sequences\n",
        "import numpy as np\n",
        "\n",
        "import numpy as np\n",
        "\n",
        "import numpy as np\n",
        "MASS_PION = 0.1396\n",
        "MASS_KAON = 0.4937\n",
        "MASS_PROTON = 0.938\n",
        "\n",
        "# Squared masses\n",
        "MASS_PION_SQ = MASS_PION * MASS_PION\n",
        "MASS_KAON_SQ = MASS_KAON * MASS_KAON\n",
        "MASS_PROTON_SQ = MASS_PROTON * MASS_PROTON\n",
        "REF_INDEX_FREON = 1.29  # Given refraction index\n",
        "REF_INDEX_FREON_SQ = REF_INDEX_FREON * REF_INDEX_FREON\n",
        "\n",
        "def threshold_momentum(pdg_code, p):\n",
        "\t\"\"\"\n",
        "\tCalculate the threshold momentum based on the given PDG code.\n",
        "\n",
        "\t:param pdg_code: PDG code of the particle.\n",
        "\tp : momentum of track\n",
        "\t(tbd : refindex)\n",
        "\n",
        "\t:return : boolean value for Cherenkov radiation.\n",
        "\t\"\"\"\n",
        "\n",
        "\t# Determine mass based on PDG code\n",
        "\tif abs(pdg_code) == 211:\n",
        "\t\tmass = MASS_PION\n",
        "\telif abs(pdg_code) == 321:\n",
        "\t\tmass = MASS_KAON\n",
        "\telif abs(pdg_code) == 2212:\n",
        "\t\tmass = MASS_PROTON\n",
        "\telse:\n",
        "\t\traise ValueError(f\"Unsupported PDG code: {pdg_code}\")\n",
        "\n",
        "\tp_lim = mass/(np.sqrt(REF_INDEX_FREON_SQ-1))\n",
        "\t#print(f\" p_lim {p_lim} p {p}\")\n",
        "\treturn p_lim < p\n",
        "\n",
        "\n",
        "\n",
        "def pad_and_stack(sequences, max_length=None):\n",
        "\t# Your existing code\n",
        "\ttry:\n",
        "\t\t# Try padding, if max_length is not None, pad or truncate to that length\n",
        "\t\tpadded_sequences = pad_sequences(sequences, maxlen=max_length, padding='post', dtype='float32')  # Changed dtype to 'floar32'\n",
        "\texcept ValueError:\n",
        "\t\t# Fallback: manually pad with zeros\n",
        "\t\tmax_len = max_length if max_length is not None else max(len(seq) for seq in sequences)\n",
        "\t\tpadded_sequences = np.array([np.pad(seq, (0, max_len - len(seq)), 'constant', constant_values=0) for seq in sequences])\n",
        "\n",
        "\treturn padded_sequences\n",
        "\n",
        "\n",
        "def count_non_zero_charges_vectorized(datasets):\n",
        "\treturn [np.count_nonzero(data[:, :, 3], axis=1) for data in datasets]\n",
        "\n",
        "import numpy as np\n",
        "import numpy as np\n",
        "\n",
        "def classify_candidates_with_pad_sequences(x_values_data, y_values_data, q_values_data, mCluSize_lista, candStatus_values_data, max_clu_in_event, xmip_list, ymip_list, phiCervalues_lst_data_list, sigmaRing_lst_data_list, thetaCervalues_lst_data_list, ckovhough_list):\n",
        "\n",
        "\t# x_values_data shape: (4064, 550)\n",
        "\n",
        "\tprint(\"x_values_data shape:\", x_values_data.shape)\n",
        "\tprint(\"y_values_data shape:\", y_values_data.shape)\n",
        "\tprint(\"q_values_data shape:\", q_values_data.shape)\n",
        "\tprint(\"mCluSize_lista shape:\", mCluSize_lista.shape)\n",
        "\tprint(\"candStatus_values_data shape:\", candStatus_values_data.shape)\n",
        "\tprint(\"max_clu_in_event:\", max_clu_in_event)  # assuming this is a single value, not an array\n",
        "\tprint(\"xmip_list shape:\", xmip_list.shape)\n",
        "\tprint(\"ymip_list shape:\", ymip_list.shape)\n",
        "\tprint(\"phiCervalues_lst_data_list shape:\", phiCervalues_lst_data_list.shape)\n",
        "\tprint(\"sigmaRing_lst_data_list shape:\", sigmaRing_lst_data_list.shape)\n",
        "\tprint(\"thetaCervalues_lst_data_list shape:\", thetaCervalues_lst_data_list.shape)\n",
        "\tprint(\"ckovhough_list shape:\", ckovhough_list.shape)\n",
        "\n",
        "\t\"\"\"Classify the candidates based on the candidate_status\n",
        "\t\t\tReturns : pion - NumSamples x padded_length x 5 |\n",
        "\t\t\t\t\t\t\t  kaon\n",
        "\t\t\t\t\t\t\t\tproton\n",
        "\t\t\t\t\t\t\t\tnone\n",
        "\n",
        "\t\"\"\"\n",
        "\t# TODO:\n",
        "\t# add matching w other tracks / photons in same chamber for the given event\n",
        "\t# add total \"probability\" of the zones in other tracks + other species\n",
        "\n",
        "\n",
        "\n",
        "\tprint(f\"classify_candidates_with_pad_sequences : x_values_data shape {x_values_data.shape}\")\n",
        "\tnon_zero_counts = np.count_nonzero(x_values_data, axis=1)\n",
        "\tunique_lengths = np.unique(non_zero_counts)\n",
        "\n",
        "\tfirst_elements_x = x_values_data[:, 0]\n",
        "\tunique_x = np.unique(first_elements_x)\n",
        "\tnum_unique_x = len(unique_x)\n",
        "\n",
        "\n",
        "\tfirst_elements_y = y_values_data[:, 0]\n",
        "\tunique_y = np.unique(first_elements_y)\n",
        "\tnum_unique_y = len(unique_y)\n",
        "\n",
        "\tfirst_elements_q = q_values_data[:, 0]\n",
        "\tunique_q = np.unique(first_elements_q)\n",
        "\tnum_unique_q = len(unique_q)\n",
        "\n",
        "\tunique_lengths = np.unique(non_zero_counts)\n",
        "\n",
        "\tnum_unique_lengths = len(unique_lengths)\n",
        "\n",
        "\n",
        "\n",
        "\tprint(f\"classify_candidates_with_pad_sequences : num_unique_lengths shape {num_unique_lengths}\")\n",
        "\tprint(f\"classify_candidates_with_pad_sequences : unique_x shape {num_unique_x}\")\n",
        "\tprint(f\"classify_candidates_with_pad_sequences : unique_y shape {num_unique_y}\")\n",
        "\tprint(f\"classify_candidates_with_pad_sequences : unique_q shape {num_unique_q}\")\n",
        "\n",
        "\n",
        "\n",
        "\t# classify_candidates_with_pad_sequences : x_values_data shape (750, 610)\n",
        "\t#non_zero_charges = np.count_nonzero(x_values_data[idx, :, 3])\n",
        "\n",
        "  #num_candidates_per_event = x_values_data\n",
        "\n",
        "\t# Ensure x_values_data has the right dimension\n",
        "\tif np.ndim(x_values_data) == 1:\n",
        "\t\tx_values_data = np.expand_dims(x_values_data, axis=-1)\n",
        "\n",
        "\t# Pad the sequences\n",
        "\n",
        "\tmax_clu_in_event = 1100\n",
        "\tx_padded = pad_and_stack(x_values_data, max_length=max_clu_in_event)\n",
        "\ty_padded = pad_and_stack(y_values_data, max_length=max_clu_in_event)\n",
        "\tq_padded = pad_and_stack(q_values_data, max_length=max_clu_in_event)\n",
        "\tsize_padded = pad_and_stack(mCluSize_lista, max_length=max_clu_in_event)\n",
        "\tcandStatus_padded = pad_and_stack(candStatus_values_data, max_length=max_clu_in_event).astype(int)\n",
        "\n",
        "\t# Modify candStatus based on charge and size threshold\n",
        "\tcandStatus_padded[(q_padded >= 150) & (size_padded >= 3)] = 1\n",
        "\t# candStatus_padded[outside_fiducial_zones] = 0\n",
        "\n",
        "\t# Define masks for different particle statuses\n",
        "\tproton_values = [2, 4, 6, 8]\n",
        "\tkaon_values = [3, 4, 7, 8] # 3,5,7,8 ??\n",
        "\tpion_values = [5, 6, 7, 8]\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\tproton_mask = np.isin(candStatus_padded, proton_values)\n",
        "\tkaon_mask = np.isin(candStatus_padded, kaon_values)\n",
        "\tpion_mask = np.isin(candStatus_padded, pion_values)\n",
        "\n",
        "\t# Stack the data into a single array\n",
        "\tpadded_data = np.stack([x_padded, y_padded, q_padded, size_padded], axis=-1)\n",
        "\n",
        "\t## ef added : 26/10\n",
        "\t# Stack the data into a single array\n",
        "\tpadded_data = np.stack([x_padded, y_padded, q_padded, size_padded, candStatus_padded], axis=-1)\n",
        "\n",
        "\t# Create masks for positive and non statuses\n",
        "\tpositive_mask = (candStatus_padded > 1).astype(bool)\n",
        "\tnon_mask = (candStatus_padded <= 1).astype(bool)\n",
        "\n",
        "\t# Populate particle candidates arrays\n",
        "\tpion_candidates = np.zeros_like(padded_data)\n",
        "\tkaon_candidates = np.zeros_like(padded_data)\n",
        "\tproton_candidates = np.zeros_like(padded_data)\n",
        "\tnon_candidates = np.zeros_like(padded_data)\n",
        "\tpion_candidates[positive_mask & pion_mask] = padded_data[positive_mask & pion_mask]\n",
        "\tkaon_candidates[positive_mask & kaon_mask] = padded_data[positive_mask & kaon_mask]\n",
        "\tproton_candidates[positive_mask & proton_mask] = padded_data[positive_mask & proton_mask]\n",
        "\n",
        "\n",
        "\n",
        "\tnon_candidates[non_mask] = padded_data[non_mask]\n",
        "\n",
        "\treturn pion_candidates, kaon_candidates, proton_candidates, non_candidates, candStatus_padded\n",
        "\n",
        "import random\n",
        "\n",
        "\n",
        "from sklearn.metrics import precision_recall_curve\n",
        "from sklearn.preprocessing import label_binarize\n",
        "import matplotlib.pyplot as plt\n",
        "from itertools import cycle\n",
        "\n",
        "import sys\n",
        "\n",
        "print(sys.getrecursionlimit()) # Prints 1000\n",
        "\n",
        "print_vals = False\n",
        "from numpy.linalg import norm\n",
        "from tensorflow.keras.backend import expand_dims\n",
        "from tensorflow.keras.preprocessing.sequence import pad_sequences\n",
        "from sklearn.metrics import precision_recall_curve, confusion_matrix\n",
        "\n",
        "from scipy.signal import find_peaks\n",
        "\n",
        "import os\n",
        "import h5py\n",
        "import numpy as np\n",
        "import tensorflow as tf\n",
        "from tensorflow.keras.models import Model\n",
        "from tensorflow.keras.layers import Activation, Input, Conv2D, Lambda, Flatten, Dense, concatenate, BatchNormalization, MaxPooling2D, Dropout, LeakyReLU, Masking, Embedding\n",
        "\n",
        "from sklearn.model_selection import train_test_split\n",
        "from sklearn.preprocessing import StandardScaler, LabelBinarizer\n",
        "import matplotlib.pyplot as plt\n",
        "from tensorflow.keras import regularizers\n",
        "\n",
        "from sklearn.metrics import precision_recall_curve\n",
        "from sklearn.metrics import f1_score\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "class Constants:\n",
        "\tPION_MASS = 0.1396\n",
        "\tKAON_MASS = 0.4937\n",
        "\tPROTON_MASS = 0.938\n",
        "\n",
        "np.set_printoptions(precision=4)\n",
        "\n",
        "@staticmethod\n",
        "def calculate_mass(momentum, refractiveIndex, ckov):\n",
        "\t\"\"\" args : momentum, refractiveIndex, ckov\n",
        "\t\treturns : mass\n",
        "\t\"\"\"\n",
        "\tmass = momentum * np.sqrt((refractiveIndex * np.cos(ckov))**2 - 1)\n",
        "\treturn mass\n",
        "\n",
        "\n",
        "class ParticleDataUtils:\n",
        "\n",
        "\tdef __init__(self, filenames =  [], percentage_to_read = 100):\n",
        "\t\tself.filename = filenames\n",
        "\t\tself.percentage_to_read = percentage_to_read\n",
        "\t\tself.particle_vector = []\n",
        "\t\tself.load_data(filenames=filenames)\n",
        "\n",
        "\t\t#\n",
        "\t\t# jeg flyttet\n",
        "\t\tself.particle_info = self.process_data(self.particle_vector, self.percentage_to_read)\n",
        "\t\tself.num_particles = len(self.particle_info)\n",
        "\n",
        "\n",
        "\t\t# new scalers to be created :\n",
        "\t\tself.phi_scaler, self.phi_stats = self.create_scalar_scaler(\"phiP\")\n",
        "\t\tself.theta_scaler, self.theta_stats = self.create_scalar_scaler(\"thetaP\")\n",
        "\t\tself.refractive_index_scaler, self.refractive_index_stats = self.create_scalar_scaler(\"refractiveIndex\")\n",
        "\t\tself.momentum_scaler, self.momentum_stats = self.create_scalar_scaler(\"momentum\")\n",
        "\t\tself.mCluSize_scaler, self.mCluSize_stats = self.create_scalar_scaler(\"mCluSize\")\n",
        "\t\tself.mCluCharge_scaler, self.mCluCharge_stats = self.create_scalar_scaler(\"mCluCharge\")\n",
        "\t\tprint(\"Created scaler for scalars\")\n",
        "\n",
        "\t\t# 2D\n",
        "\t\tself.mip_scaler, self.mip_stats = self.create_2D_scaler(\"mip_position\")\n",
        "\t\tself.rad_scaler, self.rad_stats = self.create_2D_scaler(\"rad_position\")\n",
        "\n",
        "\t\t# # vector of 2D\n",
        "\t\tself.proton_scalers, self.proton_stats = self.create_vector_scaler(\"proton_candidates\")\n",
        "\t\tself.kaon_scalers, self.kaon_stats = self.create_vector_scaler(\"kaon_candidates\")\n",
        "\t\tself.pion_scalers, self.pion_stats = self.create_vector_scaler(\"pion_candidates\")\n",
        "\n",
        "\n",
        "\n",
        "\t\t#self.ckov_scaler, self.ckov_stats = self.create_scaler(\"ckov\")\n",
        "\t\t#self.distances_scaler, self.distances_stats = self.create_scaler(\"distances\")def classify_candidates(candidates_data):\n",
        "\n",
        "\n",
        "\tclass Candidate2:\n",
        "\t\tdef __init__(self, x_values, y_values, chi2_values, q_values, xe_values, ye_values, candStatus_values):\n",
        "\t\t\tself.x_values = x_values\n",
        "\t\t\tself.y_values = y_values\n",
        "\t\t\tself.chi2_values = chi2_values\n",
        "\t\t\tself.q_values = q_values\n",
        "\t\t\tself.xe_values = xe_values\n",
        "\t\t\tself.ye_values = ye_values\n",
        "\t\t\tself.candStatus_values = candStatus_values\n",
        "\n",
        "\n",
        "\tclass ParticleInfo: # p\n",
        "\t\tdef __init__(self,  momentum, refractiveIndex, xRad, yRad, xMIP, yMIP, thetaP, phiP, mCluCharge, mCluSize, non_candidates, pion_candidates, kaon_candidates, proton_candidates, mTrackPdg, index, pion_flag, kaon_flag, proton_flag):\n",
        "\t\t\tself.momentum = momentum # this dhould be with\n",
        "\t\t\tself.refractiveIndex = refractiveIndex # with\n",
        "\t\t\tself.xRad = xRad # with\n",
        "\t\t\tself.yRad = yRad # with\n",
        "\n",
        "\t\t\tself.xMIP = xMIP # with\n",
        "\t\t\tself.yMIP = yMIP # with\n",
        "\n",
        "\t\t\tself.mCluCharge = mCluCharge # with\n",
        "\t\t\tself.mCluSize = mCluSize # with\n",
        "\n",
        "\t\t\tself.thetaP = thetaP# with\n",
        "\t\t\tself.phiP = phiP# with\n",
        "\t\t\tself.non_candidates = non_candidates # with the field candStatus is a int that is 0..7, please make it categorical\n",
        "\t\t\tself.rad_position = [xRad, yRad]\n",
        "\t\t\tself.mip_position = [xMIP, yMIP]\n",
        "\n",
        "\n",
        "\t\t\tself.pion_candidates = pion_candidates # pion_candidates = [1 if (int(candStatus) & 4) == 4 else 0 for candStatus in candsCombined]\n",
        "\t\t\tself.kaon_candidates = kaon_candidates # = kaon_candidates [1 if (int(candStatus) & 2) == 2 else 0 for candStatus in candsCombined]\n",
        "\t\t\tself.proton_candidates = proton_candidates # = proton_candidates[1 if (int(candStatus) & 1) == 1 else 0 for candStatus in candsCombined]\n",
        "\n",
        "\n",
        "\t\t\tself.pion_flag = pion_flag # pion_candidates = [1 if (int(candStatus) & 4) == 4 else 0 for candStatus in candsCombined]\n",
        "\t\t\tself.kaon_flag = kaon_flag # = kaon_candidates [1 if (int(candStatus) & 2) == 2 else 0 for candStatus in candsCombined]\n",
        "\t\t\tself.proton_flag = proton_flag # = proton_candidates[1 if (int(candStatus) & 1) == 1 else 0 for candStatus in candsCombined]\n",
        "\n",
        "\t\t\tself.mTrackPdg = mTrackPdg # with\n",
        "\t\t\tself.index_particle = index # with\n",
        "\n",
        "\t\t\tabs_mTrackPdg = abs(self.mTrackPdg)  # Take the absolute value\n",
        "\n",
        "\t\t\t# Set particleType based on absolute PDG code\n",
        "\t\t\tif abs_mTrackPdg == 211:\n",
        "\t\t\t\tself.particleType = 211#'pion'\n",
        "\t\t\telif abs_mTrackPdg == 321:\n",
        "\t\t\t\tself.particleType = 321#'kaon'\n",
        "\t\t\telif abs_mTrackPdg == 2212:\n",
        "\t\t\t\tself.particleType = 2212#'proton'\n",
        "\t\t\telse:\n",
        "\t\t\t\tself.particleType = -1\n",
        "\t\t\t\t#print(f\"pdg type was other : {abs_mTrackPdg}\")\n",
        "\n",
        "\n",
        "\t\t@staticmethod\n",
        "\t\tdef infer_mass_category_from_ckov(momentum, refractiveIndex, ckov):\n",
        "\t\t\tmass = momentum * np.sqrt((refractiveIndex * np.cos(ckov))**2 - 1)\n",
        "\n",
        "\t\t\tmass_category = \"unk_nown\"\n",
        "\t\t\tif abs(mass - Constants.PION_MASS) < 1e-4:\n",
        "\t\t\t\tmass_category = \"pion\"\n",
        "\t\t\telif abs(mass - Constants.KAON_MASS) < 1e-4:\n",
        "\t\t\t\tmass_category = \"kaon\"\n",
        "\t\t\telif abs(mass - Constants.PROTON_MASS) < 1e-4:\n",
        "\t\t\t\tmass_category = \"proton\"\n",
        "\t\t\tif print_vals:\n",
        "\t\t\t  print(f\"\\ninfer_mass_category_from_ckov :  momentum = {momentum}|  mass_calc = {mass} |  mass_category={mass_category} | refractiveIndex = {refractiveIndex} | ckov = {ckov}\")\n",
        "\t\t\treturn mass_category\n",
        "\n",
        "\t\t@staticmethod\n",
        "\t\tdef infer_mass_category(mass):\n",
        "\t\t\tif abs(mass - Constants.PION_MASS) < 1e-6:\n",
        "\t\t\t\treturn \"pion\"\n",
        "\t\t\telif abs(mass - Constants.KAON_MASS) < 1e-6:\n",
        "\t\t\t\treturn \"kaon\"\n",
        "\t\t\telif abs(mass - Constants.PROTON_MASS) < 1e-6:\n",
        "\t\t\t\treturn \"proton\"\n",
        "\t\t\telse:\n",
        "\t\t\t\treturn \"unk_nown\"\n",
        "\n",
        "\t\tdef __str__(self):\n",
        "\t\t\tif print_vals:\n",
        "\t\t\t  return (f\"ParticleInfo(momentum={self.momentum} | mass={self.mass} |  mass_category={self.mass_category} | \"\n",
        "\t\t\t\t\t  f\"refractiveIndex={self.refractiveIndex} | ckov={self.ckov} | rad_position={len(self.rad_position)}, \"\n",
        "\t\t\t\t\t  f\"mip_position={self.mip_position})\")\n",
        "\n",
        "\t#  ''' def calculate_distances_to_mip(self):\n",
        "\t#       \"\"\"Calculate Euclidean distances from all filled bins to MIP position\"\"\"\n",
        "\t#       filledBins_np = np.array(self.filledBins)\n",
        "\t#       mip_position_np = np.array(self.mip_position)\n",
        "\n",
        "\t#       distances = np.linalg.norm(filledBins_np - mip_position_np, axis=1)\n",
        "\t#       return distances'''\n",
        "\n",
        "\n",
        "\tdef load_data(self, filenames):\n",
        "\t\t\tmax_length_MIP = 0 # max antall MIPs for alle chamber i event\n",
        "\t\t\tverbose = False\n",
        "\t\t\tdrive_path = '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/'\n",
        "\n",
        "\t\t\tnum_equal = 0\n",
        "\t\t\tnum_particles = 0\n",
        "\t\t\tfile_num = 0\n",
        "\t\t\tnum_equal = 0\n",
        "\t\t\tmax_tracks_in_event = 0\n",
        "\t\t\tmax_clu_in_event = 0\n",
        "\t\t\tn_events = 0\n",
        "\n",
        "\n",
        "\t\t\tnum_pion_cands = 0\n",
        "\t\t\tnum_kaon_cands = 0\n",
        "\t\t\tnum_proton_cands = 0\n",
        "\n",
        "\n",
        "\n",
        "\t\t\tfor filename in filenames:\n",
        "\t\t\t\t\tfile_path = os.path.join(drive_path, filename)\n",
        "\t\t\t\t\tlengths = []\n",
        "\t\t\t\t\tnum_equals = []\n",
        "\t\t\t\t\twith h5py.File(file_path, 'r') as file:\n",
        "\t\t\t\t\t\t\tif verbose : print(f\"Reading file {filename}\")\n",
        "\n",
        "\t\t\t\t\t\t\tgroup_names = list(file.keys())  # Get all group names\n",
        "\t\t\t\t\t\t\ti = 0  # Initialize loop counter\n",
        "\n",
        "\t\t\t\t\t\t\twhile i < len(group_names):\n",
        "\t\t\t\t\t\t\t\t\t# Process the current track\n",
        "\t\t\t\t\t\t\t\t\tgroup_name = group_names[i]\n",
        "\t\t\t\t\t\t\t\t\tgroup = file[group_name]\n",
        "\t\t\t\t\t\t\t\t\t#print(f\"i {i} reading group {group_name}\")\n",
        "\n",
        "\t\t\t\t\t\t\t\t\tabs_pdg = group.attrs[\"TrackPdg\"]\n",
        "\t\t\t\t\t\t\t\t\tif abs_pdg == 211:\n",
        "\t\t\t\t\t\t\t\t\t\tnum_pion_cands += 1\n",
        "\t\t\t\t\t\t\t\t\telif abs_pdg == 321:\n",
        "\t\t\t\t\t\t\t\t\t\tnum_kaon_cands += 1\n",
        "\t\t\t\t\t\t\t\t\telif abs_pdg == 2212:\n",
        "\t\t\t\t\t\t\t\t\t\tnum_proton_cands += 1\n",
        "\n",
        "\t\t\t\t\t\t\t\t\tsizes = np.array(group['mSize_values'][...])\n",
        "\t\t\t\t\t\t\t\t\tcharges = np.array(group['q_values'][...])\n",
        "\n",
        "\t\t\t\t\t\t\t\t\tmip_mask = (charges >= 200) & (sizes >= 3)\n",
        "\t\t\t\t\t\t\t\t\ttrue_count_mip = np.sum(mip_mask)\n",
        "\t\t\t\t\t\t\t\t\tif true_count_mip > max_length_MIP:\n",
        "\t\t\t\t\t\t\t\t\t\tmax_length_MIP = true_count_mip\n",
        "\t\t\t\t\t\t\t\t\t\tprint(f\"mip_mask_condition count_nonzero {np.count_nonzero(mip_mask)}\")\n",
        "\t\t\t\t\t\t\t\t\t\tprint(f\"mip_mask_condition true_count_mip {true_count_mip}\")\n",
        "\n",
        "\t\t\t\t\t\t\t\t\tt = group['y_values'][...]\n",
        "\t\t\t\t\t\t\t\t\ty1 = t[0]\n",
        "\t\t\t\t\t\t\t\t\tcurrent_length = len(group['ye_values'][...])\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t# Initialize for the next loop\n",
        "\t\t\t\t\t\t\t\t\ti += 1\n",
        "\t\t\t\t\t\t\t\t\tend_condition = False\n",
        "\t\t\t\t\t\t\t\t\tnum_equal = 1  # Initialize with 1 since we have processed one group\n",
        "\t\t\t\t\t\t\t\t\tlengths.append(current_length)\n",
        "\t\t\t\t\t\t\t\t\tnum_particles += 1\n",
        "\t\t\t\t\t\t\t\t\twhile not end_condition and i < len(group_names):\n",
        "\t\t\t\t\t\t\t\t\t\t\t# Check for other tracks in the same event\n",
        "\t\t\t\t\t\t\t\t\t\t\tnext_group_name = group_names[i]\n",
        "\t\t\t\t\t\t\t\t\t\t\tnext_group = file[next_group_name]\n",
        "\t\t\t\t\t\t\t\t\t\t\tt_next = next_group['y_values'][...]\n",
        "\t\t\t\t\t\t\t\t\t\t\ty1_next = t_next[0]\n",
        "\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t\t\tif (len(next_group['ye_values'][...]) == current_length) and (y1_next == y1):\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t# Tracks are in the same event\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\tnum_equal += 1\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\ti += 1  # Move to next track\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\tnum_particles += 1\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\tlengths.append(len(next_group['ye_values'][...]))\n",
        "\t\t\t\t\t\t\t\t\t\t\telse:\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t# Tracks are not in the same event\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\tif num_equal > max_tracks_in_event:\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmax_tracks_in_event = num_equal\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\tend_condition = True\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\tn_events += 1\n",
        "\t\t\t\t\t\t\t\t\t\t\tif len(next_group['ye_values'][...]) > max_clu_in_event:\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\tmax_clu_in_event = len(next_group['ye_values'][...])\n",
        "\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t\t\tabs_pdg = group.attrs[\"TrackPdg\"]\n",
        "\t\t\t\t\t\t\t\t\t\t\tif abs_pdg == 211:\n",
        "\t\t\t\t\t\t\t\t\t\t\t\tnum_pion_cands += 1\n",
        "\t\t\t\t\t\t\t\t\t\t\telif abs_pdg == 321:\n",
        "\t\t\t\t\t\t\t\t\t\t\t\tnum_kaon_cands += 1\n",
        "\t\t\t\t\t\t\t\t\t\t\telif abs_pdg == 2212:\n",
        "\t\t\t\t\t\t\t\t\t\t\t\tnum_proton_cands += 1\n",
        "\n",
        "\t\t\t\t\t\t\t\t\tnum_equals.append(num_equal)\n",
        "\n",
        "\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t# Update variables for next iteration\n",
        "\t\t\t\t\t\t\t\t\tprev_length = current_length\n",
        "\t\t\t\t\t\t\t\t\ty_prev = y1\n",
        "\n",
        "\t\t\t\t\t#print(f\"num_equals :  {num_equals[:30]}\")\n",
        "\t\t\t\t\t# plt.hist(num_equals, bins='auto', edgecolor='black')\n",
        "\t\t\t\t\t# plt.xlabel('Length')\n",
        "\t\t\t\t\t# plt.ylabel('Frequency')\n",
        "\t\t\t\t\t# plt.title('Histogram of Lengths')\n",
        "\t\t\t\t\t# plt.show()\n",
        "\n",
        "\t\t\t\t\t# plt.hist(lengths, np.max(lengths), edgecolor='black')\n",
        "\t\t\t\t\t# plt.xlabel('lengths')\n",
        "\t\t\t\t\t# plt.ylabel('lengths')\n",
        "\t\t\t\t\t# plt.title('Histogram of lengths')\n",
        "\t\t\t\t\t# plt.show()\n",
        "\n",
        "\t\t\tprint(f\"==================== Finisyhed LOOP ===============\")\n",
        "\n",
        "\t\t\t# Lists to store scalar and array-like attributes\n",
        "\n",
        "\t\t\tevent_data_dict_dtype2 = np.dtype({\n",
        "\t\t\t\t\t'names': ['Momentum', 'RefractiveIndex', 'xRad', 'yRad', 'xMip', 'yMip', 'ThetaP', 'PhiP', 'CluCharge', 'CluSize', 'TrackPdg', 'ckovReconstructed'],\n",
        "\t\t\t\t\t'formats': [np.float64, np.float64, np.float64, np.float64, np.float64, np.float64, np.float64, np.float64, np.float64, np.float64, np.int32, np.bool_],\n",
        "\t\t\t\t\t'shapes': [(max_tracks_in_event, 1)] * 12\n",
        "\t\t\t})\n",
        "\n",
        "\t\t\tprint(f\"==================== Finisyhed all_events_data_dtype ===============\")\n",
        "\n",
        "\n",
        "\t\t\t#\tpadded_data = np.stack([x_padded, y_padded, q_padded, size_padded, phi_cer_padded, theta_cer_padded, sigma_ring_padded, pion_prob_per_specie, kaon_prob_per_specie, proton_prob_per_specie, L_track, L_all_tracks], axis=-1)\n",
        "\n",
        "\t\t\tnum_features_cluster_candidates = 12\n",
        "\t\t\tall_events_data_dtype = np.dtype([\n",
        "\t\t\t\t\t('p_specie_per_track', float, (max_tracks_in_event, max_clu_in_event, 5)),\n",
        "\t\t\t\t\t('L_track', float, (max_tracks_in_event, max_clu_in_event)),\n",
        "\t\t\t\t\t('L_all_tracks', float, (max_clu_in_event)),\n",
        "\t\t\t\t\t('padded_data', float, ( max_clu_in_event, max_tracks_in_event, num_features_cluster_candidates)),\n",
        "\t\t\t\t\t('pion_candidates', float, (max_clu_in_event, max_tracks_in_event, num_features_cluster_candidates)),\n",
        "\t\t\t\t\t('kaon_candidates', float, (max_clu_in_event, max_tracks_in_event, num_features_cluster_candidates)),\n",
        "\t\t\t\t\t('proton_candidates', float, (max_clu_in_event, max_tracks_in_event, num_features_cluster_candidates)),\n",
        "\t\t\t\t\t('high_charge_size', float, (max_clu_in_event, max_tracks_in_event,  4)), # lagre alle \"MIP\" per event {x, y, size, Q} for √• evaluare FB fotoner\n",
        "\t\t\t\t\t('ckov_hyps_tracks_in_event', float,  (max_tracks_in_event, 3)), # Ckov Hyps for species for all tracks in event\n",
        "\t\t\t\t\t('event_data_dict', event_data_dict_dtype2, (1,)),  # This adds event_data_dict as a sub-array\n",
        "\t\t\t])\n",
        "\n",
        "\n",
        "\n",
        "\t\t\tall_events_data = np.zeros(n_events, dtype=all_events_data_dtype)\n",
        "\n",
        "\t\t\tpion_data = []\n",
        "\t\t\tkaon_data = []\n",
        "\t\t\tproton_data = []\n",
        "\n",
        "\t\t\t# these holds the info for a track to be reconstricted\n",
        "\t\t\tparticle_dict = {\n",
        "\t\t\t\t\t'Momentum': np.zeros((num_particles, 1)),\n",
        "\t\t\t\t\t'RefractiveIndex': np.zeros((num_particles, 1)),\n",
        "\t\t\t\t\t'xRad': np.zeros((num_particles, 1)),\n",
        "\t\t\t\t\t'yRad': np.zeros((num_particles, 1)),\n",
        "\t\t\t\t\t'xMip': np.zeros((num_particles, 1)),\n",
        "\t\t\t\t\t'yMip': np.zeros((num_particles, 1)),\n",
        "\t\t\t\t\t'ThetaP': np.zeros((num_particles, 1)),\n",
        "\t\t\t\t\t'PhiP': np.zeros((num_particles, 1)),\n",
        "\t\t\t\t\t'CluCharge': np.zeros((num_particles, 1)),\n",
        "\t\t\t\t\t'CluSize': np.zeros((num_particles, 1)),\n",
        "\t\t\t\t\t'TrackPdg': np.zeros((num_particles, 1)),\n",
        "\t\t\t\t\t'ckovReconstructed': np.zeros((num_particles, 1))\n",
        "\t\t\t}\n",
        "\n",
        "\n",
        "\n",
        "\t\t\t# m√• gj√∏res i loop\n",
        "\t\t\tother_tracks_dict = {\n",
        "\t\t\t\t\t'Momentum': np.zeros((num_particles, max_tracks_in_event)),\n",
        "\t\t\t\t\t'RefractiveIndex': np.zeros((num_particles, max_tracks_in_event)),\n",
        "\t\t\t\t\t'xRad': np.zeros((num_particles, max_tracks_in_event)),\n",
        "\t\t\t\t\t'yRad': np.zeros((num_particles, max_tracks_in_event)),\n",
        "\t\t\t\t\t'xMip': np.zeros((num_particles, max_tracks_in_event)),\n",
        "\t\t\t\t\t'yMip': np.zeros((num_particles, max_tracks_in_event)),\n",
        "\t\t\t\t\t'ThetaP': np.zeros((num_particles, max_tracks_in_event)),\n",
        "\t\t\t\t\t'PhiP': np.zeros((num_particles, max_tracks_in_event)),\n",
        "\t\t\t\t\t'CluCharge': np.zeros((num_particles, max_tracks_in_event)),\n",
        "\t\t\t\t\t'CluSize': np.zeros((num_particles, max_tracks_in_event)),\n",
        "\t\t\t\t\t'TrackPdg': np.zeros((num_particles, max_tracks_in_event)),\n",
        "\t\t\t\t\t'ckovReconstructed': np.zeros((num_particles, max_tracks_in_event))\n",
        "\t\t\t}\n",
        "\n",
        "\n",
        "\n",
        "\t\t\t# np arrs holding attributes per event\n",
        "\n",
        "\t\t\t# denne er ok\n",
        "\n",
        "\n",
        "\n",
        "\t\t\t# these holds the values per event individiually\n",
        "\n",
        "\n",
        "\t\t\t# denne er ok\n",
        "\t\t\tvalues_data_dict = {\n",
        "\t\t\t\t\t'x_values': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t\t\t\t'y_values': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t\t\t\t'chi2_values': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t\t\t\t'q_values': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t\t\t\t'xe_values': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t\t\t\t'ye_values': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t\t\t\t'candStatusCkov_values': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t\t\t\t'phiCerValues': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t\t\t\t'thetaCerValues': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t\t\t\t'sigmaRingValues': np.zeros((num_particles, max_clu_in_event)),\n",
        "\t\t\t\t\t'mSize_values': np.zeros((num_particles, max_clu_in_event))\n",
        "\t\t\t}\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\t\t\tindex_particle = 0\n",
        "\n",
        "\t\t\tdef list_all_keys(h5_group, prefix=''):\n",
        "\t\t\t\tkeys = []\n",
        "\t\t\t\tfor key in h5_group:\n",
        "\t\t\t\t\t\tcurrent_key = f\"{prefix}/{key}\"\n",
        "\t\t\t\t\t\tkeys.append(current_key)\n",
        "\t\t\t\t\t\tif isinstance(h5_group[key], h5py.Group):\n",
        "\t\t\t\t\t\t\t\tkeys.extend(list_all_keys(h5_group[key], current_key))\n",
        "\t\t\t\treturn keys\n",
        "\n",
        "\t\t\t\tfilenames = os.listdir(drive_path)\n",
        "\n",
        "\t\t\tall_keys = []\n",
        "\t\t\tind = 0\n",
        "\t\t\tindex_particle = 0\n",
        "\t\t\t#for filename in filenames:\n",
        "\t\t\t#\t\tfile_path = os.path.join(drive_path, filename)\n",
        "\t\t\t#\t\twith h5py.File(file_path, 'r') as file:\n",
        "\t\t\t#\t\t\t\tfor i, group_name in enumerate(file):\n",
        "\t\t\t#\t\t\t\t\t\t#print(group_name)  # This line will print the key name\n",
        "\n",
        "\t\t\t#\t\t\t\t#ind = ind + 1\n",
        "\n",
        "\t\t\tprint(f\"\\n 2nd LOOP \")\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\t\t\tdef make_cand_dict(num_particles_of_specie, SPECIE_NAME) :\n",
        "\n",
        "\n",
        "\n",
        "\t\t\t\t# Hadron candidate specifications :\n",
        "\t\t\t\thadron_candidate_dict = {\n",
        "\t\t\t\t\t'x_padded': np.zeros((num_particles_of_specie, max_clu_in_event)),  # Example initial data\n",
        "\t\t\t\t\t'y_padded': np.zeros((num_particles_of_specie, max_clu_in_event)),\n",
        "\t\t\t\t\t'q_padded': np.zeros((num_particles_of_specie, max_clu_in_event)),\n",
        "\t\t\t\t\t'size_padded': np.zeros((num_particles_of_specie, max_clu_in_event)),\n",
        "\t\t\t\t\t'phi_cer_padded': np.zeros((num_particles_of_specie, max_clu_in_event)),\n",
        "\t\t\t\t\t'theta_cer_padded': np.zeros((num_particles_of_specie, max_clu_in_event)),\n",
        "\t\t\t\t\t'sigma_ring_padded': np.zeros((num_particles_of_specie, max_clu_in_event)),\n",
        "\t\t\t\t\t'pion_prob_per_specie': np.zeros((num_particles_of_specie, max_clu_in_event)),\n",
        "\t\t\t\t\t'kaon_prob_per_specie': np.zeros((num_particles_of_specie, max_clu_in_event)),\n",
        "\t\t\t\t\t'proton_prob_per_specie': np.zeros((num_particles_of_specie, max_clu_in_event)),\n",
        "\t\t\t\t\t'L_track': np.zeros((num_particles_of_specie, max_clu_in_event)),\n",
        "\t\t\t\t\t'L_all_tracks': np.zeros((num_particles_of_specie, max_clu_in_event))\n",
        "\t\t\t\t}\n",
        "\n",
        "\t\t\t\tcandidate_dict = {\n",
        "\t\t\t\t\t\"PIONS\" : hadron_candidate_dict.copy(),\n",
        "\t\t\t\t\t\"KAONS\" : hadron_candidate_dict.copy(),\n",
        "\t\t\t\t\t\"PROTONS\" : hadron_candidate_dict.copy(),\n",
        "\t\t\t\t}\n",
        "\n",
        "\t\t\t\tother_tracks_dict = {\n",
        "\t\t\t\t\t'Momentum': np.zeros((num_particles_of_specie, max_tracks_in_event)),\n",
        "\t\t\t\t\t'RefractiveIndex': np.zeros((num_particles_of_specie, max_tracks_in_event)),\n",
        "\t\t\t\t\t'xRad': np.zeros((num_particles_of_specie, max_tracks_in_event)),\n",
        "\t\t\t\t\t'yRad': np.zeros((num_particles_of_specie, max_tracks_in_event)),\n",
        "\t\t\t\t\t'xMip': np.zeros((num_particles_of_specie, max_tracks_in_event)),\n",
        "\t\t\t\t\t'yMip': np.zeros((num_particles_of_specie, max_tracks_in_event)),\n",
        "\t\t\t\t\t'ThetaP': np.zeros((num_particles_of_specie, max_tracks_in_event)),\n",
        "\t\t\t\t\t'PhiP': np.zeros((num_particles_of_specie, max_tracks_in_event)),\n",
        "\t\t\t\t\t'CluCharge': np.zeros((num_particles_of_specie, max_tracks_in_event)),\n",
        "\t\t\t\t\t'CluSize': np.zeros((num_particles_of_specie, max_tracks_in_event)),\n",
        "\t\t\t\t\t'TrackPdg': np.zeros((num_particles_of_specie, max_tracks_in_event)),\n",
        "\t\t\t\t\t'ckovReconstructed': np.zeros((num_particles_of_specie, max_tracks_in_event)),\n",
        "\t\t\t\t\t'CkovTheoretical': np.zeros((num_particles_of_specie, max_tracks_in_event, 3))  # add CkovHyps here\n",
        "\t\t\t\t}\n",
        "\n",
        "\t\t\t\tparticle_dict = {\n",
        "\t\t\t\t\t'Momentum': np.zeros((num_particles_of_specie, 1)),\n",
        "\t\t\t\t\t'RefractiveIndex': np.zeros((num_particles_of_specie, 1)),\n",
        "\t\t\t\t\t'xRad': np.zeros((num_particles_of_specie, 1)),\n",
        "\t\t\t\t\t'yRad': np.zeros((num_particles_of_specie, 1)),\n",
        "\t\t\t\t\t'xMip': np.zeros((num_particles_of_specie, 1)),\n",
        "\t\t\t\t\t'yMip': np.zeros((num_particles_of_specie, 1)),\n",
        "\t\t\t\t\t'ThetaP': np.zeros((num_particles_of_specie, 1)),\n",
        "\t\t\t\t\t'PhiP': np.zeros((num_particles_of_specie, 1)),\n",
        "\t\t\t\t\t'CluCharge': np.zeros((num_particles_of_specie, 1)),\n",
        "\t\t\t\t\t'CluSize': np.zeros((num_particles_of_specie, 1)),\n",
        "\t\t\t\t\t'TrackPdg': np.zeros((num_particles_of_specie, 1)),\n",
        "\t\t\t\t\t'ckovReconstructed': np.zeros((num_particles_of_specie, 1)),\n",
        "\t\t\t\t\t'CkovTheoretical': np.zeros((num_particles_of_specie, 3)), # add CkovHyps here\n",
        "\t\t\t\t\t'MIPS': np.zeros((num_particles_of_specie, max_clu_in_event, 4)) # hold info abt MIPs (primary and secondary) : to evaluate FB p\n",
        "\t\t\t\t}\n",
        "\n",
        "\n",
        "\t\t\t\tSPECIE_data = {\n",
        "\t\t\t\t\t'CANDIDATES': candidate_dict.copy(),\n",
        "\t\t\t\t\t'OTHER_TRACK': other_tracks_dict.copy(),\n",
        "\t\t\t\t\t'CURRENT_TRACK': particle_dict.copy()\n",
        "\t\t\t\t}\n",
        "\n",
        "\t\t\t\treturn SPECIE_data\n",
        "\n",
        "\t\t\tPROTON_data = make_cand_dict(num_proton_cands, \"PROTON\")\n",
        "\t\t\tKAON_data = make_cand_dict(num_kaon_cands, \"PION\")\n",
        "\t\t\tPION_data = make_cand_dict(num_pion_cands, \"KAON\")\n",
        "\t\t\tprint(f\"num_proton_cands {num_proton_cands} | num_kaon_cands {num_kaon_cands} | num_pion_cands {num_pion_cands}\")\n",
        "\n",
        "\n",
        "\t\t\tSPECIES_DICTIONARY = {\n",
        "\t\t\t\t'PROTON_data': PROTON_data.copy(),\n",
        "\t\t\t\t'KAON_data': KAON_data.copy(),\n",
        "\t\t\t\t'PION_data': PION_data.copy()\n",
        "\t\t\t}\n",
        "\t\t\tINDEX_VALID_PION, INDEX_VALID_PROTON, INDEX_VALID_KAON = 0, 0, 0\n",
        "\t\t\tfor filename in filenames:\n",
        "\t\t\t\t\tfile_path = os.path.join(drive_path, filename)\n",
        "\t\t\t\t\twith h5py.File(file_path, 'r') as file:\n",
        "\t\t\t\t\t\t\tif verbose : print(f\"reading file {filename}\")\n",
        "\n",
        "\t\t\t\t\t\t\tgroup_names = list(file.keys())\n",
        "\t\t\t\t\t\t\ti = 0\n",
        "\n",
        "\n",
        "\t\t\t\t\t\t\t# list holding all teh photons values per track in event\n",
        "\t\t\t\t\t\t\t#list_of_values = []\n",
        "\t\t\t\t\t\t\twhile i < len(group_names):\n",
        "\t\t\t\t\t\t\t\t\tgroup_name = group_names[i]\n",
        "\t\t\t\t\t\t\t\t\tgroup = file[group_name]\n",
        "\t\t\t\t\t\t\t\t\t#print(f\"i {i} reading group {group_name} index_particle {index_particle}\")\n",
        "\n",
        "\n",
        "\n",
        "\t\t\t\t\t\t\t\t\tevent_data_dict = {\n",
        "\t\t\t\t\t\t\t\t\t\t\t'Momentum': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t\t\t\t\t\t\t\t'RefractiveIndex': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t\t\t\t\t\t\t\t'xRad': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t\t\t\t\t\t\t\t'yRad': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t\t\t\t\t\t\t\t'xMip': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t\t\t\t\t\t\t\t'yMip': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t\t\t\t\t\t\t\t'ThetaP': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t\t\t\t\t\t\t\t'PhiP': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t\t\t\t\t\t\t\t'CluCharge': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t\t\t\t\t\t\t\t'CluSize': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t\t\t\t\t\t\t\t'TrackPdg': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t\t\t\t\t\t\t\t'ckovReconstructed': np.zeros((max_tracks_in_event, 1)),\n",
        "\t\t\t\t\t\t\t\t\t}  # add CkovHyps here?\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t# Reset for each new event\n",
        "\t\t\t\t\t\t\t\t\tnum_tracks_in_event = 0\n",
        "\n",
        "\t\t\t\t\t\t\t\t\tif verbose : print(\"assign_attributes_from_group\")\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t# if group.attrs[\"TrackPdg\"] == 211:\n",
        "\t\t\t\t\t\t\t\t\t# \tif (group.attrs[\"Momentum\"] < 3.1) & (group.attrs[\"Momentum\"] > 2.7) :\n",
        "\t\t\t\t\t\t\t\t\t# \t\tthetaCerValues = group['thetaCerValues'][...]\n",
        "\t\t\t\t\t\t\t\t\t# \t\tsigmaRingValues = group['sigmaRingValues'][...]\n",
        "\t\t\t\t\t\t\t\t\t# \t\tprint(f\"thetaCerValues {thetaCerValues}\")\n",
        "\t\t\t\t\t\t\t\t\t# \t\tprint(f\"thetaCerValues.shape {thetaCerValues.shape}\")\n",
        "\n",
        "\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t# \t\ttry:\n",
        "\t\t\t\t\t\t\t\t\t# \t\t\tprint( \"TRY : thetaCerValues---assign_values_from_group thetaCerValues\")\n",
        "\t\t\t\t\t\t\t\t\t# \t\t\tassign_values_from_group(draw_something, group, \"thetaCerValues\", index_particle, actual_length)\n",
        "\t\t\t\t\t\t\t\t\t# \t\t\tprint( \"thetaCerValues---assign_values_from_group thetaCerValues\")\n",
        "\t\t\t\t\t\t\t\t\t# \t\texcept Exception as e:\n",
        "\t\t\t\t\t\t\t\t\t# \t\t\tprint(f\"An error occurred while assigning values to data_dict[{key}]: {e}\")\n",
        "\t\t\t\t\t\t\t\t\t# \t\t\tprint(f\"group[key][...].shape {group[key][...].shape}\")\n",
        "\t\t\t\t\t\t\t\t\t# \t\t\tprint(f\"index_particle {index_particle} | actual_length {actual_length}\")\n",
        "\t\t\t\t\t\t\t\t\t# \t\t\tprint(f\"draw_something[key].shape {draw_something[].shape}\") # sexegutt\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t# \t\t\traise\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t# \t\tprint( \"TRY : thetaCerValues---assign_values_from_group sigmaRingValues\")\n",
        "\t\t\t\t\t\t\t\t\t# \t\tassign_values_from_group(draw_something, group, \"sigmaRingValues\", index_particle, actual_length)\n",
        "\t\t\t\t\t\t\t\t\t# \t\tprint( \"thetaCerValues---assign_values_from_group sigmaRingValues\")\n",
        "\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t# \t\ttry:\n",
        "\t\t\t\t\t\t\t\t\t# \t\t\tckov = group.attrs[\"ckovReconstructed\"]\n",
        "\t\t\t\t\t\t\t\t\t# \t\t\tprint( \"TRY : thetaCerValues---assign_values_from_group ckovReconstructed\")\n",
        "\t\t\t\t\t\t\t\t\t# \t\t\tassign_values_from_group(draw_something, group, \"ckovReconstructed\", index_particle)\n",
        "\t\t\t\t\t\t\t\t\t# \t\t\tprint( \"thetaCerValues---assign_values_from_group thetaCerValues\")\n",
        "\t\t\t\t\t\t\t\t\t# \t\texcept Exception as e:\n",
        "\t\t\t\t\t\t\t\t\t# \t\t\tprint(f\"An error occurred while assigning values to data_dict[{key}]: {e}\")\n",
        "\t\t\t\t\t\t\t\t\t# \t\t\tprint(f\"group[key][...].shape {group[key][...].shape}\")\n",
        "\t\t\t\t\t\t\t\t\t# \t\t\tprint(f\"index_particle {index_particle} \")\n",
        "\t\t\t\t\t\t\t\t\t# \t\t\traise\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\t\t\t\t\t\t\t\t\tfor key in event_data_dict:\n",
        "\t\t\t\t\t\t\t\t\t\t\tassign_attributes_from_group(event_data_dict, group, key, num_tracks_in_event)\n",
        "\n",
        "\t\t\t\t\t\t\t\t\tif verbose:\n",
        "\t\t\t\t\t\t\t\t\t\tprint(\"assign_values_from_group\")\n",
        "\n",
        "\t\t\t\t\t\t\t\t\tfor key in values_data_dict:\n",
        "\t\t\t\t\t\t\t\t\t\t\tactual_length = len(group[key][...])\n",
        "\t\t\t\t\t\t\t\t\t\t\tassign_values_from_group(values_data_dict, group, key, index_particle, actual_length)\n",
        "\t\t\t\t\t\t\t\t\t\t\t#print(f\"check  values_data_dict {key} { values_data_dict[key][index_particle, :actual_length]}\")\n",
        "\t\t\t\t\t\t\t\t\tif verbose:\n",
        "\t\t\t\t\t\t\t\t\t\tprint(\"assign_particle_dict\")\n",
        "\n",
        "\t\t\t\t\t\t\t\t\tfor key in particle_dict:\n",
        "\t\t\t\t\t\t\t\t\t\t\tassign_particle_dict(particle_dict, group, key, index_particle)\n",
        "\t\t\t\t\t\t\t\t\t\t\t#print(f\"ceeck  particle_dict{key} { values_data_dict[key][index_particle, :actual_length]}\")\n",
        "\n",
        "\t\t\t\t\t\t\t\t\tif verbose:\n",
        "\t\t\t\t\t\t\t\t\t\tprint(\"checking other tracks ... \")\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t# we have processed one track :\n",
        "\t\t\t\t\t\t\t\t\ti += 1\n",
        "\n",
        "\n",
        "\t\t\t\t\t\t\t\t\tcurrent_length = len(group['ye_values'][...])\n",
        "\t\t\t\t\t\t\t\t\tprev_length = current_length\n",
        "\t\t\t\t\t\t\t\t\ty_values_prev = group['y_values'][...]\n",
        "\t\t\t\t\t\t\t\t\ty_0_prev = y_values_prev[0]\n",
        "\n",
        "\t\t\t\t\t\t\t\t\tend_condition = False\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\t\t\t\t\t\t\t\t\twhile not end_condition and i < len(group_names):\n",
        "\t\t\t\t\t\t\t\t\t\t\tnext_group_name = group_names[i]\n",
        "\t\t\t\t\t\t\t\t\t\t\tgroup = file[next_group_name]\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t\t\tcurrent_length = len(group['ye_values'][...])\n",
        "\t\t\t\t\t\t\t\t\t\t\ty_values = group['y_values'][...]\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t\t\ty_values = group['y_values'][...]\n",
        "\n",
        "\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t\t\ty_0 = y_values[0]\n",
        "\t\t\t\t\t\t\t\t\t\t\tif verbose : print(f\"current_length {current_length} y_0 {y_0}\")\n",
        "\t\t\t\t\t\t\t\t\t\t\tif verbose : print(f\"prev_length {prev_length} y_0_prev {y_0_prev}\")\n",
        "\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t\t\tif (current_length == prev_length) and (y_0_prev == y_0):\n",
        "\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t# move to next index in chamber-event\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\tnum_tracks_in_event += 1\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t#print(\"assign_attributes_from_group\")\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\tfor key in event_data_dict:\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tassign_attributes_from_group(event_data_dict, group, key, num_tracks_in_event)\n",
        "\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t#print(\"assign_values_from_group\")\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\tfor key in values_data_dict:\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tactual_length = len(group[key][...])\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tassign_values_from_group(values_data_dict, group, key, index_particle, actual_length)\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#print(f\"check  values_data_dict {key} { values_data_dict[key][index_particle, :actual_length]}\")\n",
        "\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t#print(\"assign_particle_dict\")\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\tfor key in particle_dict:\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tassign_particle_dict(particle_dict, group, key, index_particle)\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t# skip to next since weve processed a track\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\ti += 1\n",
        "\n",
        "\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t# move onto next track\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\tindex_particle += 1\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t\t\t# we have moved onto another chamber or event\n",
        "\t\t\t\t\t\t\t\t\t\t\telse:\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\tif verbose : print(f\" was not equal ! current_length {current_length} prev_length {prev_length} \")\n",
        "\n",
        "\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\tprint(f\"index_particle {index_particle}  num_tracks_in_event { num_tracks_in_event}\")\n",
        "\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\tif num_tracks_in_event > 1:\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor i in range(index_particle, index_particle + num_tracks_in_event):\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor key in values_data_dict:\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif verbose : print(f\"check  values_data_dict {key} { values_data_dict[key][i, :actual_length]}\")\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\telse :\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor key in values_data_dict:\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif verbose : print(f\"check  values_data_dict {key} { values_data_dict[key][index_particle, :actual_length]}\")\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#print(f\"check  values_data_dict {key} { values_data_dict[key][i-1, :actual_length]}\")\n",
        "\n",
        "\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\tclassify_candidates_with_pad_sequences2(other_tracks_dict, event_data_dict, values_data_dict, all_events_data, index_particle, num_tracks_in_event, max_clu_in_event, SPECIES_DICTIONARY, INDEX_VALID_PION, INDEX_VALID_PROTON, INDEX_VALID_KAON)\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\tend_condition = True\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t# sender :\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t#           event_data_dict : list av alle momentum etc for tracks in chamber-event\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t#           event_data_dict : length : number of tracks in chamber-event\n",
        "\n",
        "\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t#           values_data_dict : x,y... for alle clusters i chamber-event\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t#           values_data_dict : vil ha samme x,y... verdier, men ha forskjellige cand-status\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t# \t\t\t\t\tvalues_data_dict : length = all tracks to be reconstructed over all events\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t#\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t# other_tracks_dict will be fileld here :\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t# just places event_data_dict at index :\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t#  \tother_tracks_dict : (num_particles, max_tracks_in_event)\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t#  \tevent_data_dict : (max_tracks_in_event, 1)\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t# index_particle : will give last track in event-chamber\n",
        "\t\t\t\t\t\t\t\t\t\t\t\t\t# index_particle - num_tracks_in_event gives the first track\n",
        "\n",
        "\n",
        "\t\t\t\t\t\t\t\t\t\t\ty_0_prev = y_0\n",
        "\t\t\t\t\t\t\t\t\t\t\tprev_length = current_length\n",
        "\t\t\t\t\t\t\t\t\tindex_particle += 1\n",
        "\n",
        "\t\t\t# pion_candidates, kaon_candidates, proton_candidates, non_candidates, cand_combined = classify_candidates_with_pad_sequences(\n",
        "\t\t\t# \tx_values_data_list, y_values_data_list, size_clu_lst,\n",
        "\t\t\t# \tq_values_data_list, candStatus_values_data_list,\n",
        "\t\t\t# \tmax_clu_in_event,xMIP_list, yMIP_list,\n",
        "\t\t\t# \tphiCervalues_lst_data_list, sigmaRing_lst_data_list,\n",
        "\t\t\t# \tthetaCervalues_lst_data_list,\n",
        "\t\t\t# \tckovhough_list\n",
        "\t\t\t# )\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\t\t\tprint(f\"LOOP2 finished!\")\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\t\t\t# for species, species_data in SPECIES_DICTIONARY.items():\n",
        "\t\t\t# \tprint(f\"\\n{species} data:\")\n",
        "\t\t\t# \tfor category, category_dict in species_data.items():\n",
        "\t\t\t# \t\tprint(f\"  {category}:\")\n",
        "\t\t\t# \t\tfor key, value in category_dict.items():\n",
        "\t\t\t# \t\t\tif isinstance(value, np.ndarray):\n",
        "\t\t\t# \t\t\t\t# If the value is a numpy array, print its shape and number of non-zero entries\n",
        "\t\t\t# \t\t\t\tprint(f\"    {species}, {category}, {key}: shape {value.shape}, number of non-zero entries {np.count_nonzero(value)}\")\n",
        "\t\t\t# \t\t\telse:\n",
        "\t\t\t# \t\t\t\t# For other types (like nested dictionaries), just print the key and type of the value\n",
        "\t\t\t# \t\t\t\tprint(f\"    {species}, {category}, {key}: type {type(value).__name__}\")\n",
        "\n",
        "\n",
        "\n",
        "\t\t\tdef print_nested_dict(d, species='', category=''):\n",
        "\t\t\t\tfor key, value in d.items():\n",
        "\t\t\t\t\tif isinstance(value, np.ndarray):\n",
        "\t\t\t\t\t\tprint(f\"    {species}, {category}, {key}: shape {value.shape}, number of non-zero entries {np.count_nonzero(value)}\")\n",
        "\t\t\t\t\t\tprint(f\"    {species}, {category}, {key}: value {value[:2,:]}\")\n",
        "\n",
        "\t\t\t\t\telif isinstance(value, dict):\n",
        "\t\t\t\t\t\tprint_nested_dict(value, species, key)\n",
        "\t\t\t\t\telse:\n",
        "\t\t\t\t\t\tprint(f\"    {species}, {category}, {key}: type {type(value).__name__}\")\n",
        "\n",
        "\t\t\tfor species, species_data in SPECIES_DICTIONARY.items():\n",
        "\t\t\t\tprint(f\"\\n{species} data:\")\n",
        "\t\t\t\tfor category, category_dict in species_data.items():\n",
        "\t\t\t\t\tprint(f\"  {category}:\")\n",
        "\t\t\t\t\tprint_nested_dict(category_dict, species, category)\n",
        "\n",
        "\n",
        "\t\t\tprint(f\"for species, species_data in SPECIES_DICTIONARY.items():!\")\n",
        "\n",
        "\n",
        "\n",
        "\t\t\t# save the data ;\n",
        "\t\t\timport pickle\n",
        "\t\t\twith open('species_data.pkl', 'wb') as file:\n",
        "\t\t\t\tpickle.dump(SPECIES_DICTIONARY, file)\n",
        "\t\t\t#np.savez_compressed('data.npz', array1=array1, array2=array2, ...)  # add more arrays as needed\n",
        "\n",
        "\t\t\t# Load the dictionary from the file\n",
        "\t\t\twith open('species_data.pkl', 'rb') as file:\n",
        "\t\t\t\tloaded_species_dictionary = pickle.load(file)\n",
        "\n",
        "\n",
        "\n",
        "\t\t\t# Replace 'species_data.pkl' with the path to your pickle file\n",
        "\t\t\tpickle_file_path = 'species_data.pkl'\n",
        "\n",
        "\t\t\t# Get the size of the file in bytes\n",
        "\t\t\tfile_size_bytes = os.path.getsize(pickle_file_path)\n",
        "\n",
        "\t\t\t# Optionally, convert the size to kilobytes (KB) or megabytes (MB)\n",
        "\t\t\tfile_size_kb = file_size_bytes / 1024  # KB\n",
        "\t\t\tfile_size_mb = file_size_kb / 1024     # MB\n",
        "\n",
        "\t\t\tprint(f\"Size of the pickle file: {file_size_bytes} bytes ({file_size_kb} KB / {file_size_mb} MB)\")\n",
        "\n",
        "\n",
        "\n",
        "\t\t\t# print(f\"candStatus_values_data_list shape {candStatus_values_data_list.shape}\")\n",
        "\t\t\t# print(f\"candStatus_values_data_list  {candStatus_values_data_list[:5, :3]}\")\n",
        "\n",
        "\t\t\t# print(f\"pion_candidates shape {pion_candidates.shape}\")\n",
        "\t\t\t# print(f\"Dtype pion_candidates : {pion_candidates.dtype}\")  # Output will be something like: int64\n",
        "\t\t\t# print(f\"Dtype momentum_list : {momentum_list.dtype}\")  # Output will be something like: int64\n",
        "\n",
        "\t\t\t# print(f\"momentum_list shape {momentum_list.shape}\")\n",
        "\n",
        "\n",
        "\t\t\t# particle_vector = [None] * len(momentum_list)\n",
        "\n",
        "\t\t\t# MIP_list = np.hstack([xMIP_list, yMIP_list])\n",
        "\n",
        "\t\t\t# # Reshape the array to (N, 1, 2)\n",
        "\t\t\t# MIP_list_reshaped = MIP_list[:, np.newaxis, :]\n",
        "\n",
        "\t\t\t# # Extract only the x and y coordinates from pion_candidates\n",
        "\t\t\t# pion_candidates_xy = pion_candidates[:, :, :2]\n",
        "\n",
        "\t\t\t# # Compute squared differences\n",
        "\t\t\t# diff = np.sum((pion_candidates_xy - MIP_list_reshaped)**2, axis=2)\n",
        "\t\t\t# r_max = 35\n",
        "\t\t\t# r_min = 0.5\n",
        "\t\t\t# # Count the number of points within radius r (5 to 40)\n",
        "\t\t\t# non_padded_mask = np.any(pion_candidates[:, :, :2] != 0, axis=2)\n",
        "\t\t\t# within_r_mask = (diff >= r_min**2) & (diff <= r_max**2) & non_padded_mask\n",
        "\n",
        "\t\t\t# count_within_r = np.sum(within_r_mask, axis=1)\n",
        "\n",
        "\t\t\t# print(f\"momentum_list shape {np.array(momentum_list).shape}\")\n",
        "\t\t\t# print(f\"pion_candidates[i] shape {pion_candidates.shape}\")\n",
        "\t\t\t# print(f\"Dtype : {pion_candidates.dtype}\")  # Output will be something like: int64\n",
        "\t\t\t# print(f\"Dtype : {pion_candidates.dtype}\")  # Output will be something like: int64\n",
        "\n",
        "\n",
        "\n",
        "\t\t\t# tGap = 8.0\n",
        "\t\t\t# rW = 1.5\n",
        "\t\t\t# qW = 0.5\n",
        "\t\t\t# L = rW / 2\n",
        "\n",
        "\n",
        "\n",
        "\t\t\t# # Calculate L, dy, dx, X, Y, and dist\n",
        "\t\t\t# L = (rW - L + tGap + qW) * np.tan(thetaP_list)\n",
        "\t\t\t# dy = L * np.sin(phiP_list)\n",
        "\t\t\t# dx = L * np.cos(phiP_list)\n",
        "\t\t\t# X = xRad_list + dx\n",
        "\t\t\t# Y = yRad_list + dy\n",
        "\t\t\t# dist = np.sqrt((xMIP_list - X)**2 + (yMIP_list - Y)**2)\n",
        "\t\t\t# proton_cnt =0\n",
        "\t\t\t# kaon_cnt = 0\n",
        "\t\t\t# pion_cnt = 0\n",
        "\t\t\t# proton_filt_cnt = 0\n",
        "\t\t\t# pion_filt_cnt = 0\n",
        "\t\t\t# kaon_filt_cnt =0\n",
        "\t\t\t# for i in range(len(momentum_list)):\n",
        "\n",
        "\t\t\t# \tabs_pdg = abs(mTrackPdg_list[i])\n",
        "\t\t\t# \t#if abs_pdg  in [0, 1]:\n",
        "\n",
        "\t\t\t# \tif abs_pdg  in [211, 321, 2212]:\n",
        "\n",
        "\t\t\t# \t\t#print(f\"p { momentum_list[i]} pdg {abs_pdg}\")\n",
        "\n",
        "\t\t\t# \t\t# check if exceeds momentum limit for ckov photons\n",
        "\t\t\t# \t\tif threshold_momentum(abs_pdg, momentum_list[i]):\n",
        "\t\t\t# \t\t\tnum_pions = np.count_nonzero(pion_candidates[i])\n",
        "\t\t\t# \t\t\tnum_kaons = np.count_nonzero(kaon_candidates[i])\n",
        "\t\t\t# \t\t\tnum_protons = np.count_nonzero(proton_candidates[i])\n",
        "\n",
        "\t\t\t# \t\t\tif abs_pdg == 211:\n",
        "\t\t\t# \t\t\t\t\tnon_zero_val =  num_pions\n",
        "\t\t\t# \t\t\t\t\tpion_cnt = pion_cnt + 1\n",
        "\n",
        "\t\t\t# \t\t\tif abs_pdg == 321:\n",
        "\t\t\t# \t\t\t\t\tnon_zero_val = num_kaons\n",
        "\t\t\t# \t\t\t\t\tkaon_cnt = kaon_cnt + 1\n",
        "\n",
        "\t\t\t# \t\t\tif abs_pdg == 2212:\n",
        "\t\t\t# \t\t\t\t\tnon_zero_val =  num_protons\n",
        "\t\t\t# \t\t\t\t\tproton_cnt = proton_cnt + 1\n",
        "\n",
        "\n",
        "\t\t\t# \t\t\t#print(f\"abs_pdg {abs_pdg} num_pions {num_pions} num_kaons {num_kaons} num_protons {num_protons}\")\n",
        "\n",
        "\t\t\t# \t\t\t# TODO : do flags on momentum\n",
        "\t\t\t# \t\t\t# penalty on number of photons ?\n",
        "\n",
        "\t\t\t# \t\t\tpion_flag = (num_pions < 6*4) | (~threshold_momentum(211, momentum_list[i]))\n",
        "\t\t\t# \t\t\tkaon_flag = (num_kaons < 5*4) | (~threshold_momentum(321, momentum_list[i]))\n",
        "\t\t\t# \t\t\tproton_flag = (num_protons < 4*4) | (~threshold_momentum(2212, momentum_list[i]))\n",
        "\n",
        "\n",
        "\t\t\t# \t\t\t# Check if any candidate has more than 5 non-zero values\n",
        "\n",
        "\n",
        "\t\t\t# \t\t\t# ef :add more cuts here fx to number of ckov photons in a given phiCer range\n",
        "\t\t\t# \t\t\t#print(f\" Something wrong in reconstruction of Ckov {ckovhough_list[i]}: will be skipped\")\n",
        "\t\t\t# \t\t\tif ckovhough_list[i] > 0:\n",
        "\t\t\t# \t\t\t\tif non_zero_val > 20 and dist[i] < 0.2 :\n",
        "\t\t\t# \t\t\t\t\t\t#print(f\"OK abs_pdg {abs_pdg} num_pions {num_pions} num_kaons {num_kaons} num_protons {num_protons}\")\n",
        "\n",
        "\t\t\t# \t\t\t\t\t\tif abs_pdg == 211:\n",
        "\t\t\t# \t\t\t\t\t\t\t\tpion_filt_cnt = pion_filt_cnt + 1\n",
        "\n",
        "\t\t\t# \t\t\t\t\t\tif abs_pdg == 321:\n",
        "\t\t\t# \t\t\t\t\t\t\t\tkaon_filt_cnt = kaon_filt_cnt + 1\n",
        "\n",
        "\t\t\t# \t\t\t\t\t\tif abs_pdg == 2212:\n",
        "\t\t\t# \t\t\t\t\t\t\t\tproton_filt_cnt = proton_filt_cnt + 1\n",
        "\n",
        "\t\t\t# \t\t\t\t\t\tparticle_info = ParticleDataUtils.ParticleInfo(\n",
        "\t\t\t# \t\t\t\t\t\t\t\tmomentum_list[i], refractiveIndex_list[i], xRad_list[i], yRad_list[i],\n",
        "\t\t\t# \t\t\t\t\t\t\t\txMIP_list[i], yMIP_list[i], thetaP_list[i], phiP_list[i],\n",
        "\t\t\t# \t\t\t\t\t\t\t\tmCluCharge_list[i], mCluSize_list[i], non_candidates[i], pion_candidates[i],\n",
        "\t\t\t# \t\t\t\t\t\t\t\tkaon_candidates[i], proton_candidates[i], mTrackPdg_list[i],\n",
        "\t\t\t# \t\t\t\t\t\t\t\ti, pion_flag, kaon_flag, proton_flag\n",
        "\t\t\t# \t\t\t\t\t\t)\n",
        "\t\t\t# \t\t\t\t\t\tparticle_vector[i] = particle_info\n",
        "\t\t\t# \t\t\t\t\t\tself.particle_vector.append(particle_info)\n",
        "\n",
        "\t\t\t# \t\t\t#else :\n",
        "\t\t\t# \t\t\t\t\t#print(f\"non_zero_val {non_zero_val}\")\n",
        "\n",
        "\t\t\t# \t\t\t#\t\tprint(f\" dist to long {dist[i]}\")\n",
        "\t\t\t# print(f\"proton_cnt {proton_cnt}\")\n",
        "\t\t\t# print(f\"kaon_cnt {kaon_cnt}\")\n",
        "\t\t\t# print(f\"pion_cnt {pion_cnt}\")\n",
        "\n",
        "\t\t\t# print(f\"proton_filt_cnt {proton_filt_cnt}\")\n",
        "\t\t\t# print(f\"kaon_filt_cnt {kaon_filt_cnt}\")\n",
        "\t\t\t# print(f\"pion_filt_cnt {pion_filt_cnt}\")\n",
        "\n",
        "\tdef process_data(self, particle_vector, percentage):\n",
        "\n",
        "\t\t# Calculate the number of particles based on the percentage\n",
        "\t\tnum_particles = int(len(self.particle_vector) * (percentage / 100.0))\n",
        "\t\t# Slice the particle_vector to the desired percentage\n",
        "\t\tparticle_vector = self.particle_vector[:num_particles]\n",
        "\t\treturn particle_vector\n",
        "\n",
        "\tdef create_scalar_scaler(self, feature):\n",
        "\t\ttry:\n",
        "\t\t\t\tif feature in [\"momentum\", \"refractiveIndex\", \"phiP\", \"thetaP\", \"mCluSize\", \"mCluCharge\"]:  # added mCluSize and mCluCharge\n",
        "\t\t\t\t\tvalues = np.array([getattr(info, feature) for info in self.particle_info]).reshape(-1, 1)\n",
        "\t\t\t\t\tif values.size == 0:\n",
        "\t\t\t\t\t\traise ValueError(f\"Empty values array for feature: {feature}\")\n",
        "\t\t\t\t\tscaler = StandardScaler()\n",
        "\t\t\t\t\tscaled_values = scaler.fit_transform(values)\n",
        "\t\t\t\t\tvalues = scaled_values\n",
        "\n",
        "\t\t\t\t\tstats = {\n",
        "\t\t\t\t\t\t\"mean\": scaler.mean_[0],\n",
        "\t\t\t\t\t\t\"std\": scaler.scale_[0]\n",
        "\t\t\t\t\t}\n",
        "\t\t\t\t\treturn scaler, stats\n",
        "\t\t\t\telse:\n",
        "\t\t\t\t\traise ValueError(f\"Invalid feature: {feature}\")\n",
        "\n",
        "\t\texcept Exception as e:\n",
        "\t\t\t\tprint(f\"An error occurred in create_scalar_scaler: {e}\")\n",
        "\t\t\t\traise\n",
        "\n",
        "\n",
        "\n",
        "\tdef create_2D_scaler(self, feature):\n",
        "\t\ttry:\n",
        "\t\t\t\tif feature in [\"mip_position\", \"rad_position\"]:\n",
        "\t\t\t\t\t\tvalues = np.array([getattr(info, feature) for info in self.particle_info])\n",
        "\t\t\t\tif values.size == 0:\n",
        "\t\t\t\t\t\traise ValueError(f\"Empty values array for feature: {feature}\")\n",
        "\n",
        "\t\t\t\tscaler_x = StandardScaler()\n",
        "\t\t\t\tscaler_y = StandardScaler()\n",
        "\n",
        "\n",
        "\n",
        "\t\t\t\tprint(f\"create_2D_scalervalues.shape : {values.shape}\")\n",
        "\n",
        "\t\t\t\tn_samples, dim, r = values.shape\n",
        "\t\t\t\tprint(f\"create_2D_scalervalues.shape : {values[:, 0].shape}\")\n",
        "\n",
        "\t\t\t\tfeature_values_x = values[:, 0].reshape(n_samples, 1)\n",
        "\t\t\t\tscaled_values_x = scaler_x.fit_transform(feature_values_x).reshape(n_samples, 1)\n",
        "\t\t\t\tvalues[:, 0] = scaled_values_x\n",
        "\n",
        "\t\t\t\tfeature_values_y = values[:, 1].reshape(n_samples, 1)\n",
        "\t\t\t\tscaled_values_y = scaler_y.fit_transform(feature_values_y).reshape(n_samples, 1)\n",
        "\t\t\t\tvalues[:, 1] = scaled_values_y\n",
        "\n",
        "\n",
        "\t\t\t\t# Store both the scalers\n",
        "\t\t\t\tscalers = {'x': scaler_x, 'y': scaler_y}\n",
        "\t\t\t\tstats = {\n",
        "\t\t\t\t'x': {\n",
        "\t\t\t\t\"mean\": scaler_x.mean_[0],\n",
        "\t\t\t\t\"std\": scaler_x.scale_[0]\n",
        "\t\t\t\t},\n",
        "\t\t\t\t'y': {\n",
        "\t\t\t\t\t\"mean\": scaler_y.mean_[0],\n",
        "\t\t\t\t\t\"std\": scaler_y.scale_[0]\n",
        "\t\t\t\t\t}\n",
        "\t\t\t\t}\n",
        "\t\t\t\treturn scalers, stats\n",
        "\t\texcept Exception as e:\n",
        "\t\t\tprint(f\"An error occurred in create_2D_scaler: {e}\")\n",
        "\t\t\traise\n",
        "\n",
        "\tdef create_vector_scaler(self, feature):\n",
        "\t\ttry:\n",
        "\t\t\tif feature in [\"pion_candidates\", \"kaon_candidates\", \"proton_candidates\"]:\n",
        "\t\t\t\tvalues = np.array([getattr(info, feature) for info in self.particle_info])\n",
        "\t\t\t\tif values.size == 0:\n",
        "\t\t\t\t\t\traise ValueError(f\"Empty values array for feature: {feature}\")\n",
        "\n",
        "\t\t\t\tn_samples, n_clusters, n_features = values.shape\n",
        "\t\t\t\tscalers = []\n",
        "\n",
        "\t\t\t\tclip_min = -300.0  # Set your desired minimum clipping value\n",
        "\t\t\t\tclip_max = 300.0   # Set your desired maximum clipping value\n",
        "\t\t\t\tvalues = np.clip(values, clip_min, clip_max)\n",
        "\n",
        "\t\t\t\tfor i in range(n_features):\n",
        "\t\t\t\t\tscaler = StandardScaler()\n",
        "\t\t\t\t\tfeature_values = values[:, :, i].reshape(-1, 1)\n",
        "\t\t\t\t\tscaled_values = scaler.fit_transform(feature_values).reshape(n_samples, n_clusters)\n",
        "\t\t\t\t\tvalues[:, :, i] = scaled_values\n",
        "\t\t\t\t\tscalers.append(scaler)\n",
        "\t\t\t\tstats = []\n",
        "\t\t\t\tfor scaler in scalers:\n",
        "\t\t\t\t\tstat = {\n",
        "\t\t\t\t\t\t\"mean\": scaler.mean_[0],\n",
        "\t\t\t\t\t\t\"std\": scaler.scale_[0]\n",
        "\t\t\t\t}\n",
        "\t\t\t\t\tstats.append(stat)\n",
        "\n",
        "\t\t\t\treturn scalers, stats\n",
        "\n",
        "\t\texcept Exception as e:\n",
        "\t\t\tprint(f\"An error occurred in create_vector_scaler: {e}\")\n",
        "\t\t\traise\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 249,
      "metadata": {
        "id": "A_w-le-CYD5_"
      },
      "outputs": [],
      "source": [
        "#import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "from matplotlib.colors import LogNorm\n",
        "from matplotlib.patches import Wedge\n",
        "\n",
        "# Count non-zero charges\n",
        "def count_non_zero_charges(datasets, idx, titles):\n",
        "    non_zero_counts = {}\n",
        "    for data, title in zip(datasets, titles):\n",
        "        non_zero_charges = np.count_nonzero(data[idx, :, 3])\n",
        "        non_zero_counts[title] = non_zero_charges\n",
        "    return non_zero_counts\n",
        "\n",
        "from matplotlib.patches import Rectangle\n",
        "\n",
        "# def add_region(ax, xmin, xmax, color, alpha=0.2):\n",
        "#     ymin, ymax = 0, 130\n",
        "#     rect = Rectangle((xmin, ymin), xmax-xmin, ymax-ymin, color=color, alpha=alpha)\n",
        "#     ax.add_patch(rect)\n",
        "\n",
        "# Plot individual types\n",
        "def plot_individual_types(idx, x_pion, x_kaon, x_proton, x_non, MIP_charge, MIP_position, RAD_position, phi, theta, y_train, log_scale, X_index, regions):\n",
        "    # X_pion_constr_min = regions[\"X_pion_constr_min\"]\n",
        "    # X_pion_constr_max = regions[\"X_pion_constr_max\"]\n",
        "    # X_kaon_constr_min = regions[\"X_kaon_constr_min\"]\n",
        "    # X_kaon_constr_max = regions[\"X_kaon_constr_max\"]\n",
        "    # X_proton_constr_min = regions[\"X_proton_constr_min\"]\n",
        "    # X_proton_constr_max = regions[\"X_proton_constr_max\"]\n",
        "\n",
        "\n",
        "    theta_val = theta[idx]\n",
        "    phi_val = phi[idx]\n",
        "    index_of_fig = X_index[idx]\n",
        "    datasets = [x_pion, x_kaon, x_proton, x_non]\n",
        "    titles = [\"Pion\", \"Kaon\", \"Proton\", \"Non\"]\n",
        "    non_zero_counts = count_non_zero_charges(datasets, idx, titles)\n",
        "\n",
        "    mip_charge = MIP_charge[idx]\n",
        "    max_charge = np.max([np.max(data[idx, :, 3]) for data in datasets])\n",
        "    fig, ax = plt.subplots(2, 2, figsize=(14, 14))\n",
        "    ax = ax.flatten()\n",
        "    xm, ym = MIP_position[idx]\n",
        "    xr, yr = RAD_position[idx]\n",
        "    label_type = y_train[idx]\n",
        "    fig.suptitle(f\"Index: {index_of_fig} - Type : {label_type} phiP: {float(phi_val):.4f}, thetaP: {float(theta_val):.4f} MIP {float(xm):.4f} {float(ym):.4f} RAD {float(xr):.4f} {float(yr):.4f}\", fontsize=16)\n",
        "    cmap = plt.get_cmap('viridis')\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "    if log_scale:\n",
        "        norm = LogNorm(vmin=1, vmax=max_charge)\n",
        "\n",
        "    # Calculate line end points from phi angle\n",
        "    x_end_forward = xm + 50 * np.cos(phi[idx])  # 50 units in the direction of phi\n",
        "    y_end_forward = ym + 50 * np.sin(phi[idx])\n",
        "    x_end_backward = xm - 10 * np.cos(phi[idx])  # 10 units opposite to phi direction\n",
        "    y_end_backward = ym - 10 * np.sin(phi[idx])\n",
        "\n",
        "    for i, (data, title) in enumerate(zip(datasets, titles)):\n",
        "        x = data[idx, :, 0]\n",
        "        y = data[idx, :, 1]\n",
        "        charge = data[idx, :, 3]\n",
        "        # if title == \"Pion\":\n",
        "        #     add_region(ax[i], X_pion_constr_min, X_pion_constr_max, 'lightblue')\n",
        "        # elif title == \"Kaon\":\n",
        "        #     add_region(ax[i], X_kaon_constr_min, X_kaon_constr_max, 'lightgreen')\n",
        "        # elif title == \"Proton\":\n",
        "        #     add_region(ax[i], X_proton_constr_min, X_proton_constr_max, 'lightpink')\n",
        "\n",
        "\n",
        "        if log_scale:\n",
        "            sc = ax[i].scatter(x, y, c=charge, cmap=cmap, norm=norm)\n",
        "            plt.colorbar(sc, ax=ax[i], label='Charge (Log scale)', fraction=0.046, pad=0.04)\n",
        "        else:\n",
        "            sc = ax[i].scatter(x, y, c=charge, cmap=cmap, vmin=0, vmax=max_charge)\n",
        "            plt.colorbar(sc, ax=ax[i], label='Charge', fraction=0.046, pad=0.04)\n",
        "\n",
        "        ax[i].plot([x_end_backward, x_end_forward], [y_end_backward, y_end_forward], 'k-', lw=2)\n",
        "        ax[i].scatter(xm, ym, color='green', marker='x', label='MIP_position')\n",
        "        ax[i].scatter(xr, yr, color='black', marker='o', label='RAD_position')\n",
        "        ax[i].set_title(f\"{title}: {non_zero_counts[title]} non-zero candidates\")\n",
        "        ax[i].set_xlim([0, 130])\n",
        "        ax[i].set_ylim([0, 130])\n",
        "        ax[i].set_aspect('equal', adjustable='box')\n",
        "\n",
        "    plt.tight_layout(rect=[0, 0.03, 1, 0.95])\n",
        "    plt.show()\n",
        "\n",
        "# Draw pie for combined types\n",
        "def draw_pie(ax, x, y, sizes, colors):\n",
        "    total_size = sum(sizes)\n",
        "    start_angle = 90\n",
        "    for size, color in zip(sizes, colors):\n",
        "        wedge = Wedge((x, y), 0.5, start_angle, start_angle + 360 * (size / total_size), color=color)\n",
        "        ax.add_patch(wedge)\n",
        "        start_angle += 360 * (size / total_size)\n",
        "\n",
        "\n",
        "def plot_combined_types(i, x_pion, x_kaon, x_proton, x_non, MIP_position, RAD_position, phiP, thetaP, y_train, X_index, regions):\n",
        "    # X_pion_constr_min = regions[\"X_pion_constr_min\"]\n",
        "    # X_pion_constr_max = regions[\"X_pion_constr_max\"]\n",
        "    # X_kaon_constr_min = regions[\"X_kaon_constr_min\"]\n",
        "    # X_kaon_constr_max = regions[\"X_kaon_constr_max\"]\n",
        "    # X_proton_constr_min = regions[\"X_proton_constr_min\"]\n",
        "    # X_proton_constr_max = regions[\"X_proton_constr_max\"]\n",
        "\n",
        "    index_of_fig = X_index[i]\n",
        "    label_type = y_train[i]\n",
        "    phiP_val = phiP[i]\n",
        "    thetaP_val = thetaP[i]\n",
        "\n",
        "    fig, ax = plt.subplots(1, 3, figsize=(22, 7))\n",
        "    fig.suptitle(f\"Index: {index_of_fig} - Type : {label_type}\", fontsize=16)\n",
        "\n",
        "    xm, ym = MIP_position[i]\n",
        "    xr, yr = RAD_position[i]\n",
        "\n",
        "    x_end_forward = xm + 50 * np.cos(phiP_val)\n",
        "    y_end_forward = ym + 50 * np.sin(phiP_val)\n",
        "    x_end_backward = xm - 10 * np.cos(phiP_val)\n",
        "    y_end_backward = ym - 10 * np.sin(phiP_val)\n",
        "\n",
        "    for x, label, color in zip([x_proton, x_pion, x_kaon, x_non], ['Proton', 'Pion', 'Kaon', 'Non'], ['r', 'g', 'b', 'y']):\n",
        "        x_val = x[i, :, 0]\n",
        "        y_val = x[i, :, 1]\n",
        "        ax[0].scatter(x_val, y_val, c=color, alpha=0.5, label=label)\n",
        "\n",
        "    ax[0].plot([x_end_backward, x_end_forward], [y_end_backward, y_end_forward], 'k-', lw=2)\n",
        "    ax[0].scatter(xm, ym, color='green', marker='x', label='MIP_position')\n",
        "    ax[0].scatter(xr, yr, color='black', marker='o', label='RAD_position')  # added RAD_position as red marker\n",
        "\n",
        "    ax[0].set_title(f\"All Values \\nphiP: {float(phiP_val):.4f}, thetaP: {float(thetaP_val):.4f} MIP {float(xm):.4f} {float(ym):.4f} RAD {float(xr):.4f} {float(yr):.4f}\")\n",
        "\n",
        "\n",
        "    ax[0].set_xlim([0, 130])\n",
        "    ax[0].set_ylim([0, 130])\n",
        "    ax[0].set_aspect('equal', adjustable='box')\n",
        "\n",
        "    charge_cut = 150\n",
        "    for x, label, color in zip([x_proton, x_pion, x_kaon, x_non], ['Proton', 'Pion', 'Kaon', 'Non'], ['r', 'g', 'b', 'y']):\n",
        "        x_val = x[i, :, 0]\n",
        "        y_val = x[i, :, 1]\n",
        "        charge = x[i, :, 3]\n",
        "        size = x[i, :, 2]\n",
        "\n",
        "        mask = (charge > charge_cut) & (size > 2)\n",
        "\n",
        "        ax[1].scatter(x_val[mask], y_val[mask], c=color, alpha=0.5, label=label)\n",
        "\n",
        "    ax[1].scatter(xm, ym, color='green', marker='x', label='MIP_position')\n",
        "    ax[1].scatter(xr, yr, color='black', marker='o', label='RAD_position')  # added RAD_position as red marker\n",
        "    ax[1].set_title(f\"Values with Charge > {charge_cut} and Size > 2 \\nphiP: {float(phiP_val):.2f}, thetaP: {float(thetaP_val):.2f}\")\n",
        "    ax[1].set_xlim([0, 130])\n",
        "    ax[1].set_ylim([0, 130])\n",
        "    ax[1].set_aspect('equal', adjustable='box')\n",
        "\n",
        "    # 3rd subplot - 50x50 window with MIP at the center\n",
        "    for x, label, color in zip([x_proton, x_pion, x_kaon, x_non], ['Proton', 'Pion', 'Kaon', 'Non'], ['r', 'g', 'b', 'y']):\n",
        "        x_val = x[i, :, 0]\n",
        "        y_val = x[i, :, 1]\n",
        "        ax[2].scatter(x_val, y_val, c=color, alpha=0.5, label=label)\n",
        "\n",
        "    ax[2].plot([x_end_backward, x_end_forward], [y_end_backward, y_end_forward], 'k-', lw=2)\n",
        "    ax[2].scatter(xm, ym, color='green', marker='x', label='MIP_position')\n",
        "    ax[2].scatter(xr, yr, color='black', marker='o', label='RAD_position')  # added RAD_position as red marker\n",
        "    ax[2].set_title(f\"50x50 Window with MIP at center\")\n",
        "    ax[2].set_xlim([xm-25, xm+25])\n",
        "    ax[2].set_ylim([ym-25, ym+25])\n",
        "    ax[2].set_aspect('equal', adjustable='box')\n",
        "\n",
        "\n",
        "    # add_region(ax[0], X_pion_constr_min, X_pion_constr_max, 'lightblue')\n",
        "    # add_region(ax[0], X_kaon_constr_min, X_kaon_constr_max, 'lightgreen')\n",
        "    # add_region(ax[0], X_proton_constr_min, X_proton_constr_max, 'lightpink')\n",
        "\n",
        "    # add_region(ax[1], X_pion_constr_min, X_pion_constr_max, 'lightblue')\n",
        "    # add_region(ax[1], X_kaon_constr_min, X_kaon_constr_max, 'lightgreen')\n",
        "    # add_region(ax[1], X_proton_constr_min, X_proton_constr_max, 'lightpink')\n",
        "\n",
        "    # add_region(ax[2], X_pion_constr_min, X_pion_constr_max, 'lightblue')\n",
        "    # add_region(ax[2], X_kaon_constr_min, X_kaon_constr_max, 'lightgreen')\n",
        "    # add_region(ax[2], X_proton_constr_min, X_proton_constr_max, 'lightpink')\n",
        "\n",
        "    plt.legend(loc=\"upper left\")\n",
        "    plt.tight_layout()\n",
        "    plt.show()\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 249,
      "metadata": {
        "id": "bINqoPuTnc_V"
      },
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": 249,
      "metadata": {
        "id": "UW1WR7ULMldT"
      },
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": 249,
      "metadata": {
        "id": "JjgBjhUTMkR2"
      },
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": 250,
      "metadata": {
        "id": "ui9UZvaI8ri6"
      },
      "outputs": [],
      "source": [
        "import matplotlib.pyplot as plt\n",
        "import numpy as np  # Make sure to import numpy\n",
        "import matplotlib.colors as mcolors\n",
        "\n",
        "cmap = mcolors.LinearSegmentedColormap.from_list(\"\", [\"green\", \"red\"])\n",
        "\n",
        "def plot_first_instance(i, X_pion, X_kaon, X_proton, X_non, MIP_charge, MIP_position, RAD_position, phiP, thetaP, y):\n",
        "    mip_charge = MIP_charge[i]\n",
        "    Pions = X_pion[i]\n",
        "    Kaons = X_kaon[i]\n",
        "    X_proton = X_proton[i]\n",
        "    Non = X_non[i]\n",
        "\n",
        "\n",
        "    pdg = y[i] # one hot encoded -- 1 0\n",
        "    if y[i,0] == 1:\n",
        "      type = \"pion\"\n",
        "      XYp = X_pion[i]\n",
        "\n",
        "    elif y[i,1] == 1:\n",
        "      type = \"kaon\"\n",
        "      XYp = X_kaon[i]\n",
        "\n",
        "    else :\n",
        "      type = \"proton\"\n",
        "      XYp = X_proton[i]\n",
        "\n",
        "    # plot istedet hver type segmentert?\n",
        "\n",
        "    phiP_val = phiP[i]\n",
        "    thetaP_val = thetaP[i]\n",
        "\n",
        "\n",
        "\n",
        "    #XYp = X_pion[i]\n",
        "    Xp = XYp[:, 0]  # X-coordinate\n",
        "    Yp = XYp[:, 1]  # Y-coordinate\n",
        "    Charge = XYp[:, 3]  # Charge\n",
        "    Size = XYp[:, 2]  # Size\n",
        "\n",
        "    fig, ax = plt.subplots(1, 3, figsize=(21, 7))\n",
        "    fig.suptitle(f\"{type} - MIP Charge: {mip_charge:.2f}\", fontsize=16)\n",
        "    plt.tight_layout()  # Automatic layout adjustment\n",
        "\n",
        "    # Plot using charge without log scale\n",
        "    sc0 = ax[0].scatter(Xp, Yp, c=Charge, cmap=cmap, label='X_pion')\n",
        "    cbar0 = plt.colorbar(sc0, ax=ax[0], label='Charge', fraction=0.046, pad=0.04)\n",
        "    ax[0].set_title(f\"Charge as Color\\nphiP: {float(phiP_val):.2f}, thetaP: {float(thetaP_val):.2f}\")\n",
        "\n",
        "    # Plot using charge on a log scale for color\n",
        "    sc1 = ax[1].scatter(Xp, Yp, c=np.log1p(Charge), cmap=cmap, label='X_pion')\n",
        "    cbar1 = plt.colorbar(sc1, ax=ax[1], label='Log(Charge)', fraction=0.046, pad=0.04)\n",
        "    ax[1].set_title(f\"Log-Scale Charge as Color\\nphiP: {float(phiP_val):.2f}, thetaP: {float(thetaP_val):.2f}\")\n",
        "\n",
        "    # Plot using Size for color with a linear color map\n",
        "    sc2 = ax[2].scatter(Xp, Yp, c=Size, cmap=cmap, label='X_pion')\n",
        "    cbar2 = plt.colorbar(sc2, ax=ax[2], label='Size', fraction=0.046, pad=0.04)\n",
        "    ax[2].set_title(f\"Size as Color\\nphiP: {float(phiP_val):.2f}, thetaP: {float(thetaP_val):.2f}\")\n",
        "\n",
        "    xm, ym = MIP_position[i]\n",
        "    xr, yr = RAD_position[i]\n",
        "\n",
        "    # Plot MIP_position and RAD_position on all plots\n",
        "    i = 1\n",
        "    for a in ax:\n",
        "        if i == 2:\n",
        "          a.scatter(xm, ym, color='green', marker='x', label='MIP_position')\n",
        "          a.scatter(xr, yr, color='orange', marker='x', label='RAD_position')\n",
        "          a.legend()\n",
        "        i += 1\n",
        "        # Set x and y limits for the plot\n",
        "        a.set_xlim([0, 130])\n",
        "        a.set_ylim([0, 130])\n",
        "\n",
        "        # Set aspect ratio to be equal\n",
        "        a.set_aspect('equal', adjustable='box')\n",
        "\n",
        "    plt.show()\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 251,
      "metadata": {
        "id": "c1GBZlHOMiv4"
      },
      "outputs": [],
      "source": [
        "import numpy as np\n",
        "class CherenkovHypothesisCalculator:\n",
        "    def __init__(self, p, n, n_constraint, k_n):\n",
        "        self.p = p\n",
        "        self.n = n\n",
        "        self.n_constraint = n_constraint\n",
        "        self.k_n = k_n  # number of points to form polygon\n",
        "        self.mass_Pion = 0.1396\n",
        "        self.mass_Kaon = 0.4937\n",
        "        self.mass_Proton = 0.938\n",
        "        self.mass_Pion_sq = self.mass_Pion * self.mass_Pion\n",
        "        self.mass_Kaon_sq = self.mass_Kaon * self.mass_Kaon\n",
        "        self.mass_Proton_sq = self.mass_Proton * self.mass_Proton\n",
        "\n",
        "    def calcCherenkovHyp(self):\n",
        "        len_pion = len(self.p)\n",
        "\n",
        "        std_dev = 0.01\n",
        "\n",
        "        X_pion_min_ckov = np.zeros((len_pion, self.k_n))\n",
        "        X_pion_max_ckov = np.zeros((len_pion, self.k_n))\n",
        "        X_kaon_min_ckov = np.zeros((len_pion, self.k_n))\n",
        "        X_kaon_max_ckov = np.zeros((len_pion, self.k_n))\n",
        "        X_proton_min_ckov = np.zeros((len_pion, self.k_n))\n",
        "        X_proton_max_ckov = np.zeros((len_pion, self.k_n))\n",
        "\n",
        "        n_min = self.n - self.n_constraint\n",
        "        n_max = self.n + self.n_constraint\n",
        "\n",
        "        p_sq = self.p * self.p\n",
        "\n",
        "        # Calculations for min_ckov using n_min\n",
        "        cos_ckov_denom_min = self.p * n_min\n",
        "        cos_ckov_Pion_min = np.sqrt(p_sq + self.mass_Pion_sq) / cos_ckov_denom_min - std_dev\n",
        "        cos_ckov_Kaon_min = np.sqrt(p_sq + self.mass_Kaon_sq) / cos_ckov_denom_min - std_dev\n",
        "        cos_ckov_Proton_min = np.sqrt(p_sq + self.mass_Proton_sq) / cos_ckov_denom_min - std_dev\n",
        "\n",
        "\n",
        "\n",
        "        # Calculations for max_ckov using n_max\n",
        "        cos_ckov_denom_max = self.p * n_max\n",
        "        cos_ckov_Pion_max = np.sqrt(p_sq + self.mass_Pion_sq) / cos_ckov_denom_max + std_dev\n",
        "        cos_ckov_Kaon_max = np.sqrt(p_sq + self.mass_Kaon_sq) / cos_ckov_denom_max + std_dev\n",
        "        cos_ckov_Proton_max = np.sqrt(p_sq + self.mass_Proton_sq) / cos_ckov_denom_max + std_dev\n",
        "\n",
        "        X_pion_min_ckov[:, :] = np.arccos(cos_ckov_Pion_min).reshape(-1, 1)\n",
        "        X_kaon_min_ckov[:, :] = np.arccos(cos_ckov_Kaon_min).reshape(-1, 1)\n",
        "\n",
        "        X_pion_max_ckov[:, :] = np.arccos(cos_ckov_Pion_max).reshape(-1, 1)\n",
        "        X_kaon_max_ckov[:, :] = np.arccos(cos_ckov_Kaon_max).reshape(-1, 1)\n",
        "\n",
        "        X_proton_max_ckov[:, :] = np.arccos(cos_ckov_Proton_max).reshape(-1, 1)\n",
        "        X_proton_min_ckov[:, :] = np.arccos(cos_ckov_Proton_min).reshape(-1,1)\n",
        "\n",
        "        print(f\"Pion Min {np.mean(X_pion_min_ckov[:, 0]):.3f} Max {np.mean(X_pion_max_ckov[:, 0]):.3f}\")\n",
        "        print(f\"Kaon Min {np.mean(X_kaon_min_ckov[:, 0]):.3f} Max {np.mean(X_kaon_max_ckov[:, 0]):.3f}\")\n",
        "        print(f\"Proton Min {np.mean(X_proton_min_ckov[:, 0]):.3f} Max {np.mean(X_proton_max_ckov[:, 0]):.3f}\")\n",
        "\n",
        "        return X_pion_min_ckov, X_pion_max_ckov, X_kaon_min_ckov, X_kaon_max_ckov, X_proton_min_ckov, X_proton_max_ckov\n",
        "\n",
        "\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 251,
      "metadata": {
        "id": "Y9ZOOuC_Dhay"
      },
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": 251,
      "metadata": {
        "id": "pcY6LVGpxZQI"
      },
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": 251,
      "metadata": {
        "id": "VRoviFHFMvUa"
      },
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "oXEUp3H8NoS_"
      },
      "source": [
        "# Helping class and imports\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 252,
      "metadata": {
        "id": "es3UneK1Nmof",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "27ad52a5-e136-43a4-d722-f969c080cb82"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "1000\n"
          ]
        }
      ],
      "source": [
        "#resolution = 4\n",
        "\n",
        "from sklearn.metrics import precision_recall_curve\n",
        "from sklearn.preprocessing import label_binarize\n",
        "import matplotlib.pyplot as plt\n",
        "from itertools import cycle\n",
        "\n",
        "import sys\n",
        "\n",
        "print(sys.getrecursionlimit()) # Prints 1000\n",
        "\n",
        "print_vals = False\n",
        "from numpy.linalg import norm\n",
        "from tensorflow.keras.backend import expand_dims\n",
        "from tensorflow.keras.preprocessing.sequence import pad_sequences\n",
        "from sklearn.metrics import precision_recall_curve, confusion_matrix\n",
        "\n",
        "from scipy.signal import find_peaks\n",
        "\n",
        "from __future__ import print_function\n",
        "import os\n",
        "import h5py\n",
        "import numpy as np\n",
        "import tensorflow as tf\n",
        "from tensorflow.keras.models import Model\n",
        "from tensorflow.keras.layers import Activation, Input, Conv2D, Lambda, Flatten, Dense, concatenate, BatchNormalization, MaxPooling2D, Dropout, LeakyReLU, Masking, Embedding\n",
        "\n",
        "from sklearn.model_selection import train_test_split\n",
        "from sklearn.preprocessing import StandardScaler, LabelBinarizer\n",
        "import matplotlib.pyplot as plt\n",
        "from tensorflow.keras import regularizers\n",
        "\n",
        "from sklearn.metrics import precision_recall_curve\n",
        "from sklearn.metrics import f1_score\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "\n",
        "from tensorflow.keras.callbacks import EarlyStopping"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 253,
      "metadata": {
        "id": "TVLkss66iBW5"
      },
      "outputs": [],
      "source": [
        "from tensorflow.keras.losses import categorical_crossentropy\n",
        "\n",
        "def custom_loss(y_true, y_pred):\n",
        "    base_loss = categorical_crossentropy(y_true, y_pred)\n",
        "    print(\"y_true shape:\", y_true.shape)\n",
        "    print(\"y_pred shape:\", y_pred.shape)\n",
        "    # Assuming the order of classes in y_pred is pion, kaon, and proton.\n",
        "\n",
        "    # Extract flags from y_true (assuming they are appended after the original one-hot encoded labels)\n",
        "    pion_flag = y_true[:, 3]\n",
        "    kaon_flag = y_true[:, 4]\n",
        "    proton_flag = y_true[:, 5]\n",
        "\n",
        "    # Calculate the penalty for each class.\n",
        "    # The penalty increases when the predicted probability for a class is high and the flag for that class is set.\n",
        "    pion_penalty = pion_flag * y_pred[:, 0]\n",
        "    kaon_penalty = kaon_flag * y_pred[:, 1]\n",
        "    proton_penalty = proton_flag * y_pred[:, 2]\n",
        "\n",
        "    total_penalty = pion_penalty + kaon_penalty + proton_penalty\n",
        "\n",
        "    # Add the penalties to the base loss.\n",
        "    return base_loss + total_penalty\n",
        "#\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "pN8kSaAzUDxj"
      },
      "source": []
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "8U_5qogtNs15"
      },
      "source": [
        "# Model"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 254,
      "metadata": {
        "id": "IjrxNzz0LMqU"
      },
      "outputs": [],
      "source": [
        "\n",
        "class MassClassifier:\n",
        "  def __init__(self, percentage_to_read = 10, resolution = 4):\n",
        "      self.model = None\n",
        "      self.utils = None\n",
        "      self.percentage_to_read = percentage_to_read\n",
        "      self.resolution = resolution\n",
        "      self.particle_vector = None\n",
        "\n",
        "\n",
        "  def load_data(self, filenames):\n",
        "\n",
        "      print(f\"MassClassifier __ load_data\")\n",
        "\n",
        "      self.utils = ParticleDataUtils(filenames, percentage_to_read = self.percentage_to_read) # specify percentage of particles to read..\n",
        "      # when init on ParticleDataUtils is called, it calls its member function function         self.particle_vector = self.load_data(filename)\n",
        "      if  self.particle_vector is None :\n",
        "        print(f\"self.particle_vector is None\")\n",
        "\n",
        "        self.particle_vector = self.utils.particle_vector\n",
        "\n",
        "        np.random.shuffle( self.particle_vector)\n",
        "\n",
        "      else :\n",
        "        print(f\"self.particle_vector is not None\")\n",
        "        self.particle_vector.extend(self.utils.particle_vector)\n",
        "\n",
        "      y = np.array([info.particleType  for info in self.particle_vector])\n",
        "      pion_candidates_list =[info.pion_candidates for info in self.particle_vector]\n",
        "      kaon_candidates_list = ([info.kaon_candidates for info in self.particle_vector])\n",
        "      proton_candidates_list = ([info.proton_candidates for info in self.particle_vector])\n",
        "      proton_candidates_list = ([info.proton_candidates for info in self.particle_vector])\n",
        "\n",
        "      for info in self.particle_vector:\n",
        "        n_pion = np.count_nonzero(info.pion_candidates)/4\n",
        "        n_kaon = np.count_nonzero(info.kaon_candidates)/4\n",
        "        n_proton = np.count_nonzero(info.proton_candidates)/4\n",
        "        type_p = info.particleType\n",
        "\n",
        "        #print(f\" type_p: {type_p} n_pion: {n_pion} n_kaon: {n_kaon} n_proton: {n_proton}\")\n",
        "\n",
        "\n",
        "      print(f\"Number of particles: {len(self.particle_vector)}\")\n",
        "\n",
        "  def preprocess_data(self, k_n):\n",
        "      particle_info = self.utils.particle_info\n",
        "      particle_info = self.particle_vector\n",
        "      # random.shuffle(particle_info)\n",
        "      np.random.shuffle(particle_info)\n",
        "\n",
        "      from tensorflow.keras.preprocessing.sequence import pad_sequences\n",
        "\n",
        "      # Convert pion_candidates, kaon_candidates, proton_candidates to lists\n",
        "      pion_candidates_list =[info.pion_candidates for info in particle_info]\n",
        "      kaon_candidates_list = ([info.kaon_candidates for info in particle_info])\n",
        "      proton_candidates_list = ([info.proton_candidates for info in particle_info])\n",
        "      non_candidates_list = ([info.non_candidates for info in particle_info])\n",
        "\n",
        "\n",
        "      def find_min_max_replace_nan(my_list):\n",
        "          # Convert list to numpy array for easier NaN handling\n",
        "          arr = np.array(my_list)\n",
        "\n",
        "          # Find min and max while ignoring NaNs\n",
        "          min_val = np.nanmin(arr)\n",
        "          max_val = np.nanmax(arr)\n",
        "\n",
        "          # Print min and max values\n",
        "          print(f\"Min Value: {min_val} Max Value: {max_val}\")\n",
        "\n",
        "          # Replace NaNs with 0\n",
        "          arr[np.isnan(arr)] = 0\n",
        "\n",
        "\n",
        "          for i in  range(4):\n",
        "\n",
        "\n",
        "            min_val = np.nanmin(arr[:,:,i])\n",
        "            max_val = np.nanmax(arr[:,:,i])\n",
        "\n",
        "            # Print min and max values\n",
        "            print(f\"Min Value: {min_val} Max Value: {max_val} i {i}\")\n",
        "\n",
        "          return arr.tolist()\n",
        "\n",
        "\n",
        "      print(\"pion_Cndidates : \")\n",
        "      pion_candidates_list = find_min_max_replace_nan(pion_candidates_list)\n",
        "\n",
        "      print(\"kaon_Cndidates : \")\n",
        "\n",
        "      kaon_candidates_list = find_min_max_replace_nan(kaon_candidates_list)\n",
        "\n",
        "      print(\"proton_Cndidates : \")\n",
        "\n",
        "      proton_candidates_list = find_min_max_replace_nan(proton_candidates_list)\n",
        "\n",
        "      print(\"non_Cndidates : \")\n",
        "\n",
        "      non_candidates_list = find_min_max_replace_nan(non_candidates_list)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "      #plot_function(X_train_pion_candidates, X_train_kaon_candidates, X_train_proton_candidates, X_train_mip_position, X_train_rad_position, X_train_phi, X_train_theta)\n",
        "      print(\"Fields in the first vector of X_train:\")\n",
        "      print(\"pion_candidates_list shape:\",  np.array(pion_candidates_list).shape)\n",
        "      print(\"kaon_candidates_list shape:\",  np.array(kaon_candidates_list).shape)\n",
        "      print(\"proton_candidates_list shape:\",  np.array(proton_candidates_list).shape)\n",
        "\n",
        "\n",
        "      # Pad the lists to the longest vector per dimension\n",
        "      X_pion_candidates =  np.array(pion_candidates_list).astype(np.float32)#pad_sequences(pion_candidates_list, padding='post')\n",
        "      X_kaon_candidates =  np.array(kaon_candidates_list).astype(np.float32)#pad_sequences(kaon_candidates_list, padding='post')\n",
        "      X_proton_candidates = np.array(proton_candidates_list).astype(np.float32)# pad_sequences(proton_candidates_list, padding='post')\n",
        "      X_non_candidates = np.array(non_candidates_list).astype(np.float32)# pad_sequences(proton_candidates_list, padding='post')\n",
        "\n",
        "\n",
        "\n",
        "      print(f\"PADDED \\n:\")\n",
        "      print(\"X_pion_candidates shape:\", X_pion_candidates.shape)\n",
        "      print(\"X_kaon_candidates shape:\", X_kaon_candidates.shape)\n",
        "      print(\"X_proton_candidates shape:\", X_proton_candidates.shape)\n",
        "\n",
        "\n",
        "      print(\"NaN in X_pion_candidates:\", np.isnan(X_pion_candidates).any())\n",
        "      print(\"NaN in X_kaon_candidates:\", np.isnan(X_kaon_candidates).any())\n",
        "      print(\"NaN in X_proton_candidates:\", np.isnan(X_proton_candidates).any())\n",
        "      print(\"NaN in X_non_candidates:\", np.isnan(X_non_candidates).any())\n",
        "\n",
        "\n",
        "      # scalars\n",
        "      X_momentum = np.array([info.momentum for info in particle_info])#.reshape(-1, 32, 32, 1)\n",
        "      X_refractive_index = np.array([info.refractiveIndex for info in particle_info])#.reshape(-1, 32, 32, 1)\n",
        "\n",
        "      print(\"NaN in X_refractive_index:\", np.isnan(X_refractive_index).any())\n",
        "      print(\"NaN in X_momentum:\", np.isnan(X_momentum).any())\n",
        "\n",
        "      # this should not be included? :\n",
        "      print(f\"PADDED \\n:\")\n",
        "\n",
        "      X_phi = np.array([particle.phiP for particle in particle_info])      #\n",
        "      X_theta = np.array([particle.thetaP for particle in particle_info])  #\n",
        "\n",
        "      X_phi = np.array([particle.phiP for particle in particle_info])      #\n",
        "      X_theta = np.array([particle.thetaP for particle in particle_info])  #\n",
        "\n",
        "\n",
        "\n",
        "      X_index_particle = np.array([particle.index_particle for particle in particle_info])  # new\n",
        "\n",
        "      X_pion_flag = np.array([particle.pion_flag for particle in particle_info])  # new\n",
        "      X_kaon_flag = np.array([particle.kaon_flag for particle in particle_info])  # new\n",
        "      X_proton_flag = np.array([particle.proton_flag for particle in particle_info])  # new\n",
        "\n",
        "\n",
        "      # x,y pairs (2,1) :\n",
        "      X_mip_position = np.array([info.mip_position for info in particle_info]) # was already\n",
        "      X_rad_position = np.array([info.rad_position for info in particle_info]) # new\n",
        "\n",
        "      X_mCluCharge = np.array([info.mCluCharge for info in particle_info]) # was already\n",
        "      X_mCluSize = np.array([info.mCluSize for info in particle_info]) # new\n",
        "\n",
        "      print(np.asarray(X_proton_candidates, dtype=object).shape)\n",
        "\n",
        "      len_proton = np.asarray(X_proton_candidates, dtype = object).shape[1]\n",
        "\n",
        "\n",
        "\n",
        "      print(\"NaN in X_index_particle:\", np.isnan(X_index_particle).any())\n",
        "      print(\"NaN in X_mip_position:\", np.isnan(X_mip_position).any())\n",
        "      print(\"NaN in X_rad_positiX_phion:\", np.isnan(X_phi).any())\n",
        "      print(\"NaN in X_theta:\", np.isnan(X_theta).any())\n",
        "\n",
        "\n",
        "      # Prepare the outputs\n",
        "      y = np.array([info.particleType  for info in particle_info])\n",
        "      y_cp = np.array([info.particleType  for info in particle_info])\n",
        "      print(f\"y_cp {y_cp[:10]}\")\n",
        "\n",
        "      # if pdg == 211 -- pion 321 kaon 2212 proton else \"other\"\n",
        "      #lb = LabelBinarizer()\n",
        "      #lb.classes_ = np.array(['pion', 'kaon', 'proton'])\n",
        "      #y_one_hot = lb.transform(y)\n",
        "\n",
        "\n",
        "      from sklearn.preprocessing import OneHotEncoder\n",
        "\n",
        "      encoder = OneHotEncoder(sparse=False)\n",
        "      y = encoder.fit_transform(y.reshape(-1, 1))\n",
        "\n",
        "      # Split the data into train and test sets\n",
        "      map_size = nb_size = 50\n",
        "\n",
        "      # ef :TODO fix this back again\n",
        "      X_map_pion = extract_neighborhood_map(candidate_positions = X_pion_candidates, mip_positions = X_mip_position, neighborhood_size = nb_size, map_size = map_size)\n",
        "      X_map_kaon =extract_neighborhood_map(candidate_positions = X_kaon_candidates, mip_positions = X_mip_position, neighborhood_size = nb_size, map_size = map_size)\n",
        "      X_map_proton =extract_neighborhood_map(candidate_positions = X_proton_candidates, mip_positions = X_mip_position, neighborhood_size = nb_size, map_size = map_size)\n",
        "\n",
        "\n",
        "      print(\"X_map_pion shape:\", X_map_pion.shape)\n",
        "      print(\"X_map_kaon shape:\", X_map_kaon.shape)\n",
        "      print(\"y shape: \", y.shape)\n",
        "      print(\"y_cp shape: \", y_cp.shape)\n",
        "\n",
        "      #for i in range(100):\n",
        "      #    #print(f\"Pair {i+1}:\")\n",
        "      #    #print(f\"y: {y[i]}\")\n",
        "      #    #print(f\"y_cp: {y_cp[i]}\\n\")\n",
        "      print(\"NaN in X_map_pion:\", np.isnan(X_map_pion).any())\n",
        "      print(\"NaN in X_map_kaon:\", np.isnan(X_map_kaon).any())\n",
        "      print(\"NaN in X_map_proton:\", np.isnan(X_map_proton).any())\n",
        "\n",
        "      print(\"NaN in y:\", np.isnan(y).any())\n",
        "      print(\"NaN in y_cp:\", np.isnan(y_cp).any())\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "      TEST_SIZE = 0.4\n",
        "      X_train_mCluCharge, X_test_mCluCharge = train_test_split(X_mCluCharge, test_size=TEST_SIZE, random_state=27, shuffle=True)\n",
        "      X_train_mCluSize, X_test_mCluSize = train_test_split(X_mCluSize, test_size=TEST_SIZE, random_state=27, shuffle=True)\n",
        "      X_train_pion_candidates, X_test_pion_candidates = train_test_split(X_pion_candidates, test_size=TEST_SIZE, random_state=27, shuffle=True)\n",
        "      X_train_kaon_candidates, X_test_kaon_candidates = train_test_split(X_kaon_candidates, test_size=TEST_SIZE, random_state=27, shuffle=True)\n",
        "      X_train_proton_candidates, X_test_proton_candidates = train_test_split(X_proton_candidates, test_size=TEST_SIZE, random_state=27, shuffle=True)\n",
        "      X_train_non_candidates, X_test_non_candidates = train_test_split(X_non_candidates, test_size=TEST_SIZE, random_state=27, shuffle=True)\n",
        "      X_train_momentum, X_test_momentum = train_test_split(X_momentum, test_size=TEST_SIZE, random_state=27, shuffle=True)\n",
        "      X_train_refractive_index, X_test_refractive_index = train_test_split(X_refractive_index, test_size=TEST_SIZE, random_state=27, shuffle=True)\n",
        "      X_train_phi, X_test_phi = train_test_split(X_phi, test_size=TEST_SIZE, random_state=27, shuffle=True)\n",
        "      X_train_theta, X_test_theta = train_test_split(X_theta, test_size=TEST_SIZE, random_state=27, shuffle=True)\n",
        "      X_train_mip_position, X_test_mip_position = train_test_split(X_mip_position, test_size=TEST_SIZE, random_state=27, shuffle=True)\n",
        "      X_train_rad_position, X_test_rad_position = train_test_split(X_rad_position, test_size=TEST_SIZE, random_state=27, shuffle=True)\n",
        "      X_train_map_pion, X_test_map_pion = train_test_split(X_map_pion, test_size=TEST_SIZE, random_state=27, shuffle=True)\n",
        "      X_train_map_kaon, X_test_map_kaon = train_test_split(X_map_kaon, test_size=TEST_SIZE, random_state=27, shuffle=True)\n",
        "      X_train_map_proton, X_test_map_proton = train_test_split(X_map_proton, test_size=TEST_SIZE, random_state=27, shuffle=True)\n",
        "      X_train_pion_flag, X_test_pion_flag = train_test_split(X_pion_flag, test_size=TEST_SIZE, random_state=27, shuffle=True)\n",
        "      X_train_kaon_flag, X_test_kaon_flag = train_test_split(X_kaon_flag, test_size=TEST_SIZE, random_state=27, shuffle=True)\n",
        "      X_train_proton_flag, X_test_proton_flag = train_test_split(X_proton_flag, test_size=TEST_SIZE, random_state=27, shuffle=True)\n",
        "      X_train_index_particle, X_test_index_particle = train_test_split(X_index_particle, test_size=TEST_SIZE, random_state=27, shuffle=True)\n",
        "      y_train, y_test = train_test_split(y, test_size=TEST_SIZE, random_state=27, shuffle=True)\n",
        "\n",
        "\n",
        "      #X_pion_candidates, X_pion_constr_min, X_pion_constr_max, X_kaon_candidates, X_kaon_constr_min,\\\n",
        "      #X_kaon_constr_max, X_proton_candidates, X_proton_constr_min, X_proton_constr_max = segmenter.do_segment()\n",
        "\n",
        "      datasets = {\n",
        "          'mCluCharge': X_mCluCharge,\n",
        "          'mCluSize': X_mCluSize,\n",
        "          'pion_candidates': X_pion_candidates,\n",
        "          'kaon_candidates': X_kaon_candidates,\n",
        "          'proton_candidates': X_proton_candidates,\n",
        "          'non_candidates': X_non_candidates,\n",
        "          'momentum': X_momentum,\n",
        "          'refractive_index': X_refractive_index,\n",
        "          'phi': X_phi,\n",
        "          'theta': X_theta,\n",
        "          'mip_position': X_mip_position,\n",
        "          'rad_position': X_rad_position,\n",
        "          'map_pion': X_map_pion,\n",
        "          'map_kaon': X_map_kaon,\n",
        "          'map_proton': X_map_proton,\n",
        "          'pion_flag': X_pion_flag,\n",
        "          'kaon_flag': X_kaon_flag,\n",
        "          'proton_flag': X_proton_flag,\n",
        "          'index_particle': X_index_particle,\n",
        "          'y_cp': y_cp\n",
        "      }\n",
        "\n",
        "\n",
        "      regions = 2\n",
        "\n",
        "      # add them to all the dictionaries :\n",
        "      import copy\n",
        "      X_train = {\n",
        "        \"X_train_index_particle\": X_train_index_particle,\n",
        "          \"X_train_momentum\": X_train_momentum,\n",
        "          \"X_train_refractive_index\": X_train_refractive_index,\n",
        "          \"X_train_phi\": X_train_phi,\n",
        "          \"X_train_theta\": X_train_theta,\n",
        "          \"X_train_mip_position\": X_train_mip_position,\n",
        "          \"X_train_rad_position\": X_train_rad_position,\n",
        "          \"X_train_pion_candidates\": X_train_pion_candidates,\n",
        "          \"X_train_kaon_candidates\": X_train_kaon_candidates,\n",
        "          \"X_train_proton_candidates\": X_train_proton_candidates,\n",
        "          \"X_train_non_candidates\": X_train_non_candidates,\n",
        "          \"X_train_map_pion\": X_train_map_pion,\n",
        "          \"X_train_map_kaon\": X_train_map_kaon,\n",
        "          \"X_train_map_proton\": X_train_map_proton,\n",
        "          \"X_train_mCluCharge\": X_train_mCluCharge,  # New addition\n",
        "          \"X_train_mCluSize\": X_train_mCluSize       # New addition\n",
        "      }\n",
        "\n",
        "      X_test = {\n",
        "          \"X_test_index_particle\": X_test_index_particle,\n",
        "          \"X_test_momentum\": X_test_momentum,\n",
        "          \"X_test_refractive_index\": X_test_refractive_index,\n",
        "          \"X_test_phi\": X_test_phi,\n",
        "          \"X_test_theta\": X_test_theta,\n",
        "          \"X_test_mip_position\": X_test_mip_position,\n",
        "          \"X_test_rad_position\": X_test_rad_position,\n",
        "          \"X_test_pion_candidates\": X_test_pion_candidates,\n",
        "          \"X_test_kaon_candidates\": X_test_kaon_candidates,\n",
        "          \"X_test_proton_candidates\": X_test_proton_candidates,\n",
        "          \"X_test_non_candidates\" : X_test_non_candidates,\n",
        "          \"X_test_map_pion\": X_test_map_pion,\n",
        "          \"X_test_map_kaon\": X_test_map_kaon,\n",
        "          \"X_test_map_proton\": X_test_map_proton,\n",
        "          \"X_test_mCluCharge\": X_test_mCluCharge,  # New addition\n",
        "          \"X_test_mCluSize\": X_test_mCluSize        # New addition\n",
        "      }\n",
        "      X_train[\"X_train_pion_flag\"] = X_train_pion_flag\n",
        "      X_train[\"X_train_kaon_flag\"] = X_train_kaon_flag\n",
        "      X_train[\"X_train_proton_flag\"] = X_train_proton_flag\n",
        "\n",
        "      X_test[\"X_test_pion_flag\"] = X_test_pion_flag\n",
        "      X_test[\"X_test_kaon_flag\"] = X_test_kaon_flag\n",
        "      X_test[\"X_test_proton_flag\"] = X_test_proton_flag\n",
        "\n",
        "      X_train_unscaled = copy.deepcopy(X_train)\n",
        "      X_test_unscaled = copy.deepcopy(X_test)\n",
        "\n",
        "      def log_scaler_pion_size(X):\n",
        "          return np.log1p(X)  # log(x + 1)\n",
        "\n",
        "      def log_scaler_pion_charge(X):\n",
        "          return np.log(X + 1e-5)  # log(x + small constant)\n",
        "      from sklearn.preprocessing import FunctionTransformer, MinMaxScaler, StandardScaler, RobustScaler\n",
        "\n",
        "      log_transformer_pion_size = FunctionTransformer(func=np.vectorize(log_scaler_pion_size), validate=True)\n",
        "      log_transformer_pion_charge = FunctionTransformer(func=np.vectorize(log_scaler_pion_charge), validate=True)\n",
        "\n",
        "      min_scaler = MinMaxScaler()\n",
        "      std_scaler = StandardScaler()\n",
        "      robust_scaler = RobustScaler()\n",
        "\n",
        "      n_features = 4\n",
        "\n",
        "      for i in range(n_features):\n",
        "          if i < 2:\n",
        "              scaler = min_scaler\n",
        "          elif i == 2:  # size: peak around 2-- exp decr\n",
        "              scaler = log_transformer_pion_size\n",
        "          else:  # charge ; peak at 0 decr exp\n",
        "              scaler = log_transformer_pion_charge\n",
        "\n",
        "          X_train_pion_candidates[:, :, i] = scaler.fit_transform(X_train_pion_candidates[:, :, i])\n",
        "          X_test_pion_candidates[:, :, i] =scaler.transform(X_test_pion_candidates[:, :, i])\n",
        "          X_train_kaon_candidates[:, :, i] = scaler.fit_transform(X_train_kaon_candidates[:, :, i])\n",
        "          X_test_kaon_candidates[:, :, i] = scaler.transform(X_test_kaon_candidates[:, :, i])\n",
        "          X_train_proton_candidates[:, :, i] = scaler.fit_transform(X_train_proton_candidates[:, :, i])\n",
        "          X_test_proton_candidates[:, :, i] =scaler.transform(X_test_proton_candidates[:, :, i])\n",
        "\n",
        "\n",
        "          X_train_non_candidates[:, :, i] = scaler.fit_transform(X_train_non_candidates[:, :, i])\n",
        "          X_test_non_candidates[:, :, i] =scaler.transform(X_test_non_candidates[:, :, i])\n",
        "\n",
        "      # print(X_train_rad_position.shape)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "      X_train_rad_position[:, 0] = min_scaler.fit_transform(X_train_rad_position[:, 0])\n",
        "      X_train_rad_position[:, 1] = min_scaler.fit_transform(X_train_rad_position[:, 1])\n",
        "\n",
        "      X_test_rad_position[:, 0] = min_scaler.transform(X_test_rad_position[:, 0])\n",
        "      X_test_rad_position[:, 1] = min_scaler.transform(X_test_rad_position[:, 1])\n",
        "\n",
        "      X_train_mip_position[:, 0] = min_scaler.fit_transform(X_train_mip_position[:, 0])\n",
        "      X_train_mip_position[:, 1] = min_scaler.fit_transform(X_train_mip_position[:, 1])\n",
        "\n",
        "      X_test_mip_position[:, 0] = min_scaler.transform(X_test_mip_position[:, 0])\n",
        "      X_test_mip_position[:, 1] = min_scaler.transform(X_test_mip_position[:, 1])\n",
        "\n",
        "      X_train_momentum = robust_scaler.fit_transform(X_train_momentum.reshape(-1, 1)).flatten()\n",
        "      X_test_momentum = robust_scaler.transform(X_test_momentum.reshape(-1, 1)).flatten()\n",
        "\n",
        "      # For phi\n",
        "      X_train_phi = robust_scaler.fit_transform(X_train_phi.reshape(-1, 1)).flatten()\n",
        "      X_test_phi = robust_scaler.transform(X_test_phi.reshape(-1, 1)).flatten()\n",
        "\n",
        "      # For theta\n",
        "      X_train_theta = robust_scaler.fit_transform(X_train_theta.reshape(-1, 1)).flatten()\n",
        "      X_test_theta = robust_scaler.transform(X_test_theta.reshape(-1, 1)).flatten()\n",
        "\n",
        "      # For refractive index\n",
        "      X_train_refractive_index = self.utils.refractive_index_scaler.fit_transform(X_train_refractive_index.reshape(-1, 1)).flatten()\n",
        "      X_test_refractive_index = self.utils.refractive_index_scaler.transform(X_test_refractive_index.reshape(-1, 1)).flatten()\n",
        "\n",
        "      # For mCluCharge\n",
        "      X_train_mCluCharge =robust_scaler.fit_transform(X_train_mCluCharge.reshape(-1, 1)).flatten()  # Assumes you've created mCluCharge_scaler\n",
        "      X_test_mCluCharge = robust_scaler.transform(X_test_mCluCharge.reshape(-1, 1)).flatten()\n",
        "\n",
        "      # For mCluSize\n",
        "      X_train_mCluSize = robust_scaler.fit_transform(X_train_mCluSize.reshape(-1, 1)).flatten()  # Assumes you've created mCluSize_scaler\n",
        "      X_test_mCluSize = robust_scaler.transform(X_test_mCluSize.reshape(-1, 1)).flatten()\n",
        "\n",
        "\n",
        "      # aldos to thse dicts\n",
        "      X_train = {\n",
        "          \"X_train_index_particle\": X_train_index_particle,\n",
        "          \"X_train_momentum\": X_train_momentum,\n",
        "          \"X_train_refractive_index\": X_train_refractive_index,\n",
        "          \"X_train_phi\": X_train_phi,\n",
        "          \"X_train_theta\": X_train_theta,\n",
        "          \"X_train_mip_position\": X_train_mip_position,\n",
        "          \"X_train_rad_position\": X_train_rad_position,\n",
        "          \"X_train_pion_candidates\": X_train_pion_candidates,\n",
        "          \"X_train_kaon_candidates\": X_train_kaon_candidates,\n",
        "          \"X_train_proton_candidates\": X_train_proton_candidates,\n",
        "          \"X_train_non_candidates\" : X_train_non_candidates,\n",
        "          \"X_train_map_pion\": X_train_map_pion,\n",
        "          \"X_train_map_kaon\": X_train_map_kaon,\n",
        "          \"X_train_map_proton\": X_train_map_proton,\n",
        "          \"X_train_mCluCharge\": X_train_mCluCharge,  # New addition\n",
        "          \"X_train_mCluSize\": X_train_mCluSize       # New addition\n",
        "      }\n",
        "\n",
        "      X_test = {\n",
        "          \"X_test_index_particle\": X_test_index_particle,\n",
        "          \"X_test_momentum\": X_test_momentum,\n",
        "          \"X_test_refractive_index\": X_test_refractive_index,\n",
        "          \"X_test_phi\": X_test_phi,\n",
        "          \"X_test_theta\": X_test_theta,\n",
        "          \"X_test_mip_position\": X_test_mip_position,\n",
        "          \"X_test_rad_position\": X_test_rad_position,\n",
        "          \"X_test_pion_candidates\": X_test_pion_candidates,\n",
        "          \"X_test_kaon_candidates\": X_test_kaon_candidates,\n",
        "          \"X_test_proton_candidates\": X_test_proton_candidates,\n",
        "          \"X_test_non_candidates\" : X_test_non_candidates,\n",
        "          \"X_test_map_pion\": X_test_map_pion,\n",
        "          \"X_test_map_kaon\": X_test_map_kaon,\n",
        "          \"X_test_map_proton\": X_test_map_proton,\n",
        "          \"X_test_mCluCharge\": X_test_mCluCharge,  # New addition\n",
        "          \"X_test_mCluSize\": X_test_mCluSize        # New addition\n",
        "      }\n",
        "      X_train[\"X_train_pion_flag\"] = X_train_pion_flag\n",
        "      X_train[\"X_train_kaon_flag\"] = X_train_kaon_flag\n",
        "      X_train[\"X_train_proton_flag\"] = X_train_proton_flag\n",
        "\n",
        "      X_test[\"X_test_pion_flag\"] = X_test_pion_flag\n",
        "      X_test[\"X_test_kaon_flag\"] = X_test_kaon_flag\n",
        "      X_test[\"X_test_proton_flag\"] = X_test_proton_flag\n",
        "\n",
        "      print(f\"  return (X_train, X_test, y_train, y_test) \\n:\")\n",
        "      return (datasets ,X_train, X_test, X_train_unscaled, X_test_unscaled, y_train, y_test, regions)\n",
        "\n",
        "\n",
        "\n",
        "  def build_model(self, input_sequence_length = None, X_train = None, X_test = None, y_train = None, y_test = None, mask = None, epochs = None, include_cnn = False, units = None, units2 = None, final_concat_units = None, CNN_units = None):\n",
        "\n",
        "      dropout = 0.35\n",
        "      alpha = 0.05\n",
        "\n",
        "      #map_shape = (None, None, 1)  # Variable shape for the map input\n",
        "      #X_train_photon_ckov_segmented shape : (1955, 3, 74)\n",
        "\n",
        "      X_train_pion_candidates = X_train[\"X_train_pion_candidates\"]\n",
        "      X_train_kaon_candidates = X_train[\"X_train_kaon_candidates\"]\n",
        "      X_train_proton_candidates = X_train[\"X_train_proton_candidates\"]\n",
        "\n",
        "      X_train_non_candidates = X_train[\"X_train_non_candidates\"]\n",
        "      X_train_momentum = X_train[\"X_train_momentum\"]\n",
        "      X_train_refractive_index = X_train[\"X_train_refractive_index\"]\n",
        "      X_train_phi = X_train[\"X_train_phi\"]\n",
        "      X_train_theta = X_train[\"X_train_theta\"]\n",
        "      X_train_mip_position = X_train[\"X_train_mip_position\"]\n",
        "      X_train_rad_position = X_train[\"X_train_rad_position\"]\n",
        "      X_train_map_pion = X_train[\"X_train_map_pion\"]\n",
        "      X_train_map_kaon = X_train[\"X_train_map_kaon\"]\n",
        "      X_train_map_proton = X_train[\"X_train_map_proton\"]\n",
        "\n",
        "      X_test_pion_candidates = X_test[\"X_test_pion_candidates\"]\n",
        "      X_test_kaon_candidates = X_test[\"X_test_kaon_candidates\"]\n",
        "      X_test_proton_candidates = X_test[\"X_test_proton_candidates\"]\n",
        "      X_test_non_candidates = X_test[\"X_test_non_candidates\"]\n",
        "      X_test_momentum = X_test[\"X_test_momentum\"]\n",
        "      X_test_refractive_index = X_test[\"X_test_refractive_index\"]\n",
        "      X_test_phi = X_test[\"X_test_phi\"]\n",
        "      X_test_theta = X_test[\"X_test_theta\"]\n",
        "      X_test_mip_position = X_test[\"X_test_mip_position\"]\n",
        "      X_test_rad_position = X_test[\"X_test_rad_position\"]\n",
        "      X_test_map_pion = X_test[\"X_test_map_pion\"]\n",
        "      X_test_map_kaon = X_test[\"X_test_map_kaon\"]\n",
        "      X_test_map_proton = X_test[\"X_test_map_proton\"]\n",
        "\n",
        "      X_train_mCluCharge = X_train[\"X_train_mCluCharge\"]\n",
        "      X_train_mCluSize = X_train[\"X_train_mCluSize\"]\n",
        "      X_test_mCluCharge = X_test[\"X_test_mCluCharge\"]\n",
        "      X_test_mCluSize = X_test[\"X_test_mCluSize\"]\n",
        "\n",
        "\n",
        "\n",
        "      X_train_pion_flag = X_train[\"X_train_pion_flag\"]\n",
        "      X_train_kaon_flag = X_train[\"X_train_kaon_flag\"]\n",
        "      X_train_proton_flag = X_train[\"X_train_proton_flag\"]\n",
        "\n",
        "      X_test_pion_flag = X_test[\"X_test_pion_flag\"]\n",
        "      X_test_kaon_flag = X_test[\"X_test_kaon_flag\"]\n",
        "      X_test_proton_flag = X_test[\"X_test_proton_flag\"]\n",
        "\n",
        "\n",
        "      X_test_map_pion = tf.expand_dims(X_test_map_pion, axis=-1)\n",
        "      X_test_map_kaon = tf.expand_dims(X_test_map_kaon, axis=-1)\n",
        "      X_test_map_proton = tf.expand_dims(X_test_map_proton, axis=-1)\n",
        "\n",
        "\n",
        "      X_train_map_pion = tf.expand_dims(X_train_map_pion, axis=-1)\n",
        "      X_train_map_kaon = tf.expand_dims(X_train_map_kaon, axis=-1)\n",
        "      X_train_map_proton = tf.expand_dims(X_train_map_proton, axis=-1)\n",
        "\n",
        "\n",
        "\n",
        "      #plot_function(X_train_pion_candidates, X_train_kaon_candidates, X_train_proton_candidates, X_train_mip_position, X_train_rad_position, X_train_phi, X_train_theta)\n",
        "      print(\"Fields in the first vector of X_train:\")\n",
        "      print(\"X_train_pion_candidates shape:\", X_train_pion_candidates.shape)\n",
        "      print(\"X_train_kaon_candidates shape:\", X_train_kaon_candidates.shape)\n",
        "      print(\"X_train_proton_candidates shape:\", X_train_proton_candidates.shape)\n",
        "      print(\"X_train_momentum shape:\", X_train_momentum.shape)\n",
        "      print(\"X_train_refractive_index shape:\", X_train_refractive_index.shape)\n",
        "      print(\"X_train_phi shape:\", X_train_phi.shape)\n",
        "      print(\"X_train_theta shape:\", X_train_theta.shape)\n",
        "      print(\"X_train_mip_position shape:\", X_train_mip_position.shape)\n",
        "      print(\"X_train_rad_position shape:\", X_train_rad_position.shape)\n",
        "      print(\"X_train_map_pion shape:\", X_train_map_pion.shape)\n",
        "      print(\"X_train_map_kaon shape:\", X_train_map_kaon.shape)\n",
        "      print(\"X_train_map_proton shape:\", X_train_map_proton.shape)\n",
        "\n",
        "      print(\"\\nFields in the first vector of X_test:\")\n",
        "      print(\"X_test_pion_candidates shape:\", X_test_pion_candidates.shape)\n",
        "      print(\"X_test_kaon_candidates shape:\", X_test_kaon_candidates.shape)\n",
        "      print(\"X_test_proton_candidates shape:\", X_test_proton_candidates.shape)\n",
        "      print(\"X_test_momentum shape:\", X_test_momentum.shape)\n",
        "      print(\"X_test_refractive_index shape:\", X_test_refractive_index.shape)\n",
        "      print(\"X_test_phi shape:\", X_test_phi.shape)\n",
        "      print(\"X_test_theta shape:\", X_test_theta.shape)\n",
        "      print(\"X_test_mip_position shape:\", X_test_mip_position.shape)\n",
        "      print(\"X_test_rad_position shape:\", X_test_rad_position.shape)\n",
        "      print(\"X_test_map_pion shape:\", X_test_map_pion.shape)\n",
        "      print(\"X_test_map_kaon shape:\", X_test_map_kaon.shape)\n",
        "      print(\"X_test_map_proton shape:\", X_test_map_proton.shape)\n",
        "\n",
        "      #for i in range(1,5):\n",
        "      #  print(\"X_train_pion_candidates[0,0,i]\", X_train_pion_candidates[0,0,i])\n",
        "\n",
        "      #print(X_train_pion_candidates[:3])\n",
        "\n",
        "      X_train_pion_candidates = np.array(X_train_pion_candidates, dtype='float32')\n",
        "      X_train_kaon_candidates = np.array(X_train_kaon_candidates, dtype='float32')\n",
        "      X_train_proton_candidates = np.array(X_train_proton_candidates, dtype='float32')\n",
        "      X_train_non_candidates = np.array(X_train_non_candidates, dtype='float32')\n",
        "\n",
        "\n",
        "      X_train_pion_candidates = np.array(X_train_pion_candidates, dtype='float32')\n",
        "      X_train_kaon_candidates = np.array(X_train_kaon_candidates, dtype='float32')\n",
        "      X_train_proton_candidates = np.array(X_train_proton_candidates, dtype='float32')\n",
        "      X_test_non_candidates = np.array(X_test_non_candidates, dtype='float32')\n",
        "      # # For train data\n",
        "      # train_variables = [X_train_pion_candidates, X_train_kaon_candidates, X_train_proton_candidates, X_train_non_candidates,\n",
        "      #                   X_train_momentum, X_train_refractive_index, X_train_phi, X_train_theta,\n",
        "      #                   X_train_mip_position, X_train_rad_position,\n",
        "      #                    X_train_map_pion, X_train_map_kaon, X_train_map_proton,\n",
        "      #                    X_train_mCluCharge, X_train_mCluSize]\n",
        "\n",
        "\n",
        "\n",
        "      # train_labels = ['Train Pion Candidates', 'Train Kaon Candidates', 'Train Proton Candidates',\n",
        "      #                 'Train Momentum', 'Train Refractive Index', 'Train Phi', 'Train Theta',\n",
        "      #                 'Train MIP Position', 'Train Rad Position',\n",
        "      #                 'Train Map Pion','Train Map Kaon', 'Train Map Proton',\n",
        "      #                 'Train mCluCharge', 'Train mCluSize']\n",
        "\n",
        "      # for label, variable in zip(train_labels, train_variables):\n",
        "      #     print(f\"{label}: {variable.dtype}\")\n",
        "\n",
        "\n",
        "\n",
        "      # test_variables = [X_test_pion_candidates, X_test_kaon_candidates, X_test_proton_candidates, X_test_non_candidates,\n",
        "      #                   X_test_momentum, X_test_refractive_index, X_test_phi, X_test_theta,\n",
        "      #                   X_test_mip_position, X_test_rad_position,\n",
        "      #                   X_test_map_pion, X_test_map_kaon, X_test_map_proton,\n",
        "      #                   X_test_mCluCharge, X_test_mCluSize]\n",
        "\n",
        "      # test_labels = ['Test Pion Candidates', 'Test Kaon Candidates', 'Test Proton Candidates',\n",
        "      #               'Test Momentum', 'Test Refractive Index', 'Test Phi', 'Test Theta',\n",
        "      #               'Test MIP Position', 'Test Rad Position',\n",
        "      #               'Test Map Pion','Test Map Kaon', 'Test Map Proton',\n",
        "      #               'Test mCluCharge', 'Test mCluSize']\n",
        "\n",
        "\n",
        "      # TODO: evaluer hva som er best !\n",
        "      # 1. sende inn X_test_cand_status_encoded, X_test_cand_pos som det er naa\n",
        "      # 2. bare sende inn de som har status != 0\n",
        "      # 3 splitte til pion, proton, kaon candidates og sende disse inn\n",
        "\n",
        "\n",
        "      len_pion = np.asarray(X_test_pion_candidates, dtype = object).shape[1]\n",
        "      len_kaon = np.asarray(X_test_kaon_candidates, dtype = object).shape[1]\n",
        "      len_proton = np.asarray(X_test_proton_candidates, dtype = object).shape[1]\n",
        "\n",
        "      num_clu_vars = X_test_non_candidates.shape[2]\n",
        "      pion_ip = Input(shape=(len_pion, num_clu_vars), name=\"pion_ip\")\n",
        "      kaon_ip = Input(shape=(len_kaon, num_clu_vars), name=\"kaon_ip\")\n",
        "      proton_ip = Input(shape=(len_proton, num_clu_vars), name=\"proton_ip\")\n",
        "      none_ip = Input(shape=(len_proton, num_clu_vars), name=\"none_ip\")\n",
        "\n",
        "      map_size = nb_size = 50\n",
        "      pion_ip_map =Input(shape=(map_size, map_size, 1), name=\"pion_ip_map\")\n",
        "      kaon_ip_map  = Input(shape=(map_size, map_size, 1), name=\"kaon_ip_map\")\n",
        "      proton_ip_map  =Input(shape=(map_size, map_size, 1), name=\"proton_ip_map\")\n",
        "\n",
        "      # pion_ip = Input(shape=(len_pion, 2), name=\"pion_ip\")\n",
        "      # kaon_ip = Input(shape=(len_kaon, 2), name=\"kaon_ip\")\n",
        "      # proton_ip = Input(shape=(len_proton, 2), name=\"proton_ip\")\n",
        "\n",
        "      none_ip_mask = Masking(mask_value=0.)(none_ip)\n",
        "\n",
        "      pion_ip_mask = Masking(mask_value=0.)(pion_ip)\n",
        "      kaon_ip_mask = Masking(mask_value=0.)(kaon_ip)\n",
        "      proton_ip_mask = Masking(mask_value=0.)(proton_ip)\n",
        "\n",
        "      prev_pion = pion_ip_mask # NB change back to mask\n",
        "      prev_kaon = kaon_ip_mask\n",
        "      prev_proton = proton_ip_mask\n",
        "      prev_none = none_ip_mask\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "      # Grid search parameters\n",
        "      # Grid search parameters\n",
        "      filter_sizes = [5]  # Filter sizes to test\n",
        "      num_filters = [32]#[16, 32]  # Number of filters to test\n",
        "      strides = [(2, 2)]#[(1, 1), (2, 2)]  # Strides to test\n",
        "      pool_sizes = [(2, 2)]  # Max pooling sizes to test\n",
        "      fc1_units = [64]#, 128]  # Number of units in fc1 to test\n",
        "      fc2_units = [32]#, 32]  # Number of units in fc2 to test\n",
        "\n",
        "      dropouts = [0.225, 0.3, 0.35, 0.4]\n",
        "      best_accuracy = 0\n",
        "      best_model = None\n",
        "      alphas = [0.05, 0.1] # 0.05 var bra ca 81%\n",
        "\n",
        "      #\n",
        "      #\n",
        "      #35s 171ms/step - loss: 0.7475 - accuracy: 0.8152 - val_loss: 1.1083 - val_accuracy: 0.7360 - lr: 9.8639e-05 0.05\n",
        "      #loss: 0.7370 - accuracy: 0.8106 - val_loss: 1.1769 - val_accuracy: 0.7280 - lr: 9.8639e-05 0.1\n",
        "\n",
        "      l1l2_weights_mip = [\n",
        "          [(0.01, 0.01, 0.01), (0.02, 0.02, 0.02), (0.03, 0.03, 0.03), (0.04, 0.04, 0.04), (0.05, 0.05, 0.05),\n",
        "          (0.06, 0.06, 0.06), (0.07, 0.07, 0.07), (0.08, 0.08, 0.08), (0.09, 0.09, 0.09), (0.1, 0.1, 0.1), (0.09, 0.09, 0.09), (0.1, 0.1, 0.1), (0.09, 0.09, 0.09), (0.1, 0.1, 0.1)]\n",
        "      ]\n",
        "      l1l2_weights_mip = [[(w1/10, w2/10, w3/10) for (w1, w2, w3) in sublist] for sublist in l1l2_weights_mip]\n",
        "\n",
        "      l1l2_weights_ref_index = [\n",
        "          [(0.01, 0.01, 0.01), (0.02, 0.02, 0.02), (0.03, 0.03, 0.03), (0.04, 0.04, 0.04), (0.05, 0.05, 0.05),\n",
        "          (0.06, 0.06, 0.06), (0.07, 0.07, 0.07), (0.08, 0.08, 0.08), (0.09, 0.09, 0.09), (0.1, 0.1, 0.1), (0.09, 0.09, 0.09), (0.1, 0.1, 0.1), (0.09, 0.09, 0.09), (0.1, 0.1, 0.1)]\n",
        "      ]\n",
        "      l1l2_weights_ref_index = [[(w1/10, w2/10, w3/10) for (w1, w2, w3) in sublist] for sublist in l1l2_weights_ref_index]\n",
        "\n",
        "\n",
        "      l1l2_weights_pos = [[(w1/10, w2/10, w3/10) for (w1, w2, w3) in sublist] for sublist in l1l2_weights_ref_index]\n",
        "\n",
        "      l1l2_weights_hadrons = [\n",
        "          [(0.1, 0.1, 0.1), (0.1, 0.1, 0.1), (0.1, 0.1, 0.1),(0.1, 0.1, 0.1),(0.1, 0.1, 0.1),(0.1, 0.1, 0.1),(0.1, 0.1, 0.1),(0.1, 0.1, 0.1),\n",
        "         (0.1, 0.1, 0.1),(0.1, 0.1, 0.1),(0.1, 0.1, 0.1),(0.1, 0.1, 0.1),(0.1, 0.1, 0.1),(0.1, 0.1, 0.1),\n",
        "          (0.1, 0.1, 0.1),(0.1, 0.1, 0.1),(0.1, 0.1, 0.1),(0.1, 0.1, 0.1),(0.1, 0.1, 0.1),(0.1, 0.1, 0.1),(0.1, 0.1, 0.1),(0.1, 0.1, 0.1),(0.1, 0.1, 0.1)]\n",
        "      ]\n",
        "      l1l2_weights_hadrons = [[(w1/10, w2/10, w3/10) for (w1, w2, w3) in sublist] for sublist in l1l2_weights_hadrons]\n",
        "\n",
        "      l1l2_weights_momentum = [\n",
        "          [(0.01, 0.01, 0.01), (0.02, 0.02, 0.02), (0.1, 0.1, 0.1), (0.1, 0.1, 0.1), (0.1, 0.1, 0.1),\n",
        "          (0.1, 0.1, 0.1), (0.1, 0.1, 0.1), (0.1, 0.1, 0.1), (0.1, 0.1, 0.), (0.1, 0.1, 0.1), (0.09, 0.09, 0.09), (0.1, 0.1, 0.1), (0.09, 0.09, 0.09), (0.1, 0.1, 0.1)]\n",
        "      ]\n",
        "      l1l2_weights_momentum = [[(w1/10, w2/10, w3/10) for (w1, w2, w3) in sublist] for sublist in l1l2_weights_momentum]\n",
        "\n",
        "\n",
        "\n",
        "      scale = 2\n",
        "      # Assigning a constant regularization weight for all sublists, with the same scale\n",
        "      l1l2_weights_mip = [[(0.001*scale, 0.001*scale, 0.001*scale) for _ in sublist] for sublist in l1l2_weights_mip]\n",
        "      l1l2_weights_ref_index = [[(0.001*scale, 0.001*scale, 0.001*scale) for _ in sublist] for sublist in l1l2_weights_ref_index]\n",
        "      l1l2_weights_momentum = [[(0.001*scale, 0.001*scale, 0.001*scale) for _ in sublist] for sublist in l1l2_weights_momentum]\n",
        "      l1l2_weights_rad = [[(0.001*scale, 0.001*scale, 0.001*scale) for _ in sublist] for sublist in l1l2_weights_momentum]\n",
        "      l1l2_weights_phi = [[(0.001*scale, 0.001*scale, 0.001*scale) for _ in sublist] for sublist in l1l2_weights_momentum]\n",
        "      l1l2_weights_theta = [[(0.001*scale, 0.001*scale, 0.001*scale) for _ in sublist] for sublist in l1l2_weights_momentum]\n",
        "      l1l2_weights_cand_pos = [[(0.001*scale, 0.001*scale, 0.001*scale) for _ in sublist] for sublist in l1l2_weights_momentum]\n",
        "      l1l2_weights_cand_status = [[(0.001*scale, 0.001*scale, 0.001*scale) for _ in sublist] for sublist in l1l2_weights_momentum]\n",
        "      l1l2_weights_pos = [[(0.001*scale, 0.001*scale, 0.001*scale) for _ in sublist] for sublist in l1l2_weights_momentum]\n",
        "\n",
        "\n",
        "      print(f\"l1l2_weights_mip shape {np.array(l1l2_weights_mip, dtype =object).shape}\")\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "      momentum_shape = refractive_index_shape = phi_shape = theta_shape = energy_shape = (1, )\n",
        "\n",
        "\n",
        "      pion_flag_ip = kaon_flag_ip = proton_flag_ip  = (1, )\n",
        "\n",
        "\n",
        "      #momentum_shape = refractive_index_shape = phi_shape = theta_shape = energy_shape = (len_proton, 1)\n",
        "\n",
        "      # add the flag inputs here\n",
        "      pion_flag_input = Input(shape=pion_flag_ip, name=\"pion_flag_input\")\n",
        "      kaon_flag_input = Input(shape=kaon_flag_ip, name=\"kaon_flag_input\")\n",
        "      proton_flag_input = Input(shape=proton_flag_ip, name=\"proton_flag_input\")\n",
        "\n",
        "      mip_charge_input  = Input(shape=phi_shape, name=\"mip_charge_input\")\n",
        "      mip_size_input  = Input(shape=phi_shape, name=\"mip_size_input\")\n",
        "\n",
        "      phi_input = Input(shape=phi_shape, name=\"phi_shape\")\n",
        "      theta_input = Input(shape=theta_shape, name=\"theta_shape\")\n",
        "      momentum_input = Input(shape=momentum_shape, name=\"momentum_input\")\n",
        "      refractive_index_input = Input(shape=refractive_index_shape, name=\"refractive_index_input\")\n",
        "      mip_position_shape = rad_position_shape = (2,)\n",
        "      #mip_position_shape = rad_position_shape = (len_proton, 2)\n",
        "\n",
        "      rad_position_input = Input(shape=rad_position_shape, name=\"rad_position_input\")\n",
        "      mip_position_input = Input(shape=mip_position_shape, name=\"mip_position_input\")\n",
        "\n",
        "      print(\"mapplying inputs\")\n",
        "\n",
        "      # For training data\n",
        "      # For train data\n",
        "\n",
        "\n",
        "\n",
        "      print(\"now create ip shapes pion_input_shape\")\n",
        "\n",
        "\n",
        "\n",
        "      # CNN\n",
        "      # pion_input_shape = (map_size[0], map_size[1], 1)\n",
        "      # kaon_input_shape = (map_size[0], map_size[1], 1)\n",
        "      # proton_input_shape = (map_size[0], map_size[1], 1)\n",
        "\n",
        "\n",
        "      a = 1\n",
        "      if include_cnn == True:\n",
        "          inputs = [pion_ip_mask, kaon_ip_mask, proton_ip_mask,none_ip_mask, phi_input, theta_input, refractive_index_input, momentum_input, rad_position_input, mip_position_input, mip_charge_input, mip_size_input, pion_ip_map, kaon_ip_map, proton_ip_map]\n",
        "\n",
        "          train_variables = [X_train_pion_candidates, X_train_kaon_candidates, X_train_proton_candidates, X_train_non_candidates, X_train_phi, X_train_theta, X_train_refractive_index, X_train_momentum, X_train_rad_position, X_train_mip_position, X_train_mCluCharge, X_train_mCluSize, X_train_map_pion, X_train_map_kaon, X_train_map_proton]\n",
        "\n",
        "          train_labels = ['Train Pion Candidates', 'Train Kaon Candidates', 'Train Proton Candidates', 'Train Phi', 'Train Theta', 'Train Refractive Index', 'Train Momentum', 'Train Rad Position', 'Train MIP Position', 'Train mCluCharge', 'Train mCluSize', 'Train Map Pion','Train Map Kaon', 'Train Map Proton']\n",
        "\n",
        "          # Likewise, for the test data\n",
        "          test_variables = [X_test_pion_candidates, X_test_kaon_candidates, X_test_proton_candidates, X_test_non_candidates, X_test_phi, X_test_theta, X_test_refractive_index, X_test_momentum, X_test_rad_position, X_test_mip_position, X_test_mCluCharge, X_test_mCluSize, X_test_map_pion, X_test_map_kaon, X_test_map_proton]\n",
        "\n",
        "          test_labels = ['Test Pion Candidates', 'Test Kaon Candidates', 'Test Proton Candidates', 'Test Phi', 'Test Theta', 'Test Refractive Index', 'Test Momentum', 'Test Rad Position', 'Test MIP Position','Test mCluCharge', 'Test mCluSize', 'Test Map Pion','Test Map Kaon', 'Test Map Proton']\n",
        "\n",
        "      elif a == 1:\n",
        "          inputs = [pion_ip_mask, kaon_ip_mask, proton_ip_mask, none_ip_mask, phi_input, theta_input, refractive_index_input, momentum_input, rad_position_input, mip_position_input, mip_charge_input, mip_size_input]\n",
        "\n",
        "          train_variables = [X_train_pion_candidates, X_train_kaon_candidates, X_train_proton_candidates, X_train_non_candidates, X_train_phi, X_train_theta, X_train_refractive_index, X_train_momentum, X_train_rad_position, X_train_mip_position, X_train_mCluCharge, X_train_mCluSize]\n",
        "\n",
        "          train_labels = ['Train Pion Candidates', 'Train Kaon Candidates', 'Train Proton Candidates', 'Train Phi', 'Train Theta', 'Train Refractive Index', 'Train Momentum', 'Train Rad Position', 'Train MIP Position', 'Train mCluCharge', 'Train mCluSize']\n",
        "\n",
        "          # Likewise, for the test data\n",
        "          test_variables = [X_test_pion_candidates, X_test_kaon_candidates, X_test_proton_candidates, X_test_non_candidates, X_test_phi, X_test_theta, X_test_refractive_index, X_test_momentum, X_test_rad_position, X_test_mip_position, X_test_mCluCharge, X_test_mCluSize]\n",
        "\n",
        "          test_labels = ['Test Pion Candidates', 'Test Kaon Candidates', 'Test Proton Candidates', 'Test Phi', 'Test Theta', 'Test Refractive Index', 'Test Momentum', 'Test Rad Position', 'Test MIP Position','Test mCluCharge', 'Test mCluSize']\n",
        "\n",
        "      else:\n",
        "          inputs = [pion_ip_mask, kaon_ip_mask, proton_ip_mask, mip_position_input]\n",
        "\n",
        "          train_variables = [X_train_pion_candidates, X_train_kaon_candidates, X_train_proton_candidates, X_train_mip_position]\n",
        "\n",
        "          train_labels = ['Train Pion Candidates', 'Train Kaon Candidates', 'Train Proton Candidates', 'Train Phi', 'Train Theta', 'Train Refractive Index', 'Train Momentum', 'Train Rad Position', 'Train MIP Position', 'Train mCluCharge', 'Train mCluSize']\n",
        "\n",
        "          test_variables = [X_test_pion_candidates, X_test_kaon_candidates, X_test_proton_candidates, X_test_mip_position]\n",
        "          test_labels = ['Test Pion Candidates', 'Test Kaon Candidates', 'Test Proton Candidates', 'Test Phi', 'Test Theta', 'Test Refractive Index', 'Test Momentum', 'Test Rad Position', 'Test MIP Position','Test mCluCharge', 'Test mCluSize']\n",
        "\n",
        "      d=1\n",
        "      for input_layer in inputs:\n",
        "          print(f\"input{d} = {input_layer}, input_shape = {input_layer.shape}\")\n",
        "          d = d+1\n",
        "      num_filters = strides = 1\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "      # print the number of nan\n",
        "      #print(f\"Number of nan values in pion_candidates_test = {nan_count}\")\n",
        "      pion_ip_mask = Masking(mask_value=0.)(pion_ip)\n",
        "      kaon_ip_mask = Masking(mask_value=0.)(kaon_ip)\n",
        "      proton_ip_mask = Masking(mask_value=0.)(proton_ip)\n",
        "      none_ip_mask = Masking(mask_value=0.)(none_ip)\n",
        "\n",
        "\n",
        "      for i in range(1, len(units)):\n",
        "          unit = int(units[i])\n",
        "\n",
        "          # For pion\n",
        "          dense_pion_i = Dense(unit, name=f\"dense_pion_{i}{dropout}\", kernel_initializer='he_normal',\n",
        "                              kernel_regularizer=regularizers.L1L2(l1l2_weights_hadrons[0][i - 1][0], l1l2_weights_hadrons[0][i - 1][1]),\n",
        "                              bias_regularizer=regularizers.L1(l1l2_weights_hadrons[0][i - 1][2]))(prev_pion)\n",
        "\n",
        "          bn_pion_i = BatchNormalization(name=f\"bn_pion_{i}{dropout}\")(dense_pion_i)\n",
        "          leakyrelu_pion_i = LeakyReLU(alpha=alpha, name=f\"leakyrelu_pion_{i}{dropout}\")(bn_pion_i)\n",
        "          dropout_pion_i = Dropout(dropout, name=f\"dropout_pion_{i}{dropout}\")(leakyrelu_pion_i)\n",
        "          prev_pion = dropout_pion_i\n",
        "\n",
        "          # For kaon\n",
        "          dense_kaon_i = Dense(unit, name=f\"dense_kaon_{i}{dropout}\", kernel_initializer='he_normal',\n",
        "                              kernel_regularizer=regularizers.L1L2(l1l2_weights_hadrons[0][i - 1][0], l1l2_weights_hadrons[0][i - 1][1]),\n",
        "                              bias_regularizer=regularizers.L1(l1l2_weights_hadrons[0][i - 1][2]))(prev_kaon)\n",
        "\n",
        "          bn_kaon_i = BatchNormalization(name=f\"bn_kaon_{i}{dropout}\")(dense_kaon_i)\n",
        "          leakyrelu_kaon_i = LeakyReLU(alpha=alpha, name=f\"leakyrelu_kaon_{i}{dropout}\")(bn_kaon_i)\n",
        "          dropout_kaon_i = Dropout(dropout, name=f\"dropout_kaon_{i}{dropout}\")(leakyrelu_kaon_i)\n",
        "          prev_kaon = dropout_kaon_i\n",
        "\n",
        "          # For proton\n",
        "          dense_proton_i = Dense(unit, name=f\"dense_proton_{i}{dropout}\", kernel_initializer='he_normal',\n",
        "                                kernel_regularizer=regularizers.L1L2(l1l2_weights_hadrons[0][i - 1][0], l1l2_weights_hadrons[0][i - 1][1]),\n",
        "                                bias_regularizer=regularizers.L1(l1l2_weights_hadrons[0][i - 1][2]))(prev_proton)\n",
        "\n",
        "          bn_proton_i = BatchNormalization(name=f\"bn_proton_{i}{dropout}\")(dense_proton_i)\n",
        "          leakyrelu_proton_i = LeakyReLU(alpha=alpha, name=f\"leakyrelu_proton_{i}{dropout}\")(bn_proton_i)\n",
        "          dropout_proton_i = Dropout(dropout, name=f\"dropout_proton_{i}{dropout}\")(leakyrelu_proton_i)\n",
        "          prev_proton = dropout_proton_i\n",
        "\n",
        "\n",
        "          # For none\n",
        "          dense_none_i = Dense(unit, name=f\"dense_none_{i}{dropout}\", kernel_initializer='he_normal',\n",
        "                                kernel_regularizer=regularizers.L1L2(l1l2_weights_hadrons[0][i - 1][0], l1l2_weights_hadrons[0][i - 1][1]),\n",
        "                                bias_regularizer=regularizers.L1(l1l2_weights_hadrons[0][i - 1][2]))(prev_none)\n",
        "\n",
        "          bn_non_i = BatchNormalization(name=f\"bn_nonn_{i}{dropout}\")(dense_none_i)\n",
        "          leakyrelu_non_i = LeakyReLU(alpha=alpha, name=f\"leakyrelu_non_{i}{dropout}\")(bn_non_i)\n",
        "          dropout_non_i = Dropout(dropout, name=f\"dropout_non_{i}{dropout}\")(leakyrelu_non_i)\n",
        "          prev_non = dropout_non_i\n",
        "\n",
        "\n",
        "      prev_momentum = momentum_input\n",
        "      prev_momentum = tf.identity(prev_momentum, name=\"prev_momentum\")\n",
        "\n",
        "      prev_ref_index = refractive_index_input\n",
        "      prev_ref_index = tf.identity(prev_ref_index, name=\"prev_ref_index\")\n",
        "\n",
        "      prev_mip = mip_position_input\n",
        "      prev_mip = tf.identity(prev_mip, name=\"prev_mip\")\n",
        "\n",
        "      prev_rad = rad_position_input\n",
        "      prev_rad = tf.identity(prev_rad, name=\"prev_rad\")\n",
        "\n",
        "      prev_phi = phi_input\n",
        "      prev_phi = tf.identity(prev_phi, name=\"prev_phi\")\n",
        "\n",
        "      prev_theta = theta_input\n",
        "      prev_theta = tf.identity(prev_theta, name=\"prev_theta\")\n",
        "\n",
        "      prev_mCluCharge = mip_charge_input\n",
        "      prev_mCluCharge = tf.identity(prev_mCluCharge, name=\"prev_mCluCharge\")\n",
        "\n",
        "      prev_mCluSize = mip_size_input\n",
        "      prev_mCluSize = tf.identity(prev_mCluSize, name=\"prev_mCluSize\")\n",
        "\n",
        "\n",
        "      for i in range(1, len(units2)):\n",
        "          step = int(units2[i])\n",
        "          unit = int(units2[i])\n",
        "\n",
        "          #### REFRACTIVE INDEX #####\n",
        "          dense_ref_index_i = Dense(step, name=f\"dense_ref_index_{i}{dropout}\", kernel_initializer='he_normal',\n",
        "                                    kernel_regularizer=regularizers.L1L2(l1l2_weights_ref_index[0][i - 1][0], l1l2_weights_ref_index[0][i - 1][1]),\n",
        "                                    bias_regularizer=regularizers.L1(l1l2_weights_ref_index[0][i - 1][2]))(prev_ref_index)\n",
        "\n",
        "          bn_ref_index_i = BatchNormalization(name=f\"bn_ref_index_{i}{dropout}\")(dense_ref_index_i)\n",
        "          leakyrelu_ref_index_i = LeakyReLU(alpha=alpha, name=f\"leakyrelu_ref_index_{i}{dropout}\")(bn_ref_index_i)\n",
        "          dropout_ref_index_i = Dropout(dropout, name=f\"dropout_ref_index_{i}{dropout}\")(leakyrelu_ref_index_i)\n",
        "\n",
        "          #### MOMENTUM #####\n",
        "          dense_momentum_i = Dense(step, name=f\"dense_momentum_{i}{dropout}\", kernel_initializer='he_normal', kernel_regularizer=regularizers.L1L2(l1l2_weights_momentum[0][i - 1][0], l1l2_weights_momentum[0][i - 1][1]), bias_regularizer=regularizers.L1(l1l2_weights_momentum[0][i - 1][2]))(prev_momentum)\n",
        "          bn_momentum_i = BatchNormalization(name=f\"bn_momentum_{i}{dropout}\")(dense_momentum_i)\n",
        "          leakyrelu_momentum_i = LeakyReLU(alpha=alpha, name=f\"leakyrelu_momentum_{i}{dropout}\")(bn_momentum_i)\n",
        "          dropout_momentum_i = Dropout(dropout, name=f\"dropout_momentum_{i}{dropout}\")(leakyrelu_momentum_i)\n",
        "\n",
        "          # PHI\n",
        "          dense_phi_i = Dense(step, name=f\"dense_phi_{i}{dropout}\", kernel_initializer='he_normal',\n",
        "                              kernel_regularizer=regularizers.L1L2(l1l2_weights_phi[0][i - 1][0], l1l2_weights_phi[0][i - 1][1]),\n",
        "                              bias_regularizer=regularizers.L1(l1l2_weights_phi[0][i - 1][2]))(prev_phi)\n",
        "          bn_phi_i = BatchNormalization(name=f\"bn_phi_{i}{dropout}\")(dense_phi_i)\n",
        "          leakyrelu_phi_i = LeakyReLU(alpha=alpha, name=f\"leakyrelu_phi_{i}{dropout}\")(bn_phi_i)\n",
        "          dropout_phi_i = Dropout(dropout, name=f\"dropout_phi_{i}{dropout}\")(leakyrelu_phi_i)\n",
        "\n",
        "          # THETA\n",
        "          dense_theta_i = Dense(step, name=f\"dense_theta_{i}{dropout}\", kernel_initializer='he_normal',\n",
        "                              kernel_regularizer=regularizers.L1L2(l1l2_weights_theta[0][i - 1][0], l1l2_weights_theta[0][i - 1][1]),\n",
        "                              bias_regularizer=regularizers.L1(l1l2_weights_theta[0][i - 1][2]))(prev_theta)\n",
        "          bn_theta_i = BatchNormalization(name=f\"bn_theta_{i}{dropout}\")(dense_theta_i)\n",
        "          leakyrelu_theta_i = LeakyReLU(alpha=alpha, name=f\"leakyrelu_theta_{i}{dropout}\")(bn_theta_i)\n",
        "          dropout_theta_i = Dropout(dropout, name=f\"dropout_theta_{i}{dropout}\")(leakyrelu_theta_i)\n",
        "\n",
        "          # RAD_POSITION\n",
        "          dense_rad_position_i = Dense(step, name=f\"dense_rad_position_{i}{dropout}\", kernel_initializer='he_normal',\n",
        "                              kernel_regularizer=regularizers.L1L2(l1l2_weights_rad[0][i - 1][0], l1l2_weights_rad[0][i - 1][1]),\n",
        "                              bias_regularizer=regularizers.L1(l1l2_weights_rad[0][i - 1][2]))(prev_rad)\n",
        "          bn_rad_position_i = BatchNormalization(name=f\"bn_rad_position_{i}{dropout}\")(dense_rad_position_i)\n",
        "          leakyrelu_rad_position_i = LeakyReLU(alpha=alpha, name=f\"leakyrelu_rad_position_{i}{dropout}\")(bn_rad_position_i)\n",
        "          dropout_rad_position_i = Dropout(dropout, name=f\"dropout_rad_position_{i}{dropout}\")(leakyrelu_rad_position_i)\n",
        "\n",
        "\n",
        "          #### MIP POS #####\n",
        "          dense_mip_pos_i = Dense(step/2, name=f\"dense_mip_pos_{i}{dropout}\", kernel_initializer='he_normal',\n",
        "                                  kernel_regularizer=regularizers.L1L2(l1l2_weights_mip[0][i - 1][0], l1l2_weights_mip[0][i - 1][1]),\n",
        "                                  bias_regularizer=regularizers.L1(l1l2_weights_mip[0][i - 1][2]))(prev_mip)\n",
        "\n",
        "          bn_mip_pos_i = BatchNormalization(name=f\"bn_mip_pos_{i}{dropout}\")(dense_mip_pos_i)\n",
        "          leakyrelu_mip_pos_i = LeakyReLU(alpha=alpha, name=f\"leakyrelu_mip_pos_{i}{dropout}\")(bn_mip_pos_i)\n",
        "          dropout_mip_pos_i = Dropout(dropout, name=f\"dropout_mip_pos_{i}{dropout}\")(leakyrelu_mip_pos_i)\n",
        "\n",
        "\n",
        "          prev_mip = dropout_mip_pos_i\n",
        "          prev_rad = dropout_rad_position_i\n",
        "\n",
        "          prev_momentum = dropout_momentum_i\n",
        "          prev_ref_index = dropout_ref_index_i\n",
        "          prev_phi = dropout_phi_i\n",
        "          prev_theta = dropout_theta_i\n",
        "          #### mClucharge #####\n",
        "          dense_mClucharge_i = Dense(step, name=f\"dense_mClucharge_{i}{dropout}\", kernel_initializer='he_normal',\n",
        "                                     kernel_regularizer=regularizers.L1L2(l1l2_weights_theta[0][i - 1][0], l1l2_weights_theta[0][i - 1][1]),\n",
        "                                     bias_regularizer=regularizers.L1(l1l2_weights_theta[0][i - 1][2]))(prev_mCluCharge)\n",
        "          bn_mClucharge_i = BatchNormalization(name=f\"bn_mClucharge_{i}{dropout}\")(dense_mClucharge_i)\n",
        "          leakyrelu_mClucharge_i = LeakyReLU(alpha=alpha, name=f\"leakyrelu_mClucharge_{i}{dropout}\")(bn_mClucharge_i)\n",
        "          dropout_mClucharge_i = Dropout(dropout, name=f\"dropout_mClucharge_{i}{dropout}\")(leakyrelu_mClucharge_i)\n",
        "\n",
        "          #### mCluSize #####\n",
        "          dense_mCluSize_i = Dense(step, name=f\"dense_mCluSize_{i}{dropout}\", kernel_initializer='he_normal',\n",
        "                                   kernel_regularizer=regularizers.L1L2(l1l2_weights_theta[0][i - 1][0], l1l2_weights_theta[0][i - 1][1]),\n",
        "                                   bias_regularizer=regularizers.L1(l1l2_weights_theta[0][i - 1][2]))(prev_mCluSize)\n",
        "          bn_mCluSize_i = BatchNormalization(name=f\"bn_mCluSize_{i}{dropout}\")(dense_mCluSize_i)\n",
        "          leakyrelu_mCluSize_i = LeakyReLU(alpha=alpha, name=f\"leakyrelu_mCluSize_{i}{dropout}\")(bn_mCluSize_i)\n",
        "          dropout_mCluSize_i = Dropout(dropout, name=f\"dropout_mCluSize_{i}{dropout}\")(leakyrelu_mCluSize_i)\n",
        "\n",
        "          prev_mCluCharge  = dropout_mClucharge_i\n",
        "          prev_mCluSize = dropout_mCluSize_i\n",
        "          #  do the same as for the others for mClucharge and mCluSize\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "      epochs = epochs\n",
        "      lr = create_lr_scheduler(num_epochs=epochs)\n",
        "\n",
        "      # concat_layers should have same ordeR :\n",
        "\n",
        "      print(\"now concat scalar 2D\")\n",
        "\n",
        "\n",
        "      #  add  mClucharge and mCluSize :\n",
        "      pre_dense_layer = tf.keras.layers.Concatenate(name=\"concat_scalars_2D\")([prev_mip])\n",
        "\n",
        "      pre_dense_layer = tf.keras.layers.Concatenate(name=\"concat_scalars_2D\")([prev_phi, prev_theta, prev_ref_index, prev_momentum, prev_rad, prev_mip, prev_mCluCharge, prev_mCluSize])\n",
        "      # can i flatten something here to make the dimensions match? :\n",
        "\n",
        "      flat_pion = Flatten(name = \"flatpion\")(prev_pion)\n",
        "      flat_kaon = Flatten(name = \"flatkaon\")(prev_kaon)\n",
        "      flat_proton = Flatten(name = \"flatproton\")(prev_proton)\n",
        "      flat_non = Flatten(name = \"flat_non\")(prev_non)\n",
        "\n",
        "\n",
        "      print(\"now call extract_neighborhood_map\")\n",
        "\n",
        "\n",
        "      filters = [64*2, 128*2, 256*2]\n",
        "      stride_arr = [2,2,2]\n",
        "      filter_sizes = [3,5,7]\n",
        "\n",
        "      do = 0.375\n",
        "      l1 = 0.001\n",
        "      l2 = 0.001\n",
        "      flat_mapPion = build_species_layers(pion_ip_map, filters, filter_sizes, stride_arr, alpha, do, l1,l2)\n",
        "      flat_mapKaon = build_species_layers(kaon_ip_map, filters, filter_sizes, stride_arr, alpha, do, l1, l2)\n",
        "      flat_mapProton = build_species_layers(proton_ip_map, filters, filter_sizes, stride_arr, alpha, do, l1, l2)\n",
        "\n",
        "      print(\"now concat_cnn done \")\n",
        "      concat_layers = [flat_pion, flat_kaon, flat_proton]#, flat_non]\n",
        "      concat_layers = [flat_pion, flat_kaon, flat_proton, flat_non]\n",
        "\n",
        "      dense_comb = Dense(16)(pre_dense_layer)\n",
        "      leaky_dense_comb = LeakyReLU(alpha=alpha)(dense_comb)\n",
        "      dropout_comb = Dropout(dropout)(leaky_dense_comb)\n",
        "\n",
        "\n",
        "      if include_cnn:\n",
        "        concat_cnn = tf.keras.layers.Concatenate(name=\"ConcatCNN\")([flat_mapPion, flat_mapKaon, flat_mapProton])\n",
        "\n",
        "\n",
        "\n",
        "        un = [128, 64, 16]\n",
        "        for i in un:\n",
        "          dense_cnn = Dense(i, kernel_initializer='he_normal')(concat_cnn)\n",
        "\n",
        "          # Then apply BatchNormalization\n",
        "          bn_dense_cnn = BatchNormalization()(dense_cnn)\n",
        "\n",
        "          # Then apply Activation (LeakyReLU)\n",
        "          leaky_dense_cnn = LeakyReLU(alpha=alpha)(bn_dense_cnn)\n",
        "\n",
        "          # Finally apply Dropout\n",
        "          dropout_cnn = Dropout(dropout)(leaky_dense_cnn)\n",
        "\n",
        "\n",
        "        print(\"now concat all\")\n",
        "        final_concat_layer = tf.keras.layers.Concatenate(name=\"concat_scalars_all\")(concat_layers  +  [pre_dense_layer]  + [dropout_cnn])\n",
        "\n",
        "        if final_concat_units is None:\n",
        "          final_concat_units = [128, 64, 16]\n",
        "        for i in final_concat_units:\n",
        "          dense_final = Dense(i, kernel_initializer='he_normal')(final_concat_layer)\n",
        "          bn_final = BatchNormalization()(dense_final)\n",
        "          leaky_final = LeakyReLU(alpha=alpha)(bn_final)\n",
        "          final_concat_layer = Dropout(dropout)(leaky_final)\n",
        "          num_labels = np.array(y_test).shape[1]\n",
        "\n",
        "\n",
        "          d = 1\n",
        "          # for layer in final_concat_layer:\n",
        "          #     print(f\"concat_layers{d} : layer = {layer}, output_shape = {layer.shape}, layer_name = {layer.name}\")\n",
        "          #     d = d + 1\n",
        "          # print(\"\\n\")\n",
        "\n",
        "          output = Dense(num_labels, activation='softmax')(final_concat_layer) # NB LEGG MERKE TIL AT DENNE ER ENDRET FRA FC2\n",
        "      else :\n",
        "        final_concat_layer = tf.keras.layers.Concatenate(name=\"concat_scalars_all\")(concat_layers + [pre_dense_layer] )\n",
        "\n",
        "\n",
        "        if final_concat_units is None:\n",
        "          final_concat_units = [128, 64, 16]\n",
        "        for i in final_concat_units:\n",
        "          dense_final = Dense(i)(final_concat_layer)\n",
        "          bn_final = BatchNormalization()(dense_final)\n",
        "          leaky_final = LeakyReLU(alpha=alpha)(bn_final)\n",
        "          final_concat_layer = Dropout(dropout)(leaky_final)\n",
        "\n",
        "          num_labels = np.array(y_test).shape[1]\n",
        "\n",
        "\n",
        "          d = 1\n",
        "          # for layer in final_concat_layer:\n",
        "          #     print(f\"concat_layers{d} : layer = {layer}, output_shape = {layer.shape}, layer_name = {layer.name}\")\n",
        "          #     d = d + 1\n",
        "          # print(\"\\n\")\n",
        "          output = Dense(num_labels, activation='softmax')(final_concat_layer) # NB LEGG MERKE TIL AT DENNE ER ENDRET FRA FC2\n",
        "\n",
        "\n",
        "\n",
        "      # for kun √• evaluere en hvis type IPs\n",
        "      #inputs, concat_layers, x_input_test, x_input_train = [], [], [], []\n",
        "      #x_input_train_ev = [pion_candidates_train_tf, kaon_candidates_train_tf, proton_candidates_train_tf, X_train[\"X_train_refractive_index\"],X_train[\"X_train_momentum\"], X_train[\"X_train_mip_position\"]]\n",
        "      #x_input_test_ev = [pion_candidates_test_tf, kaon_candidates_test_tf, proton_candidates_test_tf, X_test[\"X_test_refractive_index\"],X_test[\"X_test_momentum\"], X_test[\"X_test_mip_position\"]]\n",
        "\n",
        "\n",
        "      # senere : for √• kun ta med en hvis type parametere :\n",
        "      # for index in range(len(inputs_ev)):\n",
        "      #   if mask[index] == 1:\n",
        "      #     inputs.append(inputs_ev[index])\n",
        "      #     concat_layers.append(concat_layers_ev[index])\n",
        "      #     x_input_train.append(x_input_train_ev[index])\n",
        "      #     x_input_test.append(x_input_test_ev[index])\n",
        "\n",
        "      print(\"Concatenating layers by : concat = concatenate(concat_layers)\")\n",
        "      concat = concatenate(concat_layers)\n",
        "\n",
        "\n",
        "\n",
        "      ## number of op typs : other pion kaon proton\n",
        "      # changed to 3 outputs -- ie no noncandidate\n",
        "      print(f\"y_test.shape : {np.array(y_test).shape}\")\n",
        "\n",
        "\n",
        "\n",
        "      #x_input_train = [pion_candidates_train_tf, kaon_candidates_train_tf, proton_candidates_train_tf]\n",
        "      #x_input_test = [pion_candidates_test_tf, kaon_candidates_test_tf, proton_candidates_test_tf]\n",
        "\n",
        "      x_input_train = train_variables\n",
        "      x_input_test = test_variables\n",
        "      # for i, array in enumerate(x_input_train):\n",
        "      #     if np.isnan(array).any():\n",
        "      #         print(f\"Array at index {i} contains NaN values.\")\n",
        "      #     else:\n",
        "      #         print(f\"Array at index {i} is valid.\")\n",
        "      # for i, array in enumerate(x_input_train):\n",
        "      #     if np.any(np.isnan(array)):\n",
        "      #         print(f\"Array at index {i} contains NaN values.\")\n",
        "      #     else:\n",
        "      #         print(f\"Array at index {i} does not contain NaN values.\")\n",
        "      # d = 1\n",
        "      # for input_layer in inputs:\n",
        "      #     print(f\"input{d} = {input_layer}, input_shape = {input_layer.shape}, input_name = {input_layer.name}\")\n",
        "      #     d = d + 1\n",
        "\n",
        "      # d = 1\n",
        "      # for layer in concat_layers:\n",
        "      #     print(f\"concat_layers{d} : layer = {layer}, output_shape = {layer.shape}, layer_name = {layer.name}\")\n",
        "      #     d = d + 1\n",
        "\n",
        "\n",
        "      # for i, input in enumerate(inputs):\n",
        "      #   print(f\"input{i} = {input} || inputname ={input.name}\")\n",
        "      #   print(f\"output{i} = {concat_layers[i]} | output_shape = {concat_layers[i].name}\")\n",
        "      #   try:\n",
        "      #     print(f\"x_input_train_shape{i} = {np.asarray(np.asarray(x_input_train[i]), dtype=object).shape}\")\n",
        "      #   except Exception as e:\n",
        "      #     print(f\"x_input_train_shape failed w {e}\")\n",
        "\n",
        "      model = Model(inputs = inputs, outputs=output)\n",
        "\n",
        "\n",
        "\n",
        "      y_train_with_flags = np.concatenate([y_train, X_train[\"X_train_pion_flag\"], X_train[\"X_train_kaon_flag\"], X_train[\"X_train_proton_flag\"]], axis=1)\n",
        "\n",
        "      y_test_with_flags = np.concatenate([y_test, X_test[\"X_test_pion_flag\"], X_test[\"X_test_kaon_flag\"], X_test[\"X_test_proton_flag\"]], axis=1)\n",
        "\n",
        "      #model.compile(optimizer='adam', loss=custom_loss, metrics=['accuracy'])\n",
        "      model.compile(optimizer='adam', loss=\"categorical_crossentropy\", metrics=['accuracy'])\n",
        "\n",
        "\n",
        "      batch_size_callback = GradualBatchSizeIncrease(start_size=128, max_size=256, increase_factor=2, interval=5)\n",
        "\n",
        "      history = model.fit(\n",
        "          x=train_variables,\n",
        "          y=y_train,\n",
        "          validation_data=(\n",
        "              test_variables,\n",
        "              y_test\n",
        "          ),\n",
        "          batch_size=128, # will be scheduled by GradualBatchSizeIncrease\n",
        "          epochs=epochs,\n",
        "          verbose=1,\n",
        "          callbacks=[lr, tensorboard_callback, early_stopping]#, batch_size_callback]\n",
        "      )\n",
        "\n",
        "      variables = [train_variables, y_train, test_variables, y_test]\n",
        "\n",
        "      #   # plotting the worst cases?:\n",
        "      #   #y_pred_test = model.predict([X_test[\"X_test_map\"], X_test[\"X_test_momentum\"], X_test[\"X_test_refractive_index\"], X_test[\"X_test_mip_position\"]])\n",
        "      #   #plot_worst(model, y_test, X_test_map, X_test_momentum, X_test_refractive_index, X_test_ckov, X_test_mip_position, y_pred):\n",
        "      #   print(\"Shape of y_test: \", y_test.shape)\n",
        "      #   #print(\"Shape of X_test_map: \", X_test[\"X_test_map\"].shape)\n",
        "      # # print(\"Shape of X_test_windows: \", X_test[\"X_test_windows\"].shape)\n",
        "      #   print(\"Shape of X_test_momentum: \", X_test[\"X_test_momentum\"].shape)\n",
        "      #   print(\"Shape of X_test_refractive_index: \", X_test[\"X_test_refractive_index\"].shape)\n",
        "      #   #print(\"Shape of X_test_ckov: \", X_test[\"X_test_ckov\"].shape)\n",
        "      #   print(\"Shape of X_test_mip_position: \", X_test[\"X_test_mip_position\"].shape)\n",
        "      #   #print(\"Shape of y_pred_test: \", y_pred_test.shape)\n",
        "      #   # try: # NB! commented out this line\n",
        "      #   #   #plot_worst_(model, y_test, X_test[\"X_test_map\"], X_test[\"X_test_momentum\"], X_test[\"X_test_refractive_index\"], X_test[\"X_test_ckov\"], X_test[\"X_test_mip_position\"], y_pred_test)\n",
        "      #   #   #plot_worst_(model, y_test, X_test[\"X_test_map\"], X_test[\"X_test_momentum\"], X_test[\"X_test_refractive_index\"], X_test[\"X_test_ckov\"], X_test[\"X_test_mip_position\"], self.resolution)\n",
        "      #   # except Exception as e:\n",
        "      #   #   print(f\"skip plot_worst_ due to error: {e}\")\n",
        "\n",
        "      # Evaluate the model\n",
        "\n",
        "      # x_ip_test = [pion_candidates_test_tf, kaon_candidates_test_tf, proton_candidates_test_tf,\n",
        "      #         X_test[\"X_test_refractive_index\"], X_test[\"X_test_momentum\"], X_test[\"X_test_mip_position\"]]\n",
        "      x_ip_test = x_input_test\n",
        "      _, accuracy = model.evaluate( x= x_ip_test,y=y_test,verbose=1 )\n",
        "\n",
        "\n",
        "\n",
        "      # Check if the current model configuration is better\n",
        "      if accuracy > best_accuracy:\n",
        "          best_accuracy = accuracy\n",
        "          best_model = model\n",
        "\n",
        "      # Set the best model as the final model\n",
        "      self.model = best_model\n",
        "      return model, history, variables\n",
        "\n",
        "\n",
        "  def train_model(self, X_train, X_test, y_train, y_test):\n",
        "      # Compile the model\n",
        "\n",
        "      X_train_pion_candidates = X_train[\"X_train_pion_candidates\"]\n",
        "      X_train_kaon_candidates = X_train[\"X_train_kaon_candidates\"]\n",
        "      X_train_proton_candidates = X_train[\"X_train_proton_candidates\"]\n",
        "      X_train_momentum = X_train[\"X_train_momentum\"]\n",
        "      X_train_refractive_index = X_train[\"X_train_refractive_index\"]\n",
        "      X_train_phi = X_train[\"X_train_phi\"]\n",
        "      X_train_theta = X_train[\"X_train_theta\"]\n",
        "      X_train_mip_position = X_train[\"X_train_mip_position\"]\n",
        "      X_train_rad_position = X_train[\"X_train_rad_position\"]\n",
        "\n",
        "      X_test_pion_candidates = X_test[\"X_test_pion_candidates\"]\n",
        "      X_test_kaon_candidates = X_test[\"X_test_kaon_candidates\"]\n",
        "      X_test_proton_candidates = X_test[\"X_test_proton_candidates\"]\n",
        "      X_test_momentum = X_test[\"X_test_momentum\"]\n",
        "      X_test_refractive_index = X_test[\"X_test_refractive_index\"]\n",
        "      X_test_phi = X_test[\"X_test_phi\"]\n",
        "      X_test_theta = X_test[\"X_test_theta\"]\n",
        "      X_test_mip_position = X_test[\"X_test_mip_position\"]\n",
        "      X_test_rad_position = X_test[\"X_test_rad_position\"]\n",
        "\n",
        "      print(\"Fields in the first vector of X_train:\")\n",
        "      print(\"X_train_pion_candidates shape:\", X_train_pion_candidates.shape)\n",
        "      print(\"X_train_kaon_candidates shape:\", X_train_kaon_candidates.shape)\n",
        "      print(\"X_train_proton_candidates shape:\", X_train_proton_candidates.shape)\n",
        "      print(\"X_train_momentum shape:\", X_train_momentum.shape)\n",
        "      print(\"X_train_refractive_index shape:\", X_train_refractive_index.shape)\n",
        "      print(\"X_train_phi shape:\", X_train_phi.shape)\n",
        "      print(\"X_train_theta shape:\", X_train_theta.shape)\n",
        "      print(\"X_train_mip_position shape:\", X_train_mip_position.shape)\n",
        "      print(\"X_train_rad_position shape:\", X_train_rad_position.shape)\n",
        "\n",
        "      print(\"\\nFields in the first vector of X_test:\")\n",
        "      print(\"X_test_pion_candidates shape:\", X_test_pion_candidates.shape)\n",
        "      print(\"X_test_kaon_candidates shape:\", X_test_kaon_candidates.shape)\n",
        "      print(\"X_test_proton_candidates shape:\", X_test_proton_candidates.shape)\n",
        "      print(\"X_test_momentum shape:\", X_test_momentum.shape)\n",
        "      print(\"X_test_refractive_index shape:\", X_test_refractive_index.shape)\n",
        "      print(\"X_test_phi shape:\", X_test_phi.shape)\n",
        "      print(\"X_test_theta shape:\", X_test_theta.shape)\n",
        "      print(\"X_test_mip_position shape:\", X_test_mip_position.shape)\n",
        "      print(\"X_test_rad_position shape:\", X_test_rad_position.shape)\n",
        "\n",
        "      self.model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.0002), loss=\"categorical_crossentropy\", metrics=[\"accuracy\"])\n",
        "\n",
        "\n",
        "\n",
        "      # Print the first element of y_train\n",
        "      print(\"First element of y_train:\", y_train[0])\n",
        "\n",
        "      # Train the model\n",
        "      history = self.model.fit( x=[X_train], y=y_train,validation_data=( [X_test],y_test), batch_size=16,epochs=10,verbose=1)\n",
        "      return history\n",
        "\n",
        "  def evaluate_model(self, X_test, y_test):\n",
        "\n",
        "\n",
        "      X_test_pion_candidates = X_test[\"X_test_pion_candidates\"]\n",
        "      X_test_kaon_candidates = X_test[\"X_test_kaon_candidates\"]\n",
        "      X_test_proton_candidates = X_test[\"X_test_proton_candidates\"]\n",
        "      X_test_momentum = X_test[\"X_test_momentum\"]\n",
        "      X_test_refractive_index = X_test[\"X_test_refractive_index\"]\n",
        "      X_test_phi = X_test[\"X_test_phi\"]\n",
        "      X_test_theta = X_test[\"X_test_theta\"]\n",
        "      X_test_mip_position = X_test[\"X_test_mip_position\"]\n",
        "      X_test_rad_position = X_test[\"X_test_rad_position\"]\n",
        "      loss, accuracy = self.model.evaluate(x=X_test, y=y_test,verbose=0)\n",
        "      print(f\"Test Loss: {loss:.4f}\")\n",
        "      print(f\"Test Accuracy: {accuracy:.4f}\")\n",
        "\n",
        "\n",
        "  def train(self, X_train, X_test, y_train, y_test, mask, num_epochs, include_cnn = True, units = None, units2 = None, final_concat_units = None, CNN_units = None):\n",
        "\n",
        "      #X_ckov_segm = X_train[\"X_train_photon_ckov_segmented\"]\n",
        "      #print(f\"X_train_photon_ckov_segmented shape = {np.asarray(X_ckov_segm, dtype = object).shape}\")\n",
        "      X_train_photon_ckov_segmented = 0# np.asarray(X_train[\"X_train_photon_ckov_segmented\"])\n",
        "\n",
        "\n",
        "\n",
        "      #print(f\" in  def train(self, filename) : X_train_photon_ckov_segmented shape : {X_train_photon_ckov_segmented.shape}\")\n",
        "      #X_train_dist2mip = X_train_dist2mip.reshape(X_train_dist2mip.shape[0], X_train_dist2mip.shape[1],, 1)\n",
        "      #for dist in X_train_dist2mip:\n",
        "      #  print(f\"dist = {dist}\")\n",
        "\n",
        "\n",
        "      input_sequence_length = 0# len(max(X_train_photon_ckov_segmented, key=len))\n",
        "\n",
        "      model, history, variables = self.build_model(input_sequence_length = input_sequence_length, X_train = X_train, X_test = X_test, y_train = y_train, y_test = y_test, mask = mask, epochs = num_epochs , include_cnn = include_cnn, units = units, units2 = units2, CNN_units = CNN_units)\n",
        "\n",
        "\n",
        "\n",
        "      try:\n",
        "        history = self.train_model(X_train, X_test, y_train, y_test)\n",
        "        self.evaluate_model(X_test, y_test)\n",
        "      except Exception as e:\n",
        "        print(\"    def train(self, filename) failed at history = self.train_model bc of error : {e} \")\n",
        "\n",
        "      return model, history, variables #       variables = [train_variables, y_train, test_variables, y_test]\n",
        "\n",
        "      #plot_training_history(self, history, vector_of_weights, vector_of_weights2, dropout):\n",
        "      #self.plot_training_history(history)\n",
        "\n",
        "\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "PptqTnJ_2iyl"
      },
      "source": [
        "# Usage"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "dP4hLxCiN9SP",
        "outputId": "c35746f5-2805-4a6e-d43d-f4389931b4f5"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "classifier = MassClassifier(percentage_to_read = 100, resolution = 4) # pass percentage of dataset to read\n",
            "mv: cannot stat '/content/dataPions1.npz': No such file or directory\n",
            "Attempting to open: ['/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle__321_Ckov1725_1_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle__321_Ckov1725_18_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle__321_Ckov1725_19_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle__321_Ckov1725_20_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle__321_Ckov1725_21_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle__321_Ckov1725_22_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle__321_Ckov1725_23_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle2212_Ckov1725_0_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle2212_Ckov1725_1_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle2212_Ckov1725_2_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle2212_Ckov1725_3_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle2212_Ckov1725_4_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle2212_Ckov1725_5_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle2212_Ckov1725_6_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle2212_Ckov1725_7_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle2212_Ckov1725_8_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle2212_Ckov1725_9_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle2212_Ckov1725_10_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle2212_Ckov1725_11_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_9_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_10_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_11_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_12_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_13_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_14_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_15_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_16_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_1_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_4_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_2_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_5_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_0_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_3_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_8_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_6_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_7_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_17_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_18_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_19_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle__321_Ckov1725_0_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle__321_Ckov1725_1_ (1).h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle__321_Ckov1725_2_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle__321_Ckov1725_3_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle__321_Ckov1725_4_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle__321_Ckov1725_5_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle__321_Ckov1725_6_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle__321_Ckov1725_7_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle__321_Ckov1725_8_.h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_0_ (1).h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_1_ (1).h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_2_ (1).h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_3_ (1).h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_4_ (1).h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_5_ (1).h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_6_ (1).h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_7_ (1).h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_8_ (1).h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_9_ (1).h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_10_ (1).h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_11_ (1).h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_12_ (1).h5', '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/NewSegment/mCkov/Particle211_ckov1725_13_ (1).h5']\n",
            "MassClassifier __ load_data\n",
            "mip_mask_condition count_nonzero 8\n",
            "mip_mask_condition true_count_mip 8\n",
            "mip_mask_condition count_nonzero 13\n",
            "mip_mask_condition true_count_mip 13\n",
            "mip_mask_condition count_nonzero 46\n",
            "mip_mask_condition true_count_mip 46\n",
            "mip_mask_condition count_nonzero 49\n",
            "mip_mask_condition true_count_mip 49\n",
            "mip_mask_condition count_nonzero 52\n",
            "mip_mask_condition true_count_mip 52\n",
            "mip_mask_condition count_nonzero 55\n",
            "mip_mask_condition true_count_mip 55\n",
            "==================== Finisyhed LOOP ===============\n",
            "==================== Finisyhed all_events_data_dtype ===============\n",
            "\n",
            " 2nd LOOP \n",
            "num_proton_cands 1053 | num_kaon_cands 1301 | num_pion_cands 2669\n",
            "index_particle 0  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False  True False False False  True False\n",
            "  False  True  True False False False False False]]\n",
            "q_padded  [[ 47.  19.  35.  26.  19.  80. 310. 114.  51.  59. 789.  58.   8. 262.\n",
            "  536.  16.  41.   5.  60.  12.]]\n",
            "values_data_dict q_values  [ 47.  19.  35.  26.  19.  80. 310. 114.  51.  59. 789.  58.   8. 262.\n",
            " 536.  16.  41.   5.  60.  12.]\n",
            "size_padded  [[3. 2. 3. 2. 2. 4. 4. 4. 2. 2. 4. 2. 1. 7. 5. 2. 3. 1. 2. 1.]]\n",
            "values_data_dict mSize_values  [3. 2. 3. 2. 2. 4. 4. 4. 2. 2. 4. 2. 1. 7. 5. 2. 3. 1. 2. 1.]\n",
            "mip_mask_condition true_count_mip 8\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 13\n",
            "nonzero p_value[z_mask]: [[3]\n",
            " [3]\n",
            " [3]\n",
            " [3]\n",
            " [1]]\n",
            "nonzero p_value[mip_mask]: 13\n",
            "nonzero p_value[mip_mask]: [[3]\n",
            " [3]\n",
            " [3]\n",
            " [3]\n",
            " [1]]\n",
            "high_charge_size  [[0 0 0 0 0 0 1 0 0 0 1 0 0 1 1 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[  93.8546   76.355   310.        4.    ]\n",
            " [  96.8359   75.5416  789.        4.    ]\n",
            " [  96.108    73.9457  262.        7.    ]\n",
            " [  93.802    82.7142  536.        5.    ]\n",
            " [  60.0343    8.1466 1122.        7.    ]\n",
            " [  69.1148    8.5367  329.        4.    ]\n",
            " [  43.9449    7.8949  796.        8.    ]\n",
            " [  54.0516   11.6683  602.        5.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [11.]\n",
            "\tPDG [11.] wrong >> skip\n",
            "index_particle 1  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False False False False\n",
            "   True False False False False False False False]]\n",
            "q_padded  [[  7.  49.  70.  45.  19.  76.  14.  27.  68.   7. 100.  24. 865.   8.\n",
            "    5.  79. 119.  15.  52. 156.]]\n",
            "values_data_dict q_values  [  7.  49.  70.  45.  19.  76.  14.  27.  68.   7. 100.  24. 865.   8.\n",
            "   5.  79. 119.  15.  52. 156.]\n",
            "size_padded  [[1. 2. 3. 2. 1. 2. 2. 2. 3. 1. 4. 3. 4. 1. 1. 5. 4. 1. 3. 6.]]\n",
            "values_data_dict mSize_values  [1. 2. 3. 2. 1. 2. 2. 2. 3. 1. 4. 3. 4. 1. 1. 5. 4. 1. 3. 6.]\n",
            "mip_mask_condition true_count_mip 13\n"
          ]
        },
        {
          "output_type": "stream",
          "name": "stderr",
          "text": [
            "<ipython-input-235-3dcd8be79f06>:59: RuntimeWarning: invalid value encountered in sqrt\n",
            "  p_lim = masses/np.sqrt(refractive_indices**2 - 1)\n",
            "<ipython-input-235-3dcd8be79f06>:76: RuntimeWarning: divide by zero encountered in divide\n",
            "  cos_theta_c_hyps = np.sqrt(p_squared_plus_m_squared) / (momentums * refractive_indices)\n",
            "<ipython-input-235-3dcd8be79f06>:196: RuntimeWarning: divide by zero encountered in divide\n",
            "  z = (theta_c_hyps_expanded[:num_tracks,:,:] - theta_cer_padded_expanded) / sigma_ring_padded_expanded  # Broadcasting\n",
            "<ipython-input-235-3dcd8be79f06>:277: RuntimeWarning: invalid value encountered in divide\n",
            "  p_specie_per_track = p_value / np.sum(p_value, axis=2, keepdims=True)\n",
            "<ipython-input-235-3dcd8be79f06>:196: RuntimeWarning: invalid value encountered in divide\n",
            "  z = (theta_c_hyps_expanded[:num_tracks,:,:] - theta_cer_padded_expanded) / sigma_ring_padded_expanded  # Broadcasting\n"
          ]
        },
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "\u001b[1;30;43mStreaming output truncated to the last 5000 lines.\u001b[0m\n",
            "  31.  66.  37.  16.  19.  29.]\n",
            "size_padded  [[1. 2. 4. 4. 1. 1. 1. 4. 3. 1. 3. 3. 2. 2. 3. 4. 2. 2. 2. 2.]]\n",
            "values_data_dict mSize_values  [1. 2. 4. 4. 1. 1. 1. 4. 3. 1. 3. 3. 2. 2. 3. 4. 2. 2. 2. 2.]\n",
            "mip_mask_condition true_count_mip 5\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 63\n",
            "nonzero p_value[z_mask]: [[19]\n",
            " [19]\n",
            " [18]\n",
            " [ 6]\n",
            " [ 1]]\n",
            "nonzero p_value[mip_mask]: 63\n",
            "nonzero p_value[mip_mask]: [[19]\n",
            " [19]\n",
            " [18]\n",
            " [ 6]\n",
            " [ 1]]\n",
            "high_charge_size  [[0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[ 115.9902   75.218   701.        4.    ]\n",
            " [ 128.1671   18.5232  717.        4.    ]\n",
            " [  28.6854   17.7336 1061.        4.    ]\n",
            " [  86.9803   75.7021  308.        4.    ]\n",
            " [  80.3793   69.114   233.        4.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 628  num_tracks_in_event 1\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False  True False False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[ 28.  48.  13. 199.  16. 303.  17.  10.  17.  25.   6.  29.   5.  12.\n",
            "   18.  22.  83.  33.  19.  40.]]\n",
            "values_data_dict q_values  [ 28.  48.  13. 199.  16. 303.  17.  10.  17.  25.   6.  29.   5.  12.\n",
            "  18.  22.  83.  33.  19.  40.]\n",
            "size_padded  [[2. 2. 1. 3. 2. 4. 1. 1. 1. 1. 1. 2. 1. 1. 1. 2. 3. 2. 2. 1.]]\n",
            "values_data_dict mSize_values  [2. 2. 1. 3. 2. 4. 1. 1. 1. 1. 1. 2. 1. 1. 1. 2. 3. 2. 2. 1.]\n",
            "mip_mask_condition true_count_mip 2\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (2, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (2, 550, 5)\n",
            "shape of z-score array: (2, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 5500\n",
            "nonzero p_value: [[1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]]\n",
            "nonzero p_value[z_mask]: 65\n",
            "nonzero p_value[z_mask]: [[16]\n",
            " [16]\n",
            " [16]\n",
            " [13]\n",
            " [ 4]]\n",
            "nonzero p_value[mip_mask]: 65\n",
            "nonzero p_value[mip_mask]: [[16]\n",
            " [16]\n",
            " [16]\n",
            " [13]\n",
            " [ 4]]\n",
            "high_charge_size  [[0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n",
            " [0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 1\n",
            "mips [[  2.5069  66.2844 303.       4.    ]\n",
            " [ 85.645   99.4074 487.       4.    ]]\n",
            "L_all_tracks (550, 2) \n",
            "pion_mask2.shape (550, 2, 12)\n",
            "index 0 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 16 num_kaons 13 num_protons 4\n",
            "index 1 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 630  num_tracks_in_event 1\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False  True False False False  True\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[  24.   76.   26.   75.    5.   62.   51. 2037.  137.   12.   23.  644.\n",
            "   156.   35.   21.   11.  135.   30.    7.   14.]]\n",
            "values_data_dict q_values  [  24.   76.   26.   75.    5.   62.   51. 2037.  137.   12.   23.  644.\n",
            "  156.   35.   21.   11.  135.   30.    7.   14.]\n",
            "size_padded  [[1. 3. 1. 2. 1. 2. 2. 8. 4. 1. 1. 5. 3. 2. 1. 1. 3. 2. 1. 2.]]\n",
            "values_data_dict mSize_values  [1. 3. 1. 2. 1. 2. 2. 8. 4. 1. 1. 5. 3. 2. 1. 1. 3. 2. 1. 2.]\n",
            "mip_mask_condition true_count_mip 9\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (2, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (2, 550, 5)\n",
            "shape of z-score array: (2, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 5500\n",
            "nonzero p_value: [[1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]]\n",
            "nonzero p_value[z_mask]: 67\n",
            "nonzero p_value[z_mask]: [[18]\n",
            " [18]\n",
            " [18]\n",
            " [13]\n",
            " [ 0]]\n",
            "nonzero p_value[mip_mask]: 67\n",
            "nonzero p_value[mip_mask]: [[18]\n",
            " [18]\n",
            " [18]\n",
            " [13]\n",
            " [ 0]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0]\n",
            " [0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 1\n",
            "mips [[6.9422e+01 1.2375e+02 2.0370e+03 8.0000e+00]\n",
            " [3.7136e+01 1.6551e+01 6.4400e+02 5.0000e+00]\n",
            " [7.1476e+01 6.3348e+01 1.2270e+03 5.0000e+00]\n",
            " [1.1639e+02 1.2299e+02 6.2100e+02 4.0000e+00]\n",
            " [1.1512e+02 1.2165e+02 1.3190e+03 6.0000e+00]\n",
            " [1.1196e+02 1.2502e+02 9.2800e+02 6.0000e+00]\n",
            " [2.0831e+01 9.7813e+01 8.1900e+02 4.0000e+00]\n",
            " [4.8667e+00 1.0909e+02 7.1270e+03 8.0000e+00]\n",
            " [1.0709e+02 1.1790e+02 2.2400e+02 3.0000e+00]]\n",
            "L_all_tracks (550, 2) \n",
            "pion_mask2.shape (550, 2, 12)\n",
            "index 0 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 18 num_kaons 13 num_protons 0\n",
            "index 1 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 631  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False  True False False\n",
            "  False False  True False False False False False]]\n",
            "q_padded  [[ 46. 102.  62.  45. 194.  41.  35.  44.  18. 203.  14.  89.  88.  60.\n",
            "  476.   9. 136. 122.  39.   4.]]\n",
            "values_data_dict q_values  [ 46. 102.  62.  45. 194.  41.  35.  44.  18. 203.  14.  89.  88.  60.\n",
            " 476.   9. 136. 122.  39.   4.]\n",
            "size_padded  [[2. 4. 4. 2. 3. 2. 2. 2. 1. 3. 1. 3. 2. 2. 4. 1. 3. 3. 1. 1.]]\n",
            "values_data_dict mSize_values  [2. 4. 4. 2. 3. 2. 2. 2. 1. 3. 1. 3. 2. 2. 4. 1. 3. 3. 1. 1.]\n",
            "mip_mask_condition true_count_mip 4\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 47\n",
            "nonzero p_value[z_mask]: [[ 9]\n",
            " [10]\n",
            " [10]\n",
            " [11]\n",
            " [ 7]]\n",
            "nonzero p_value[mip_mask]: 47\n",
            "nonzero p_value[mip_mask]: [[ 9]\n",
            " [10]\n",
            " [10]\n",
            " [11]\n",
            " [ 7]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[ 50.0958 115.2994 203.       3.    ]\n",
            " [ 20.0793  51.3123 476.       4.    ]\n",
            " [ 41.4579  48.8668 431.       4.    ]\n",
            " [ 42.4969 119.649  540.       4.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 635  num_tracks_in_event 3\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False  True  True  True  True\n",
            "   True False False False False False False False]]\n",
            "q_padded  [[  38.   34.   18.   70.   31.  120.    4.  707.  753.  486. 1094.  435.\n",
            "   695.   12.    4.   51.   10.  115.   33.   16.]]\n",
            "values_data_dict q_values  [  38.   34.   18.   70.   31.  120.    4.  707.  753.  486. 1094.  435.\n",
            "  695.   12.    4.   51.   10.  115.   33.   16.]\n",
            "size_padded  [[2. 1. 1. 2. 1. 3. 1. 2. 4. 4. 6. 4. 6. 1. 1. 2. 2. 3. 2. 2.]]\n",
            "values_data_dict mSize_values  [2. 1. 1. 2. 1. 3. 1. 2. 4. 4. 6. 4. 6. 1. 1. 2. 2. 3. 2. 2.]\n",
            "mip_mask_condition true_count_mip 32\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (4, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (4, 550, 5)\n",
            "shape of z-score array: (4, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 11000\n",
            "nonzero p_value: [[2200]\n",
            " [2200]\n",
            " [2200]\n",
            " [2200]\n",
            " [2200]]\n",
            "nonzero p_value[z_mask]: 346\n",
            "nonzero p_value[z_mask]: [[88]\n",
            " [89]\n",
            " [90]\n",
            " [60]\n",
            " [19]]\n",
            "nonzero p_value[mip_mask]: 346\n",
            "nonzero p_value[mip_mask]: [[88]\n",
            " [89]\n",
            " [90]\n",
            " [60]\n",
            " [19]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 0 0]\n",
            " [0 0 0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 0 0]\n",
            " [0 0 0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 0 0]\n",
            " [0 0 0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 3\n",
            "mips [[1.1516e+02 8.0718e+01 7.5300e+02 4.0000e+00]\n",
            " [1.2419e+02 7.1284e+01 4.8600e+02 4.0000e+00]\n",
            " [1.2503e+02 7.6953e+01 1.0940e+03 6.0000e+00]\n",
            " [1.2352e+02 7.7778e+01 4.3500e+02 4.0000e+00]\n",
            " [1.2635e+02 7.5399e+01 6.9500e+02 6.0000e+00]\n",
            " [7.8369e+01 1.1713e+02 2.5600e+02 3.0000e+00]\n",
            " [9.5159e+00 6.8826e+01 3.7320e+03 7.0000e+00]\n",
            " [4.6563e+00 5.8688e+01 2.4000e+02 3.0000e+00]\n",
            " [5.4801e+00 3.1658e+01 3.6470e+03 7.0000e+00]\n",
            " [8.6258e+00 4.3387e+01 5.1000e+02 3.0000e+00]\n",
            " [5.3290e+01 9.0936e+01 1.1830e+03 7.0000e+00]\n",
            " [1.1643e+01 5.3858e+01 5.6100e+02 3.0000e+00]\n",
            " [1.2625e+01 5.6390e+01 3.4720e+03 6.0000e+00]\n",
            " [7.2286e+00 1.0786e+01 1.0020e+03 5.0000e+00]\n",
            " [1.0414e+02 8.2556e+01 6.2700e+02 4.0000e+00]\n",
            " [7.9579e+01 6.1326e+01 2.4670e+03 6.0000e+00]\n",
            " [6.7505e+01 6.4626e+01 2.1800e+02 7.0000e+00]\n",
            " [8.1027e-01 2.2402e+01 1.7970e+03 6.0000e+00]\n",
            " [8.9140e+00 2.3057e+01 5.9570e+03 1.0000e+01]\n",
            " [3.6921e+00 2.5100e+01 8.5700e+02 5.0000e+00]]\n",
            "L_all_tracks (550, 4) \n",
            "pion_mask2.shape (550, 4, 12)\n",
            "index 0 of 3 : pdg [2212.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [2212.] passed treshold momentum\n",
            "PDG [2212.] non_zero_val 4 < num_phot_thresh [8.]\n",
            "PDG [2212.] num_photon_in_half 2 < num_phot_half_thresh [3.]\n",
            "index 1 of 3 : pdg [11.]\n",
            "\tPDG [11.] wrong >> skip\n",
            "index 2 of 3 : pdg [2212.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [2212.] passed treshold momentum\n",
            "PDG [2212.] non_zero_val 7 < num_phot_thresh [8.]\n",
            "PDG [2212.] num_photon_in_half 4 < num_phot_half_thresh [3.]\n",
            "index 3 of 3 : pdg [2212.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [2212.] passed treshold momentum\n",
            "PDG [2212.] non_zero_val 0 < num_phot_thresh [8.]\n",
            "PDG [2212.] num_photon_in_half 0 < num_phot_half_thresh [3.]\n",
            "index_particle 636  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False  True False False False False False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[ 26.   7. 320.  33.  10.  76.  14.  41. 116.  19.  25. 166.  13.  17.\n",
            "   31.  50.  33.  21.  41.  23.]]\n",
            "values_data_dict q_values  [ 26.   7. 320.  33.  10.  76.  14.  41. 116.  19.  25. 166.  13.  17.\n",
            "  31.  50.  33.  21.  41.  23.]\n",
            "size_padded  [[1. 1. 4. 3. 1. 3. 2. 2. 5. 1. 2. 3. 1. 2. 2. 3. 1. 2. 2. 1.]]\n",
            "values_data_dict mSize_values  [1. 1. 4. 3. 1. 3. 2. 2. 5. 1. 2. 3. 1. 2. 2. 3. 1. 2. 2. 1.]\n",
            "mip_mask_condition true_count_mip 4\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 46\n",
            "nonzero p_value[z_mask]: [[12]\n",
            " [12]\n",
            " [12]\n",
            " [10]\n",
            " [ 0]]\n",
            "nonzero p_value[mip_mask]: 46\n",
            "nonzero p_value[mip_mask]: [[12]\n",
            " [12]\n",
            " [12]\n",
            " [10]\n",
            " [ 0]]\n",
            "high_charge_size  [[0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[6.8199e+01 3.9915e+01 3.2000e+02 4.0000e+00]\n",
            " [4.4411e+01 5.9374e+01 6.7600e+02 5.0000e+00]\n",
            " [9.1118e+01 1.0923e+02 2.1600e+02 3.0000e+00]\n",
            " [1.0289e+02 1.2419e+02 4.8680e+03 6.0000e+00]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 12 num_kaons 10 num_protons 0\n",
            "index_particle 637  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False  True False False False False False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[ 44.  12. 992.  87.  87.  63.   7.  60.  94.  16.  26.  51.  49.   7.\n",
            "   18.  37.   4.  18. 164.  22.]]\n",
            "values_data_dict q_values  [ 44.  12. 992.  87.  87.  63.   7.  60.  94.  16.  26.  51.  49.   7.\n",
            "  18.  37.   4.  18. 164.  22.]\n",
            "size_padded  [[2. 1. 5. 3. 2. 2. 1. 2. 3. 2. 2. 2. 3. 1. 2. 2. 1. 2. 3. 1.]]\n",
            "values_data_dict mSize_values  [2. 1. 5. 3. 2. 2. 1. 2. 3. 2. 2. 2. 3. 1. 2. 2. 1. 2. 3. 1.]\n",
            "mip_mask_condition true_count_mip 5\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 31\n",
            "nonzero p_value[z_mask]: [[9]\n",
            " [8]\n",
            " [7]\n",
            " [6]\n",
            " [1]]\n",
            "nonzero p_value[mip_mask]: 31\n",
            "nonzero p_value[mip_mask]: [[9]\n",
            " [8]\n",
            " [7]\n",
            " [6]\n",
            " [1]]\n",
            "high_charge_size  [[0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[ 48.1631  59.11   992.       5.    ]\n",
            " [ 60.3073 106.2218 648.       5.    ]\n",
            " [ 32.4153  23.8753 673.       5.    ]\n",
            " [ 49.1339   3.0494 301.       3.    ]\n",
            " [123.4884   8.181  246.       4.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 638  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False  True False False False False False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[  11.    5. 1120.   53.   20.   47.   61.   61.  144.   13.  174.   16.\n",
            "    43.   22.   24.   22.   15.   14.   48.   31.]]\n",
            "values_data_dict q_values  [  11.    5. 1120.   53.   20.   47.   61.   61.  144.   13.  174.   16.\n",
            "   43.   22.   24.   22.   15.   14.   48.   31.]\n",
            "size_padded  [[1. 1. 6. 4. 1. 2. 4. 2. 2. 1. 4. 1. 2. 1. 1. 1. 1. 1. 2. 2.]]\n",
            "values_data_dict mSize_values  [1. 1. 6. 4. 1. 2. 4. 2. 2. 1. 4. 1. 2. 1. 1. 1. 1. 1. 2. 2.]\n",
            "mip_mask_condition true_count_mip 3\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 32\n",
            "nonzero p_value[z_mask]: [[7]\n",
            " [8]\n",
            " [8]\n",
            " [6]\n",
            " [3]]\n",
            "nonzero p_value[mip_mask]: 32\n",
            "nonzero p_value[mip_mask]: [[7]\n",
            " [8]\n",
            " [8]\n",
            " [6]\n",
            " [3]]\n",
            "high_charge_size  [[0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[ 119.2947   89.674  1120.        6.    ]\n",
            " [ 130.1549    7.2862  304.        3.    ]\n",
            " [ 111.5619   58.3985  875.        5.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 639  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False  True False False False False False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[155.   6. 511.   5.  31.  52. 121.  25.  25.  48. 107.  71.  79.  35.\n",
            "   59.  32.  17.  37.  47.  54.]]\n",
            "values_data_dict q_values  [155.   6. 511.   5.  31.  52. 121.  25.  25.  48. 107.  71.  79.  35.\n",
            "  59.  32.  17.  37.  47.  54.]\n",
            "size_padded  [[3. 1. 5. 1. 2. 2. 7. 1. 4. 3. 2. 3. 1. 2. 2. 3. 1. 2. 4. 4.]]\n",
            "values_data_dict mSize_values  [3. 1. 5. 1. 2. 2. 7. 1. 4. 3. 2. 3. 1. 2. 2. 3. 1. 2. 4. 4.]\n",
            "mip_mask_condition true_count_mip 6\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 81\n",
            "nonzero p_value[z_mask]: [[22]\n",
            " [22]\n",
            " [21]\n",
            " [16]\n",
            " [ 0]]\n",
            "nonzero p_value[mip_mask]: 81\n",
            "nonzero p_value[mip_mask]: [[22]\n",
            " [22]\n",
            " [21]\n",
            " [16]\n",
            " [ 0]]\n",
            "high_charge_size  [[0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[1.7911e+01 1.6480e+01 5.1100e+02 5.0000e+00]\n",
            " [3.4702e+01 4.4576e+01 1.1020e+03 6.0000e+00]\n",
            " [3.8441e+01 2.3648e+01 1.0000e+04 9.0000e+00]\n",
            " [6.7077e+01 6.0058e+01 6.8800e+02 4.0000e+00]\n",
            " [4.0966e+01 6.3943e+01 2.5200e+02 4.0000e+00]\n",
            " [2.5467e+01 3.2578e+01 5.6040e+03 8.0000e+00]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 21 num_kaons 16 num_protons 0\n",
            "index_particle 641  num_tracks_in_event 1\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False  True False False False False False False  True False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[ 59. 230.  11.   6.   4.  10.  18.  60. 284.  69. 152.  69.  27. 106.\n",
            "   35.  52.  60.  23.  17.   4.]]\n",
            "values_data_dict q_values  [ 59. 230.  11.   6.   4.  10.  18.  60. 284.  69. 152.  69.  27. 106.\n",
            "  35.  52.  60.  23.  17.   4.]\n",
            "size_padded  [[1. 3. 2. 1. 1. 1. 2. 3. 4. 3. 3. 3. 1. 2. 2. 2. 3. 3. 1. 1.]]\n",
            "values_data_dict mSize_values  [1. 3. 2. 1. 1. 1. 2. 3. 4. 3. 3. 3. 1. 2. 2. 2. 3. 3. 1. 1.]\n",
            "mip_mask_condition true_count_mip 12\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (2, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (2, 550, 5)\n",
            "shape of z-score array: (2, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 5500\n",
            "nonzero p_value: [[1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]]\n",
            "nonzero p_value[z_mask]: 58\n",
            "nonzero p_value[z_mask]: [[12]\n",
            " [12]\n",
            " [13]\n",
            " [14]\n",
            " [ 7]]\n",
            "nonzero p_value[mip_mask]: 58\n",
            "nonzero p_value[mip_mask]: [[12]\n",
            " [12]\n",
            " [13]\n",
            " [14]\n",
            " [ 7]]\n",
            "high_charge_size  [[0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0]\n",
            " [0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 1\n",
            "mips [[8.7981e+01 2.4087e+01 2.3000e+02 3.0000e+00]\n",
            " [1.0810e+02 2.5803e+01 2.8400e+02 4.0000e+00]\n",
            " [1.1410e+02 1.6323e+01 4.5700e+02 3.0000e+00]\n",
            " [9.7150e+01 2.6265e+01 2.9400e+02 4.0000e+00]\n",
            " [6.3444e+01 8.8628e+01 2.4020e+03 5.0000e+00]\n",
            " [1.7810e+00 2.2567e+01 5.0000e+02 4.0000e+00]\n",
            " [4.6137e+01 4.3558e+01 3.0730e+03 5.0000e+00]\n",
            " [3.9104e+01 4.6151e+01 2.0500e+02 4.0000e+00]\n",
            " [3.3921e+01 2.7656e+01 2.9900e+02 4.0000e+00]\n",
            " [4.4028e+01 2.2275e+01 4.8400e+02 6.0000e+00]\n",
            " [1.0134e+02 5.1676e+01 6.8000e+02 5.0000e+00]\n",
            " [1.0805e+02 3.0171e+01 3.0800e+02 4.0000e+00]]\n",
            "L_all_tracks (550, 2) \n",
            "pion_mask2.shape (550, 2, 12)\n",
            "index 0 of 1 : pdg [50000050.]\n",
            "\tPDG [50000050.] wrong >> skip\n",
            "index 1 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 642  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False  True False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[ 14.  30.  62.  80.   6.   4. 597.  94.   8.  26.  11.  49.  34.  77.\n",
            "   70.  13.   4.   4.  18. 110.]]\n",
            "values_data_dict q_values  [ 14.  30.  62.  80.   6.   4. 597.  94.   8.  26.  11.  49.  34.  77.\n",
            "  70.  13.   4.   4.  18. 110.]\n",
            "size_padded  [[2. 1. 1. 2. 1. 1. 5. 3. 1. 2. 2. 2. 3. 2. 2. 1. 1. 1. 2. 4.]]\n",
            "values_data_dict mSize_values  [2. 1. 1. 2. 1. 1. 5. 3. 1. 2. 2. 2. 3. 2. 2. 1. 1. 1. 2. 4.]\n",
            "mip_mask_condition true_count_mip 3\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 78\n",
            "nonzero p_value[z_mask]: [[18]\n",
            " [18]\n",
            " [18]\n",
            " [20]\n",
            " [ 4]]\n",
            "nonzero p_value[mip_mask]: 78\n",
            "nonzero p_value[mip_mask]: [[18]\n",
            " [18]\n",
            " [18]\n",
            " [20]\n",
            " [ 4]]\n",
            "high_charge_size  [[0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[ 85.594   53.5284 597.       5.    ]\n",
            " [ 15.8047 120.1851 726.       4.    ]\n",
            " [104.6802  58.2502 554.       4.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 18 num_kaons 20 num_protons 4\n",
            "index_particle 645  num_tracks_in_event 2\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False  True False False False False False False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[100. 228.   4.  32.  66.  50.   9.   7.  15.  84.  38.  14.  95.  24.\n",
            "   17.   7. 161.  48.  21.  16.]]\n",
            "values_data_dict q_values  [100. 228.   4.  32.  66.  50.   9.   7.  15.  84.  38.  14.  95.  24.\n",
            "  17.   7. 161.  48.  21.  16.]\n",
            "size_padded  [[4. 3. 1. 2. 4. 1. 1. 1. 2. 2. 2. 2. 2. 1. 2. 1. 3. 2. 1. 1.]]\n",
            "values_data_dict mSize_values  [4. 3. 1. 2. 4. 1. 1. 1. 2. 2. 2. 2. 2. 1. 2. 1. 3. 2. 1. 1.]\n",
            "mip_mask_condition true_count_mip 8\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (3, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (3, 550, 5)\n",
            "shape of z-score array: (3, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 8250\n",
            "nonzero p_value: [[1650]\n",
            " [1650]\n",
            " [1650]\n",
            " [1650]\n",
            " [1650]]\n",
            "nonzero p_value[z_mask]: 72\n",
            "nonzero p_value[z_mask]: [[16]\n",
            " [17]\n",
            " [17]\n",
            " [17]\n",
            " [ 5]]\n",
            "nonzero p_value[mip_mask]: 72\n",
            "nonzero p_value[mip_mask]: [[16]\n",
            " [17]\n",
            " [17]\n",
            " [17]\n",
            " [ 5]]\n",
            "high_charge_size  [[0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n",
            " [0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n",
            " [0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 2\n",
            "mips [[8.6707e+00 2.3031e+01 2.2800e+02 3.0000e+00]\n",
            " [1.2458e+02 1.2145e+02 6.1100e+02 5.0000e+00]\n",
            " [1.3783e+01 2.5082e+01 4.0600e+02 4.0000e+00]\n",
            " [1.2450e+02 7.7597e+01 2.0400e+03 8.0000e+00]\n",
            " [7.8057e+01 1.0461e+02 7.4000e+02 6.0000e+00]\n",
            " [1.0075e+02 5.6615e+01 5.9100e+02 5.0000e+00]\n",
            " [3.4419e+01 8.7968e+01 1.1163e+04 9.0000e+00]\n",
            " [6.0235e+01 6.1165e+01 5.1800e+02 4.0000e+00]]\n",
            "L_all_tracks (550, 3) \n",
            "pion_mask2.shape (550, 3, 12)\n",
            "index 0 of 2 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index 1 of 2 : pdg [50000050.]\n",
            "\tPDG [50000050.] wrong >> skip\n",
            "index 2 of 2 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 646  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False False False False\n",
            "  False  True False False False False False False]]\n",
            "q_padded  [[ 20. 167.  35.   9.  13.  98.  17.  19.  30.  54.  58.  57.  35. 308.\n",
            "   85.  43.  33.  10.  12.  56.]]\n",
            "values_data_dict q_values  [ 20. 167.  35.   9.  13.  98.  17.  19.  30.  54.  58.  57.  35. 308.\n",
            "  85.  43.  33.  10.  12.  56.]\n",
            "size_padded  [[3. 3. 2. 1. 4. 3. 1. 2. 2. 2. 3. 4. 3. 4. 2. 2. 2. 1. 1. 3.]]\n",
            "values_data_dict mSize_values  [3. 3. 2. 1. 4. 3. 1. 2. 2. 2. 3. 4. 3. 4. 2. 2. 2. 1. 1. 3.]\n",
            "mip_mask_condition true_count_mip 4\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 12\n",
            "nonzero p_value[z_mask]: [[5]\n",
            " [4]\n",
            " [3]\n",
            " [0]\n",
            " [0]]\n",
            "nonzero p_value[mip_mask]: 12\n",
            "nonzero p_value[mip_mask]: [[5]\n",
            " [4]\n",
            " [3]\n",
            " [0]\n",
            " [0]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[ 84.2991  20.9698 308.       4.    ]\n",
            " [103.7037 109.4582 743.       5.    ]\n",
            " [ 45.7422  35.955  216.       4.    ]\n",
            " [ 37.5535  26.9759 447.       4.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 647  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False  True False False False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[ 84.  70.  67.   4. 977.  27.   5.  37.  15.  47.   5.  99. 146. 130.\n",
            "    7. 163.  25.  16.   4.  10.]]\n",
            "values_data_dict q_values  [ 84.  70.  67.   4. 977.  27.   5.  37.  15.  47.   5.  99. 146. 130.\n",
            "   7. 163.  25.  16.   4.  10.]\n",
            "size_padded  [[3. 2. 4. 1. 5. 2. 1. 1. 2. 4. 1. 2. 3. 4. 1. 6. 1. 1. 1. 1.]]\n",
            "values_data_dict mSize_values  [3. 2. 4. 1. 5. 2. 1. 1. 2. 4. 1. 2. 3. 4. 1. 6. 1. 1. 1. 1.]\n",
            "mip_mask_condition true_count_mip 2\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 104\n",
            "nonzero p_value[z_mask]: [[26]\n",
            " [26]\n",
            " [25]\n",
            " [24]\n",
            " [ 3]]\n",
            "nonzero p_value[mip_mask]: 104\n",
            "nonzero p_value[mip_mask]: [[26]\n",
            " [26]\n",
            " [25]\n",
            " [24]\n",
            " [ 3]]\n",
            "high_charge_size  [[0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[  97.5811   75.8095  977.        5.    ]\n",
            " [  68.9511   76.1353 1550.        6.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 25 num_kaons 24 num_protons 3\n",
            "index_particle 648  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False  True False False False False False False\n",
            "  False False False False False False False  True]]\n",
            "q_padded  [[  30.   52.   24.   19.   83.  614.   39.   17.   79.   52.   64.   66.\n",
            "     4.   82.    9.   93.  127.   38.    4. 3352.]]\n",
            "values_data_dict q_values  [  30.   52.   24.   19.   83.  614.   39.   17.   79.   52.   64.   66.\n",
            "    4.   82.    9.   93.  127.   38.    4. 3352.]\n",
            "size_padded  [[2. 2. 2. 1. 3. 4. 2. 2. 2. 2. 1. 2. 1. 3. 2. 4. 3. 3. 1. 7.]]\n",
            "values_data_dict mSize_values  [2. 2. 2. 1. 3. 4. 2. 2. 2. 2. 1. 2. 1. 3. 2. 4. 3. 3. 1. 7.]\n",
            "mip_mask_condition true_count_mip 7\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 26\n",
            "nonzero p_value[z_mask]: [[3]\n",
            " [4]\n",
            " [4]\n",
            " [6]\n",
            " [9]]\n",
            "nonzero p_value[mip_mask]: 26\n",
            "nonzero p_value[mip_mask]: [[3]\n",
            " [4]\n",
            " [4]\n",
            " [6]\n",
            " [9]]\n",
            "high_charge_size  [[0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1]]\n",
            "num_tracks_in_event 0\n",
            "mips [[4.0177e+01 9.9753e+01 6.1400e+02 4.0000e+00]\n",
            " [9.5781e+01 1.1997e+02 3.3520e+03 7.0000e+00]\n",
            " [3.3303e+01 9.2374e+01 2.2500e+02 3.0000e+00]\n",
            " [5.0227e+01 9.9436e+01 2.1100e+02 4.0000e+00]\n",
            " [4.8832e+01 9.8064e+01 2.0400e+02 3.0000e+00]\n",
            " [4.8000e+01 8.3225e+00 4.6400e+02 4.0000e+00]\n",
            " [2.6329e+01 6.0645e+01 7.2000e+02 4.0000e+00]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 649  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False  True False False False False\n",
            "  False  True False False False False False False]]\n",
            "q_padded  [[ 114.   21.    5.   13.    5.    4.  103. 1167.   40.   31.   13.   53.\n",
            "    58.  246.   55.  141.   27.   24.   35.   39.]]\n",
            "values_data_dict q_values  [ 114.   21.    5.   13.    5.    4.  103. 1167.   40.   31.   13.   53.\n",
            "   58.  246.   55.  141.   27.   24.   35.   39.]\n",
            "size_padded  [[3. 2. 1. 2. 1. 1. 4. 6. 2. 2. 2. 2. 4. 8. 2. 3. 3. 1. 1. 3.]]\n",
            "values_data_dict mSize_values  [3. 2. 1. 2. 1. 1. 4. 6. 2. 2. 2. 2. 4. 8. 2. 3. 3. 1. 1. 3.]\n",
            "mip_mask_condition true_count_mip 4\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 9\n",
            "nonzero p_value[z_mask]: [[2]\n",
            " [2]\n",
            " [2]\n",
            " [2]\n",
            " [1]]\n",
            "nonzero p_value[mip_mask]: 9\n",
            "nonzero p_value[mip_mask]: [[2]\n",
            " [2]\n",
            " [2]\n",
            " [2]\n",
            " [1]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[  14.5663  116.4978 1167.        6.    ]\n",
            " [  20.1085  110.6961  246.        8.    ]\n",
            " [ 107.3915   12.6706 1058.        4.    ]\n",
            " [ 104.5844   12.0304 1910.        6.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 651  num_tracks_in_event 1\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False  True False False False False False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[ 18.   6. 481. 122.  64.  18.  23.  14.  52.  18.  10. 100.   6.   5.\n",
            "   48.  13.  41.  40.   6.  29.]]\n",
            "values_data_dict q_values  [ 18.   6. 481. 122.  64.  18.  23.  14.  52.  18.  10. 100.   6.   5.\n",
            "  48.  13.  41.  40.   6.  29.]\n",
            "size_padded  [[1. 1. 4. 4. 4. 1. 2. 2. 1. 1. 2. 2. 1. 1. 2. 1. 4. 3. 1. 2.]]\n",
            "values_data_dict mSize_values  [1. 1. 4. 4. 4. 1. 2. 2. 1. 1. 2. 2. 1. 1. 2. 1. 4. 3. 1. 2.]\n",
            "mip_mask_condition true_count_mip 8\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (2, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (2, 550, 5)\n",
            "shape of z-score array: (2, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 5500\n",
            "nonzero p_value: [[1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]]\n",
            "nonzero p_value[z_mask]: 26\n",
            "nonzero p_value[z_mask]: [[6]\n",
            " [6]\n",
            " [6]\n",
            " [5]\n",
            " [3]]\n",
            "nonzero p_value[mip_mask]: 26\n",
            "nonzero p_value[mip_mask]: [[6]\n",
            " [6]\n",
            " [6]\n",
            " [5]\n",
            " [3]]\n",
            "high_charge_size  [[0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n",
            " [0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 1\n",
            "mips [[  32.6872  114.2767  481.        4.    ]\n",
            " [  81.6233   91.2221 2067.        7.    ]\n",
            " [  30.31      9.9344  240.        4.    ]\n",
            " [  21.8774   13.9273  405.        4.    ]\n",
            " [  92.9398   48.8098  208.        4.    ]\n",
            " [  99.0736   55.756   222.        3.    ]\n",
            " [   7.1815   59.5503 1256.        4.    ]\n",
            " [ 128.5764   98.9455  218.        4.    ]]\n",
            "L_all_tracks (550, 2) \n",
            "pion_mask2.shape (550, 2, 12)\n",
            "index 0 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index 1 of 1 : pdg [50000050.]\n",
            "\tPDG [50000050.] wrong >> skip\n",
            "index_particle 652  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False False False  True\n",
            "  False False False  True False False False False]]\n",
            "q_padded  [[ 35.  88.  12. 133. 161.  13.  67.  30.  97.  42.  86. 509.  74.  64.\n",
            "   87. 278.  28.  68.  86.  32.]]\n",
            "values_data_dict q_values  [ 35.  88.  12. 133. 161.  13.  67.  30.  97.  42.  86. 509.  74.  64.\n",
            "  87. 278.  28.  68.  86.  32.]\n",
            "size_padded  [[1. 4. 2. 6. 9. 1. 3. 1. 4. 2. 4. 4. 3. 2. 2. 4. 2. 6. 5. 1.]]\n",
            "values_data_dict mSize_values  [1. 4. 2. 6. 9. 1. 3. 1. 4. 2. 4. 4. 3. 2. 2. 4. 2. 6. 5. 1.]\n",
            "mip_mask_condition true_count_mip 7\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 29\n",
            "nonzero p_value[z_mask]: [[7]\n",
            " [7]\n",
            " [7]\n",
            " [7]\n",
            " [1]]\n",
            "nonzero p_value[mip_mask]: 29\n",
            "nonzero p_value[mip_mask]: [[7]\n",
            " [7]\n",
            " [7]\n",
            " [7]\n",
            " [1]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[6.0213e+00 1.0788e+00 5.0900e+02 4.0000e+00]\n",
            " [1.2079e+02 1.8050e+01 2.7800e+02 4.0000e+00]\n",
            " [1.2337e+02 3.2015e+01 2.3300e+02 6.0000e+00]\n",
            " [1.7970e+01 9.6207e+01 6.1400e+02 5.0000e+00]\n",
            " [5.5924e+00 9.1424e+01 9.9500e+03 7.0000e+00]\n",
            " [1.0327e+02 1.1733e+02 3.1500e+02 4.0000e+00]\n",
            " [1.0449e+02 1.1491e+02 4.0620e+03 6.0000e+00]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 654  num_tracks_in_event 1\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False  True False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[  33.   36.  112.    4.   70.   55.   11.    5.    6. 2430.   16.   21.\n",
            "   118.   25.   41.   11.   74.   14.   26.   28.]]\n",
            "values_data_dict q_values  [  33.   36.  112.    4.   70.   55.   11.    5.    6. 2430.   16.   21.\n",
            "  118.   25.   41.   11.   74.   14.   26.   28.]\n",
            "size_padded  [[2. 2. 3. 1. 4. 2. 1. 1. 1. 7. 2. 2. 4. 2. 2. 1. 4. 1. 3. 2.]]\n",
            "values_data_dict mSize_values  [2. 2. 3. 1. 4. 2. 1. 1. 1. 7. 2. 2. 4. 2. 2. 1. 4. 1. 3. 2.]\n",
            "mip_mask_condition true_count_mip 11\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (2, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (2, 550, 5)\n",
            "shape of z-score array: (2, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 5500\n",
            "nonzero p_value: [[1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]]\n",
            "nonzero p_value[z_mask]: 63\n",
            "nonzero p_value[z_mask]: [[16]\n",
            " [16]\n",
            " [16]\n",
            " [15]\n",
            " [ 0]]\n",
            "nonzero p_value[mip_mask]: 63\n",
            "nonzero p_value[mip_mask]: [[16]\n",
            " [16]\n",
            " [16]\n",
            " [15]\n",
            " [ 0]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0]\n",
            " [0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 1\n",
            "mips [[1.4792e+00 1.8489e+01 2.4300e+03 7.0000e+00]\n",
            " [2.4721e+00 6.4415e+01 4.2600e+02 5.0000e+00]\n",
            " [1.2442e+02 1.1603e+02 7.4200e+02 4.0000e+00]\n",
            " [1.1868e+02 3.2790e+00 2.9100e+02 5.0000e+00]\n",
            " [8.2312e+00 9.7861e+00 7.9500e+02 6.0000e+00]\n",
            " [4.4428e+00 2.2545e+01 4.2900e+02 4.0000e+00]\n",
            " [2.2182e+01 1.1042e+02 2.3730e+03 6.0000e+00]\n",
            " [1.3009e+02 9.8493e+01 4.5400e+02 4.0000e+00]\n",
            " [1.1368e+01 1.1705e+02 2.0900e+02 3.2000e+01]\n",
            " [1.1136e+02 1.0978e+02 3.8100e+02 5.0000e+00]\n",
            " [1.9960e+01 1.1579e+02 9.1600e+02 5.0000e+00]]\n",
            "L_all_tracks (550, 2) \n",
            "pion_mask2.shape (550, 2, 12)\n",
            "index 0 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 16 num_kaons 15 num_protons 0\n",
            "index 1 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 655  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False  True False False False False False False False False\n",
            "  False  True False False False False  True False]]\n",
            "q_padded  [[  4.   8.  22. 244.  39. 103. 100.  11. 157.   9. 108.   5.  31. 246.\n",
            "    9.  13.  34.  20. 224.  75.]]\n",
            "values_data_dict q_values  [  4.   8.  22. 244.  39. 103. 100.  11. 157.   9. 108.   5.  31. 246.\n",
            "   9.  13.  34.  20. 224.  75.]\n",
            "size_padded  [[1. 1. 2. 5. 3. 4. 3. 1. 4. 1. 3. 1. 1. 4. 1. 1. 4. 1. 4. 4.]]\n",
            "values_data_dict mSize_values  [1. 1. 2. 5. 3. 4. 3. 1. 4. 1. 3. 1. 1. 4. 1. 1. 4. 1. 4. 4.]\n",
            "mip_mask_condition true_count_mip 5\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 39\n",
            "nonzero p_value[z_mask]: [[10]\n",
            " [10]\n",
            " [10]\n",
            " [ 9]\n",
            " [ 0]]\n",
            "nonzero p_value[mip_mask]: 39\n",
            "nonzero p_value[mip_mask]: [[10]\n",
            " [10]\n",
            " [10]\n",
            " [ 9]\n",
            " [ 0]]\n",
            "high_charge_size  [[0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[ 85.5727  37.7715 244.       5.    ]\n",
            " [  2.      72.011  246.       4.    ]\n",
            " [  9.5036  68.1988 224.       4.    ]\n",
            " [  7.9117  65.1462 699.       6.    ]\n",
            " [ 78.836   32.2802 935.       5.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 656  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False  True False False  True\n",
            "  False False False False False False False  True]]\n",
            "q_padded  [[ 19.   6.  43.   5. 106.  31.  52.  25. 670.  28.  14. 963.  29.  15.\n",
            "   44.   6.  51.   8.  39. 776.]]\n",
            "values_data_dict q_values  [ 19.   6.  43.   5. 106.  31.  52.  25. 670.  28.  14. 963.  29.  15.\n",
            "  44.   6.  51.   8.  39. 776.]\n",
            "size_padded  [[1. 1. 5. 1. 4. 1. 3. 2. 5. 3. 2. 5. 2. 1. 3. 1. 2. 2. 1. 5.]]\n",
            "values_data_dict mSize_values  [1. 1. 5. 1. 4. 1. 3. 2. 5. 3. 2. 5. 2. 1. 3. 1. 2. 2. 1. 5.]\n",
            "mip_mask_condition true_count_mip 7\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 0\n",
            "nonzero p_value[z_mask]: [[0]\n",
            " [0]\n",
            " [0]\n",
            " [0]\n",
            " [0]]\n",
            "nonzero p_value[mip_mask]: 0\n",
            "nonzero p_value[mip_mask]: [[0]\n",
            " [0]\n",
            " [0]\n",
            " [0]\n",
            " [0]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 1]]\n",
            "num_tracks_in_event 0\n",
            "mips [[ 82.1922  29.0765 670.       5.    ]\n",
            " [113.4027  89.5368 963.       5.    ]\n",
            " [ 46.6352  87.1238 776.       5.    ]\n",
            " [ 95.3333 124.3328 469.       4.    ]\n",
            " [103.2052 123.9851 666.       4.    ]\n",
            " [114.8517  57.3396 956.       5.    ]\n",
            " [ 98.492  116.8319 341.       4.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "PDG [211.] skip >> ckovRecon [-11.]\n",
            "index_particle 657  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False False  True False\n",
            "  False False False False False False  True False]]\n",
            "q_padded  [[  39.   14.   23.   11.   17.   59.   75.   38.   22.  417.  525.   38.\n",
            "    18.   30.  130.   62.   32.   16. 2600.    9.]]\n",
            "values_data_dict q_values  [  39.   14.   23.   11.   17.   59.   75.   38.   22.  417.  525.   38.\n",
            "   18.   30.  130.   62.   32.   16. 2600.    9.]\n",
            "size_padded  [[1. 1. 2. 2. 1. 2. 2. 2. 2. 2. 5. 1. 1. 2. 2. 3. 2. 1. 6. 1.]]\n",
            "values_data_dict mSize_values  [1. 1. 2. 2. 1. 2. 2. 2. 2. 2. 5. 1. 1. 2. 2. 3. 2. 1. 6. 1.]\n",
            "mip_mask_condition true_count_mip 19\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 47\n",
            "nonzero p_value[z_mask]: [[12]\n",
            " [12]\n",
            " [12]\n",
            " [11]\n",
            " [ 0]]\n",
            "nonzero p_value[mip_mask]: 47\n",
            "nonzero p_value[mip_mask]: [[12]\n",
            " [12]\n",
            " [12]\n",
            " [11]\n",
            " [ 0]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[1.2061e+02 6.0661e+01 5.2500e+02 5.0000e+00]\n",
            " [3.9563e+01 3.6622e+01 2.6000e+03 6.0000e+00]\n",
            " [3.4624e+01 6.7338e+01 2.5100e+02 4.0000e+00]\n",
            " [3.7828e+01 5.3854e+01 2.5300e+02 5.0000e+00]\n",
            " [2.1376e+01 8.6292e+01 9.5400e+02 4.0000e+00]\n",
            " [1.1740e+02 6.1437e+01 4.5320e+03 7.0000e+00]\n",
            " [4.4743e+01 6.1635e+01 2.5300e+02 4.0000e+00]\n",
            " [1.1763e+02 2.3370e+01 6.3400e+02 4.0000e+00]\n",
            " [8.6981e+01 3.9786e+00 7.2600e+02 5.0000e+00]\n",
            " [9.8136e+01 6.0689e+01 4.1900e+02 5.0000e+00]\n",
            " [1.2324e+02 1.0633e+02 7.2400e+02 6.0000e+00]\n",
            " [1.0079e+02 8.6988e+01 1.2670e+03 6.0000e+00]\n",
            " [2.5341e+01 5.5144e+01 1.9750e+03 6.0000e+00]\n",
            " [2.6058e+01 5.3290e+01 5.4300e+02 4.0000e+00]\n",
            " [2.3884e+01 6.1440e+01 1.2290e+03 8.0000e+00]\n",
            " [7.0032e+01 5.9638e+01 2.7700e+03 7.0000e+00]\n",
            " [7.1141e+01 5.9849e+01 2.5280e+03 7.0000e+00]\n",
            " [2.9745e+01 4.6100e+01 6.4420e+03 8.0000e+00]\n",
            " [1.0334e+01 5.2835e+01 8.0310e+03 8.0000e+00]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 12 num_kaons 11 num_protons 0\n",
            "index_particle 658  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False  True False False False False False  True False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[  76.   16.  646.   75.   30.   75.    5.   78. 2051.    5.   17.   13.\n",
            "   123.   47.   82.   19.   59.  187.   29.   49.]]\n",
            "values_data_dict q_values  [  76.   16.  646.   75.   30.   75.    5.   78. 2051.    5.   17.   13.\n",
            "  123.   47.   82.   19.   59.  187.   29.   49.]\n",
            "size_padded  [[ 4.  1.  5.  2.  2.  2.  1.  2. 10.  1.  2.  2.  3.  3.  3.  1.  2.  3.\n",
            "   2.  2.]]\n",
            "values_data_dict mSize_values  [ 4.  1.  5.  2.  2.  2.  1.  2. 10.  1.  2.  2.  3.  3.  3.  1.  2.  3.\n",
            "  2.  2.]\n",
            "mip_mask_condition true_count_mip 6\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 41\n",
            "nonzero p_value[z_mask]: [[10]\n",
            " [10]\n",
            " [10]\n",
            " [11]\n",
            " [ 0]]\n",
            "nonzero p_value[mip_mask]: 41\n",
            "nonzero p_value[mip_mask]: [[10]\n",
            " [10]\n",
            " [10]\n",
            " [11]\n",
            " [ 0]]\n",
            "high_charge_size  [[0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[  53.1288   13.8757  646.        5.    ]\n",
            " [  79.3381  108.0314 2051.       10.    ]\n",
            " [   9.9636   14.1248  258.        3.    ]\n",
            " [  24.799    28.6582  232.        4.    ]\n",
            " [  15.6644   25.0737  416.        5.    ]\n",
            " [  59.7198  110.8167  359.        3.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 661  num_tracks_in_event 2\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False  True False False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[ 75.  15.  44.  40.  45. 951.  54.  66. 113.  53.   5.  28.  26.   7.\n",
            "   58. 117.  27. 137.  46.  19.]]\n",
            "values_data_dict q_values  [ 75.  15.  44.  40.  45. 951.  54.  66. 113.  53.   5.  28.  26.   7.\n",
            "  58. 117.  27. 137.  46.  19.]\n",
            "size_padded  [[4. 1. 2. 2. 2. 5. 2. 2. 3. 2. 1. 2. 1. 1. 2. 3. 2. 4. 1. 4.]]\n",
            "values_data_dict mSize_values  [4. 1. 2. 2. 2. 5. 2. 2. 3. 2. 1. 2. 1. 1. 2. 3. 2. 4. 1. 4.]\n",
            "mip_mask_condition true_count_mip 9\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (3, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (3, 550, 5)\n",
            "shape of z-score array: (3, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 8250\n",
            "nonzero p_value: [[1650]\n",
            " [1650]\n",
            " [1650]\n",
            " [1650]\n",
            " [1650]]\n",
            "nonzero p_value[z_mask]: 109\n",
            "nonzero p_value[z_mask]: [[25]\n",
            " [25]\n",
            " [25]\n",
            " [22]\n",
            " [12]]\n",
            "nonzero p_value[mip_mask]: 109\n",
            "nonzero p_value[mip_mask]: [[25]\n",
            " [25]\n",
            " [25]\n",
            " [22]\n",
            " [12]]\n",
            "high_charge_size  [[0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n",
            " [0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n",
            " [0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 2\n",
            "mips [[ 18.6347  95.996  951.       5.    ]\n",
            " [ 57.8725 105.0919 661.       4.    ]\n",
            " [ 22.9268 112.985  281.       3.    ]\n",
            " [104.0667  88.8846 205.       8.    ]\n",
            " [116.4773  90.2398 592.       5.    ]\n",
            " [103.0969  97.3961 810.       6.    ]\n",
            " [  4.743   45.6776 618.       4.    ]\n",
            " [100.9458  61.3839 588.       4.    ]\n",
            " [122.5236  94.7867 976.       5.    ]]\n",
            "L_all_tracks (550, 3) \n",
            "pion_mask2.shape (550, 3, 12)\n",
            "index 0 of 2 : pdg [11.]\n",
            "\tPDG [11.] wrong >> skip\n",
            "index 1 of 2 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index 2 of 2 : pdg [211.]\n",
            "PDG [211.] skip >> ckovRecon [-11.]\n",
            "index_particle 662  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False  True False False False False False False False False False False\n",
            "  False False False False False False False  True]]\n",
            "q_padded  [[ 22. 223. 103.  57.  12.  14.  53.  23.  12.  13.  74.  34.  16.  73.\n",
            "   20. 147. 147.  31. 121. 531.]]\n",
            "values_data_dict q_values  [ 22. 223. 103.  57.  12.  14.  53.  23.  12.  13.  74.  34.  16.  73.\n",
            "  20. 147. 147.  31. 121. 531.]\n",
            "size_padded  [[1. 7. 3. 4. 1. 3. 2. 3. 1. 1. 3. 2. 1. 2. 3. 3. 3. 2. 4. 5.]]\n",
            "values_data_dict mSize_values  [1. 7. 3. 4. 1. 3. 2. 3. 1. 1. 3. 2. 1. 2. 3. 3. 3. 2. 4. 5.]\n",
            "mip_mask_condition true_count_mip 10\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 11\n",
            "nonzero p_value[z_mask]: [[3]\n",
            " [3]\n",
            " [3]\n",
            " [2]\n",
            " [0]]\n",
            "nonzero p_value[mip_mask]: 11\n",
            "nonzero p_value[mip_mask]: [[3]\n",
            " [3]\n",
            " [3]\n",
            " [2]\n",
            " [0]]\n",
            "high_charge_size  [[0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1]]\n",
            "num_tracks_in_event 0\n",
            "mips [[8.5703e+01 7.3879e+01 2.2300e+02 7.0000e+00]\n",
            " [7.2678e+01 7.2230e+01 5.3100e+02 5.0000e+00]\n",
            " [9.0023e+00 9.7783e+01 1.0670e+03 6.0000e+00]\n",
            " [7.1900e+01 3.4661e+01 2.0300e+02 3.0000e+00]\n",
            " [2.1527e+01 2.2760e+01 1.0760e+03 4.0000e+00]\n",
            " [1.3514e+01 2.1434e+01 6.2420e+03 7.0000e+00]\n",
            " [8.8986e+01 5.2760e+01 8.1500e+02 4.0000e+00]\n",
            " [2.8056e+01 4.1878e+00 7.4300e+02 4.0000e+00]\n",
            " [1.1020e+02 5.1287e+00 2.2700e+02 3.0000e+00]\n",
            " [1.0874e+02 2.4373e+00 6.6200e+02 4.0000e+00]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [50000050.]\n",
            "\tPDG [50000050.] wrong >> skip\n",
            "index_particle 663  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False  True False False False False False False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[1.210e+02 7.643e+03 3.600e+01 1.000e+01 4.400e+01 1.070e+02 2.400e+01\n",
            "  7.000e+01 6.700e+01 6.000e+00 1.200e+01 4.800e+01 1.800e+01 3.300e+01\n",
            "  6.400e+01 6.900e+01 7.800e+01 3.200e+01 2.800e+01 9.300e+01]]\n",
            "values_data_dict q_values  [1.210e+02 7.643e+03 3.600e+01 1.000e+01 4.400e+01 1.070e+02 2.400e+01\n",
            " 7.000e+01 6.700e+01 6.000e+00 1.200e+01 4.800e+01 1.800e+01 3.300e+01\n",
            " 6.400e+01 6.900e+01 7.800e+01 3.200e+01 2.800e+01 9.300e+01]\n",
            "size_padded  [[2. 7. 3. 1. 3. 3. 1. 2. 2. 1. 1. 3. 2. 1. 2. 3. 3. 2. 2. 2.]]\n",
            "values_data_dict mSize_values  [2. 7. 3. 1. 3. 3. 1. 2. 2. 1. 1. 3. 2. 1. 2. 3. 3. 2. 2. 2.]\n",
            "mip_mask_condition true_count_mip 2\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 50\n",
            "nonzero p_value[z_mask]: [[13]\n",
            " [13]\n",
            " [13]\n",
            " [11]\n",
            " [ 0]]\n",
            "nonzero p_value[mip_mask]: 50\n",
            "nonzero p_value[mip_mask]: [[13]\n",
            " [13]\n",
            " [13]\n",
            " [11]\n",
            " [ 0]]\n",
            "high_charge_size  [[0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[1.0238e+01 1.0262e+02 7.6430e+03 7.0000e+00]\n",
            " [8.2915e+01 6.4326e+01 7.2700e+02 5.0000e+00]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 13 num_kaons 11 num_protons 0\n",
            "index_particle 664  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False  True False False\n",
            "  False False False False False False False  True]]\n",
            "q_padded  [[ 85.  84. 117.  31.  84. 118.  54.   6.  17. 844.  25.  91.  32.  12.\n",
            "   18.  82.  48.  52.  35. 418.]]\n",
            "values_data_dict q_values  [ 85.  84. 117.  31.  84. 118.  54.   6.  17. 844.  25.  91.  32.  12.\n",
            "  18.  82.  48.  52.  35. 418.]\n",
            "size_padded  [[2. 4. 3. 2. 4. 4. 2. 1. 1. 4. 2. 5. 2. 1. 1. 3. 3. 3. 4. 5.]]\n",
            "values_data_dict mSize_values  [2. 4. 3. 2. 4. 4. 2. 1. 1. 4. 2. 5. 2. 1. 1. 3. 3. 3. 4. 5.]\n",
            "mip_mask_condition true_count_mip 9\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 29\n",
            "nonzero p_value[z_mask]: [[7]\n",
            " [7]\n",
            " [8]\n",
            " [5]\n",
            " [2]]\n",
            "nonzero p_value[mip_mask]: 29\n",
            "nonzero p_value[mip_mask]: [[7]\n",
            " [7]\n",
            " [8]\n",
            " [5]\n",
            " [2]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1]]\n",
            "num_tracks_in_event 0\n",
            "mips [[ 34.4474  27.0767 844.       4.    ]\n",
            " [127.1478 105.7814 418.       5.    ]\n",
            " [ 68.8894 114.3912 240.       4.    ]\n",
            " [ 58.1346 115.8033 860.       6.    ]\n",
            " [ 77.111   11.7099 631.       4.    ]\n",
            " [ 55.1288  97.2453 413.       5.    ]\n",
            " [ 69.0366  45.8733 290.       4.    ]\n",
            " [ 87.3589  50.9994 534.       5.    ]\n",
            " [ 56.3666  16.5778 573.       4.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [50000050.]\n",
            "\tPDG [50000050.] wrong >> skip\n",
            "index_particle 665  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[ True False False False False False  True False False False  True  True\n",
            "  False False False  True False False False False]]\n",
            "q_padded  [[ 829.   47.   13.   50.   20.   69.  456.   11.   29.   82. 1221. 1105.\n",
            "    52.   23.    8.  754.   56.   12.   46.   56.]]\n",
            "values_data_dict q_values  [ 829.   47.   13.   50.   20.   69.  456.   11.   29.   82. 1221. 1105.\n",
            "   52.   23.    8.  754.   56.   12.   46.   56.]\n",
            "size_padded  [[3. 1. 2. 2. 2. 2. 5. 1. 2. 2. 7. 6. 2. 2. 1. 5. 2. 2. 2. 2.]]\n",
            "values_data_dict mSize_values  [3. 1. 2. 2. 2. 2. 5. 1. 2. 2. 7. 6. 2. 2. 1. 5. 2. 2. 2. 2.]\n",
            "mip_mask_condition true_count_mip 8\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 70\n",
            "nonzero p_value[z_mask]: [[18]\n",
            " [18]\n",
            " [18]\n",
            " [16]\n",
            " [ 0]]\n",
            "nonzero p_value[mip_mask]: 70\n",
            "nonzero p_value[mip_mask]: [[18]\n",
            " [18]\n",
            " [18]\n",
            " [16]\n",
            " [ 0]]\n",
            "high_charge_size  [[1 0 0 0 0 0 1 0 0 0 1 1 0 0 0 1 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[  66.9993   53.4109  829.        3.    ]\n",
            " [  61.5783   70.1844  456.        5.    ]\n",
            " [  17.96     28.4999 1221.        7.    ]\n",
            " [  14.4882   30.8509 1105.        6.    ]\n",
            " [ 110.8696   76.0965  754.        5.    ]\n",
            " [  60.6004   74.5273  929.        5.    ]\n",
            " [  74.7269   19.5041  979.        4.    ]\n",
            " [ 119.4078   87.6918  702.        4.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 18 num_kaons 16 num_protons 0\n",
            "index_particle 667  num_tracks_in_event 1\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False  True False False\n",
            "  False False False  True False False False False]]\n",
            "q_padded  [[  33.   24.   17.    4.   60.   22.    9.   88.    5. 3083.   93.    5.\n",
            "    43.    8.   16.  287.   58.   11.   70.   49.]]\n",
            "values_data_dict q_values  [  33.   24.   17.    4.   60.   22.    9.   88.    5. 3083.   93.    5.\n",
            "   43.    8.   16.  287.   58.   11.   70.   49.]\n",
            "size_padded  [[3. 2. 2. 1. 4. 2. 1. 3. 1. 7. 2. 1. 2. 1. 1. 4. 4. 1. 4. 3.]]\n",
            "values_data_dict mSize_values  [3. 2. 2. 1. 4. 2. 1. 3. 1. 7. 2. 1. 2. 1. 1. 4. 4. 1. 4. 3.]\n",
            "mip_mask_condition true_count_mip 13\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (2, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (2, 550, 5)\n",
            "shape of z-score array: (2, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 5500\n",
            "nonzero p_value: [[1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]]\n",
            "nonzero p_value[z_mask]: 36\n",
            "nonzero p_value[z_mask]: [[9]\n",
            " [9]\n",
            " [9]\n",
            " [8]\n",
            " [1]]\n",
            "nonzero p_value[mip_mask]: 36\n",
            "nonzero p_value[mip_mask]: [[9]\n",
            " [9]\n",
            " [9]\n",
            " [8]\n",
            " [1]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0]\n",
            " [0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0]]\n",
            "num_tracks_in_event 1\n",
            "mips [[9.6917e+01 1.9764e+01 3.0830e+03 7.0000e+00]\n",
            " [5.4125e+01 9.0083e+01 2.8700e+02 4.0000e+00]\n",
            " [1.1041e+02 9.1848e+01 3.2300e+02 4.0000e+00]\n",
            " [1.0044e+02 5.2320e+01 3.9200e+02 4.0000e+00]\n",
            " [1.0303e+02 4.7169e+01 2.1200e+02 3.0000e+00]\n",
            " [9.1441e+01 3.2710e+01 1.5052e+04 8.0000e+00]\n",
            " [1.0170e+02 3.4328e+01 1.0280e+03 4.0000e+00]\n",
            " [1.1702e+02 2.9069e+01 1.0731e+04 1.0000e+01]\n",
            " [9.9074e+01 4.6486e-01 1.4140e+03 4.0000e+00]\n",
            " [8.2774e+01 4.8479e+01 1.3330e+03 6.0000e+00]\n",
            " [9.1410e+01 3.6501e+01 6.3600e+02 6.0000e+00]\n",
            " [1.4425e+01 2.1766e+01 2.2700e+02 4.0000e+00]\n",
            " [1.9805e+01 3.2173e+01 5.8900e+02 4.0000e+00]]\n",
            "L_all_tracks (550, 2) \n",
            "pion_mask2.shape (550, 2, 12)\n",
            "index 0 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index 1 of 1 : pdg [50000050.]\n",
            "\tPDG [50000050.] wrong >> skip\n",
            "index_particle 669  num_tracks_in_event 1\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False  True False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[  73.   23.   98.   51.   70.  145.   32.   36. 1348.   23.   41.   62.\n",
            "   153.   20.   87.   78.   64.   64.   42.    4.]]\n",
            "values_data_dict q_values  [  73.   23.   98.   51.   70.  145.   32.   36. 1348.   23.   41.   62.\n",
            "  153.   20.   87.   78.   64.   64.   42.    4.]\n",
            "size_padded  [[2. 1. 4. 3. 2. 3. 2. 2. 6. 1. 1. 3. 3. 2. 3. 3. 4. 2. 2. 1.]]\n",
            "values_data_dict mSize_values  [2. 1. 4. 3. 2. 3. 2. 2. 6. 1. 1. 3. 3. 2. 3. 3. 4. 2. 2. 1.]\n",
            "mip_mask_condition true_count_mip 6\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (2, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (2, 550, 5)\n",
            "shape of z-score array: (2, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 5500\n",
            "nonzero p_value: [[1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]]\n",
            "nonzero p_value[z_mask]: 117\n",
            "nonzero p_value[z_mask]: [[29]\n",
            " [29]\n",
            " [29]\n",
            " [28]\n",
            " [ 2]]\n",
            "nonzero p_value[mip_mask]: 117\n",
            "nonzero p_value[mip_mask]: [[29]\n",
            " [29]\n",
            " [29]\n",
            " [28]\n",
            " [ 2]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0]\n",
            " [0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 1\n",
            "mips [[  99.182    65.1061 1348.        6.    ]\n",
            " [  91.6237   60.0026  205.        3.    ]\n",
            " [  31.5595   70.0901  768.        5.    ]\n",
            " [  43.0357  101.7254  225.        4.    ]\n",
            " [  36.1296  121.4621  398.        5.    ]\n",
            " [  51.6061  107.506   484.        4.    ]]\n",
            "L_all_tracks (550, 2) \n",
            "pion_mask2.shape (550, 2, 12)\n",
            "index 0 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 29 num_kaons 28 num_protons 2\n",
            "index 1 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 670  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False  True False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[181.  32.  21.  36.  46.   5.  33. 305.   5.   5.  11.  50.   9.  14.\n",
            "   44. 116.  19.  35.  20.  56.]]\n",
            "values_data_dict q_values  [181.  32.  21.  36.  46.   5.  33. 305.   5.   5.  11.  50.   9.  14.\n",
            "  44. 116.  19.  35.  20.  56.]\n",
            "size_padded  [[4. 2. 1. 4. 3. 1. 2. 4. 1. 1. 1. 4. 1. 2. 2. 2. 1. 2. 1. 2.]]\n",
            "values_data_dict mSize_values  [4. 2. 1. 4. 3. 1. 2. 4. 1. 1. 1. 4. 1. 2. 2. 2. 1. 2. 1. 2.]\n",
            "mip_mask_condition true_count_mip 3\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 48\n",
            "nonzero p_value[z_mask]: [[12]\n",
            " [12]\n",
            " [12]\n",
            " [12]\n",
            " [ 0]]\n",
            "nonzero p_value[mip_mask]: 48\n",
            "nonzero p_value[mip_mask]: [[12]\n",
            " [12]\n",
            " [12]\n",
            " [12]\n",
            " [ 0]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[4.0594e+01 5.6582e+01 3.0500e+02 4.0000e+00]\n",
            " [1.1161e+02 9.9225e+00 4.7350e+03 7.0000e+00]\n",
            " [1.2383e+02 1.2648e+01 9.1000e+02 6.0000e+00]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 12 num_kaons 12 num_protons 0\n",
            "index_particle 671  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[ 52.  30. 198.  98.  12.  18.  55.  15.   7. 177.   8.   9.  20.   4.\n",
            "   66.  29.  81.   4.  59.   5.]]\n",
            "values_data_dict q_values  [ 52.  30. 198.  98.  12.  18.  55.  15.   7. 177.   8.   9.  20.   4.\n",
            "  66.  29.  81.   4.  59.   5.]\n",
            "size_padded  [[2. 2. 3. 3. 2. 1. 2. 1. 1. 4. 1. 1. 3. 1. 2. 1. 2. 1. 2. 1.]]\n",
            "values_data_dict mSize_values  [2. 2. 3. 3. 2. 1. 2. 1. 1. 4. 1. 1. 3. 1. 2. 1. 2. 1. 2. 1.]\n",
            "mip_mask_condition true_count_mip 11\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 36\n",
            "nonzero p_value[z_mask]: [[9]\n",
            " [9]\n",
            " [9]\n",
            " [9]\n",
            " [0]]\n",
            "nonzero p_value[mip_mask]: 36\n",
            "nonzero p_value[mip_mask]: [[9]\n",
            " [9]\n",
            " [9]\n",
            " [9]\n",
            " [0]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[7.7578e+01 3.0632e+01 5.6300e+02 4.0000e+00]\n",
            " [2.6336e+01 1.2573e+01 1.2660e+03 5.0000e+00]\n",
            " [2.9074e+01 1.5884e+01 7.0000e+02 4.0000e+00]\n",
            " [5.0043e+01 8.8261e+01 9.3000e+02 6.0000e+00]\n",
            " [1.3451e+01 4.3843e+01 3.0630e+03 6.0000e+00]\n",
            " [1.2108e+02 1.0300e+02 1.0500e+03 6.0000e+00]\n",
            " [1.2133e+02 1.0591e+02 2.0200e+03 7.0000e+00]\n",
            " [1.2819e+02 8.7194e+01 5.3300e+02 4.0000e+00]\n",
            " [4.6303e+01 5.5036e+01 2.7300e+03 7.0000e+00]\n",
            " [7.2156e+01 2.1617e+01 8.2550e+03 8.0000e+00]\n",
            " [9.3554e+01 2.2899e+01 7.3200e+02 6.0000e+00]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 673  num_tracks_in_event 1\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False False False False\n",
            "  False False  True False False False False False]]\n",
            "q_padded  [[  4.  17.  86.  20.  86.  17.  32.  66.  18.  61.  65.  97.  40.   7.\n",
            "  574.  74.   9. 113.  15.   9.]]\n",
            "values_data_dict q_values  [  4.  17.  86.  20.  86.  17.  32.  66.  18.  61.  65.  97.  40.   7.\n",
            " 574.  74.   9. 113.  15.   9.]\n",
            "size_padded  [[1. 1. 4. 1. 1. 2. 2. 3. 1. 1. 3. 2. 2. 1. 4. 2. 1. 3. 2. 2.]]\n",
            "values_data_dict mSize_values  [1. 1. 4. 1. 1. 2. 2. 3. 1. 1. 3. 2. 2. 1. 4. 2. 1. 3. 2. 2.]\n",
            "mip_mask_condition true_count_mip 6\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (2, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (2, 550, 5)\n",
            "shape of z-score array: (2, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 5500\n",
            "nonzero p_value: [[1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]]\n",
            "nonzero p_value[z_mask]: 76\n",
            "nonzero p_value[z_mask]: [[19]\n",
            " [18]\n",
            " [17]\n",
            " [15]\n",
            " [ 7]]\n",
            "nonzero p_value[mip_mask]: 76\n",
            "nonzero p_value[mip_mask]: [[19]\n",
            " [18]\n",
            " [17]\n",
            " [15]\n",
            " [ 7]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0]\n",
            " [0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0]]\n",
            "num_tracks_in_event 1\n",
            "mips [[  16.5252  105.3638  574.        4.    ]\n",
            " [  13.9851   13.998   708.        5.    ]\n",
            " [  28.2243   89.2519  877.        3.    ]\n",
            " [  17.3294   81.8104 1276.        6.    ]\n",
            " [  20.2216    6.8462  608.        4.    ]\n",
            " [ 125.1685   73.771   424.        4.    ]]\n",
            "L_all_tracks (550, 2) \n",
            "pion_mask2.shape (550, 2, 12)\n",
            "index 0 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 17 num_kaons 15 num_protons 7\n",
            "index 1 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 674  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False False False False\n",
            "  False False False False False False  True False]]\n",
            "q_padded  [[  6.   5.  78.  42.  10.   5.  56. 154.  55.  41.  75.  21.  50. 170.\n",
            "   83.  14.  18.  48. 606.  35.]]\n",
            "values_data_dict q_values  [  6.   5.  78.  42.  10.   5.  56. 154.  55.  41.  75.  21.  50. 170.\n",
            "  83.  14.  18.  48. 606.  35.]\n",
            "size_padded  [[1. 1. 3. 1. 1. 1. 2. 3. 2. 3. 3. 2. 2. 2. 3. 2. 1. 2. 5. 2.]]\n",
            "values_data_dict mSize_values  [1. 1. 3. 1. 1. 1. 2. 3. 2. 3. 3. 2. 2. 2. 3. 2. 1. 2. 5. 2.]\n",
            "mip_mask_condition true_count_mip 4\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 46\n",
            "nonzero p_value[z_mask]: [[12]\n",
            " [12]\n",
            " [12]\n",
            " [10]\n",
            " [ 0]]\n",
            "nonzero p_value[mip_mask]: 46\n",
            "nonzero p_value[mip_mask]: [[12]\n",
            " [12]\n",
            " [12]\n",
            " [10]\n",
            " [ 0]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[  99.9339  123.4176  606.        5.    ]\n",
            " [ 112.2186   98.5438  217.        4.    ]\n",
            " [  86.4797   19.9098  223.        4.    ]\n",
            " [  92.5483   66.6237 1231.        6.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 12 num_kaons 10 num_protons 0\n",
            "index_particle 675  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False  True  True False False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[3.500e+01 6.700e+01 8.600e+01 2.100e+01 4.783e+03 8.950e+02 6.400e+01\n",
            "  9.300e+01 3.900e+01 1.240e+02 6.600e+01 4.700e+01 4.000e+00 3.000e+01\n",
            "  4.500e+01 7.000e+00 1.240e+02 6.900e+01 6.000e+01 1.600e+01]]\n",
            "values_data_dict q_values  [3.500e+01 6.700e+01 8.600e+01 2.100e+01 4.783e+03 8.950e+02 6.400e+01\n",
            " 9.300e+01 3.900e+01 1.240e+02 6.600e+01 4.700e+01 4.000e+00 3.000e+01\n",
            " 4.500e+01 7.000e+00 1.240e+02 6.900e+01 6.000e+01 1.600e+01]\n",
            "size_padded  [[1. 2. 3. 1. 7. 6. 4. 2. 3. 3. 2. 2. 1. 2. 1. 1. 4. 3. 5. 1.]]\n",
            "values_data_dict mSize_values  [1. 2. 3. 1. 7. 6. 4. 2. 3. 3. 2. 2. 1. 2. 1. 1. 4. 3. 5. 1.]\n",
            "mip_mask_condition true_count_mip 5\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 56\n",
            "nonzero p_value[z_mask]: [[14]\n",
            " [14]\n",
            " [14]\n",
            " [14]\n",
            " [ 0]]\n",
            "nonzero p_value[mip_mask]: 56\n",
            "nonzero p_value[mip_mask]: [[14]\n",
            " [14]\n",
            " [14]\n",
            " [14]\n",
            " [ 0]]\n",
            "high_charge_size  [[0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[1.0893e+01 9.9868e+01 4.7830e+03 7.0000e+00]\n",
            " [3.4827e+01 6.1398e+01 8.9500e+02 6.0000e+00]\n",
            " [7.9053e+01 8.6463e+01 3.0300e+02 4.0000e+00]\n",
            " [4.2599e+01 9.4678e+01 3.0300e+02 4.0000e+00]\n",
            " [3.0274e+01 8.1208e+01 2.5000e+02 3.0000e+00]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 14 num_kaons 14 num_protons 0\n",
            "index_particle 676  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[42. 96. 13.  4.  4.  8.  6.  8. 82. 42. 63.  4.  5. 58. 64. 14. 13.  6.\n",
            "  62. 17.]]\n",
            "values_data_dict q_values  [42. 96. 13.  4.  4.  8.  6.  8. 82. 42. 63.  4.  5. 58. 64. 14. 13.  6.\n",
            " 62. 17.]\n",
            "size_padded  [[2. 2. 1. 1. 1. 1. 1. 1. 3. 1. 2. 1. 1. 5. 4. 2. 1. 1. 3. 2.]]\n",
            "values_data_dict mSize_values  [2. 2. 1. 1. 1. 1. 1. 1. 3. 1. 2. 1. 1. 5. 4. 2. 1. 1. 3. 2.]\n",
            "mip_mask_condition true_count_mip 4\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 69\n",
            "nonzero p_value[z_mask]: [[17]\n",
            " [17]\n",
            " [17]\n",
            " [16]\n",
            " [ 2]]\n",
            "nonzero p_value[mip_mask]: 69\n",
            "nonzero p_value[mip_mask]: [[17]\n",
            " [17]\n",
            " [17]\n",
            " [16]\n",
            " [ 2]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[  62.7393   22.6923  576.        6.    ]\n",
            " [  93.3909   58.4489 1126.        5.    ]\n",
            " [  86.7754   77.76    424.        4.    ]\n",
            " [  48.6697   93.3203  373.        4.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 17 num_kaons 16 num_protons 2\n",
            "index_particle 677  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False  True False False False False False  True False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[ 45.  70.  98. 234.  52.  25.  15.   6. 104. 305.  31.   0.   0.   0.\n",
            "    0.   0.   0.   0.   0.   0.]]\n",
            "values_data_dict q_values  [ 45.  70.  98. 234.  52.  25.  15.   6. 104. 305.  31.   0.   0.   0.\n",
            "   0.   0.   0.   0.   0.   0.]\n",
            "size_padded  [[2. 2. 6. 4. 2. 2. 2. 1. 4. 4. 2. 0. 0. 0. 0. 0. 0. 0. 0. 0.]]\n",
            "values_data_dict mSize_values  [2. 2. 6. 4. 2. 2. 2. 1. 4. 4. 2. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n",
            "mip_mask_condition true_count_mip 2\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 29\n",
            "nonzero p_value[z_mask]: [[7]\n",
            " [7]\n",
            " [7]\n",
            " [8]\n",
            " [0]]\n",
            "nonzero p_value[mip_mask]: 29\n",
            "nonzero p_value[mip_mask]: [[7]\n",
            " [7]\n",
            " [7]\n",
            " [8]\n",
            " [0]]\n",
            "high_charge_size  [[0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[ 28.7016  57.7885 234.       4.    ]\n",
            " [ 21.4158  46.1484 305.       4.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 678  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False False False False\n",
            "  False  True False False False False False False]]\n",
            "q_padded  [[  6.  32.  37.  40.  19.  23.  13.  77.  40.  11.  29.  38.  12. 241.\n",
            "    0.   0.   0.   0.   0.   0.]]\n",
            "values_data_dict q_values  [  6.  32.  37.  40.  19.  23.  13.  77.  40.  11.  29.  38.  12. 241.\n",
            "   0.   0.   0.   0.   0.   0.]\n",
            "size_padded  [[1. 2. 3. 2. 2. 4. 1. 4. 1. 1. 2. 2. 2. 7. 0. 0. 0. 0. 0. 0.]]\n",
            "values_data_dict mSize_values  [1. 2. 3. 2. 2. 4. 1. 4. 1. 1. 2. 2. 2. 7. 0. 0. 0. 0. 0. 0.]\n",
            "mip_mask_condition true_count_mip 1\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 33\n",
            "nonzero p_value[z_mask]: [[8]\n",
            " [8]\n",
            " [8]\n",
            " [8]\n",
            " [1]]\n",
            "nonzero p_value[mip_mask]: 33\n",
            "nonzero p_value[mip_mask]: [[8]\n",
            " [8]\n",
            " [8]\n",
            " [8]\n",
            " [1]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[ 72.1426  92.4376 241.       7.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 679  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[ True False False False False False False False False False  True False\n",
            "   True  True False False  True False False False]]\n",
            "q_padded  [[1570.    4.    4.   68.    7.  158.   66.  189.   58.   73.  285.   38.\n",
            "   491. 1089.  210.    9. 2020.   51.   20.    9.]]\n",
            "values_data_dict q_values  [1570.    4.    4.   68.    7.  158.   66.  189.   58.   73.  285.   38.\n",
            "  491. 1089.  210.    9. 2020.   51.   20.    9.]\n",
            "size_padded  [[8. 1. 1. 4. 1. 3. 2. 3. 3. 3. 8. 2. 5. 5. 1. 1. 5. 2. 1. 1.]]\n",
            "values_data_dict mSize_values  [8. 1. 1. 4. 1. 3. 2. 3. 3. 3. 8. 2. 5. 5. 1. 1. 5. 2. 1. 1.]\n",
            "mip_mask_condition true_count_mip 13\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 28\n",
            "nonzero p_value[z_mask]: [[7]\n",
            " [7]\n",
            " [7]\n",
            " [7]\n",
            " [0]]\n",
            "nonzero p_value[mip_mask]: 28\n",
            "nonzero p_value[mip_mask]: [[7]\n",
            " [7]\n",
            " [7]\n",
            " [7]\n",
            " [0]]\n",
            "high_charge_size  [[1 0 0 0 0 0 0 0 0 0 1 0 1 1 0 0 1 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[4.0207e+01 6.5504e+01 1.5700e+03 8.0000e+00]\n",
            " [3.1928e+01 6.8327e+01 2.8500e+02 8.0000e+00]\n",
            " [3.0049e+01 5.9703e+01 4.9100e+02 5.0000e+00]\n",
            " [3.5031e+01 6.6742e+01 1.0890e+03 5.0000e+00]\n",
            " [3.4990e+01 6.3957e+01 2.0200e+03 5.0000e+00]\n",
            " [5.0863e+01 5.5573e+01 2.3780e+03 7.0000e+00]\n",
            " [7.5503e+01 1.1474e+02 1.1860e+03 6.0000e+00]\n",
            " [4.5396e+01 7.2878e+01 5.2070e+03 7.0000e+00]\n",
            " [8.9369e+01 1.0186e+02 6.8300e+02 6.0000e+00]\n",
            " [1.0433e+02 1.0609e+02 2.1100e+02 4.0000e+00]\n",
            " [1.1216e+02 1.1005e+02 7.2500e+02 6.0000e+00]\n",
            " [7.8701e+01 1.0657e+02 3.3400e+02 4.0000e+00]\n",
            " [7.7770e+01 1.0491e+02 2.0200e+02 3.0000e+00]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 680  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False False False False\n",
            "  False False False False False False False  True]]\n",
            "q_padded  [[ 93.  48.  40.  31.  54.  89.  31.  61.  64.  49.  35.  58.  16.  11.\n",
            "   19.  42.   4.  12. 174. 314.]]\n",
            "values_data_dict q_values  [ 93.  48.  40.  31.  54.  89.  31.  61.  64.  49.  35.  58.  16.  11.\n",
            "  19.  42.   4.  12. 174. 314.]\n",
            "size_padded  [[3. 3. 2. 2. 2. 3. 2. 3. 2. 2. 2. 2. 2. 1. 2. 2. 1. 1. 4. 4.]]\n",
            "values_data_dict mSize_values  [3. 3. 2. 2. 2. 3. 2. 3. 2. 2. 2. 2. 2. 1. 2. 2. 1. 1. 4. 4.]\n",
            "mip_mask_condition true_count_mip 2\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 10\n",
            "nonzero p_value[z_mask]: [[1]\n",
            " [1]\n",
            " [1]\n",
            " [5]\n",
            " [2]]\n",
            "nonzero p_value[mip_mask]: 10\n",
            "nonzero p_value[mip_mask]: [[1]\n",
            " [1]\n",
            " [1]\n",
            " [5]\n",
            " [2]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1]]\n",
            "num_tracks_in_event 0\n",
            "mips [[ 46.2332 110.6365 314.       4.    ]\n",
            " [ 49.8559  79.4398 260.       4.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 681  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[ True False False False False False False False False False False False\n",
            "  False False  True False False False False False]]\n",
            "q_padded  [[1661.   59.   90.    7.  113.   31.   84.   31.   33.    5.   56.    7.\n",
            "    16.   15.  375.    4.   67.  151.  109.   65.]]\n",
            "values_data_dict q_values  [1661.   59.   90.    7.  113.   31.   84.   31.   33.    5.   56.    7.\n",
            "   16.   15.  375.    4.   67.  151.  109.   65.]\n",
            "size_padded  [[4. 4. 6. 1. 4. 2. 4. 2. 4. 1. 2. 1. 1. 2. 5. 1. 3. 4. 3. 2.]]\n",
            "values_data_dict mSize_values  [4. 4. 6. 1. 4. 2. 4. 2. 4. 1. 2. 1. 1. 2. 5. 1. 3. 4. 3. 2.]\n",
            "mip_mask_condition true_count_mip 2\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 13\n",
            "nonzero p_value[z_mask]: [[3]\n",
            " [3]\n",
            " [3]\n",
            " [4]\n",
            " [0]]\n",
            "nonzero p_value[mip_mask]: 13\n",
            "nonzero p_value[mip_mask]: [[3]\n",
            " [3]\n",
            " [3]\n",
            " [4]\n",
            " [0]]\n",
            "high_charge_size  [[1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[7.7085e+01 2.4149e-01 1.6610e+03 4.0000e+00]\n",
            " [5.2459e+01 1.2075e+02 3.7500e+02 5.0000e+00]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 682  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False  True False False False False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[121.  22.  64. 828.  97.   4. 144. 187.  12.  55.  86.  51.  63.  84.\n",
            "   14.  41.  63.  94. 153.  69.]]\n",
            "values_data_dict q_values  [121.  22.  64. 828.  97.   4. 144. 187.  12.  55.  86.  51.  63.  84.\n",
            "  14.  41.  63.  94. 153.  69.]\n",
            "size_padded  [[4. 1. 2. 5. 4. 1. 3. 6. 1. 2. 3. 2. 2. 3. 1. 2. 2. 3. 3. 3.]]\n",
            "values_data_dict mSize_values  [4. 1. 2. 5. 4. 1. 3. 6. 1. 2. 3. 2. 2. 3. 1. 2. 2. 3. 3. 3.]\n",
            "mip_mask_condition true_count_mip 14\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 24\n",
            "nonzero p_value[z_mask]: [[5]\n",
            " [5]\n",
            " [5]\n",
            " [6]\n",
            " [3]]\n",
            "nonzero p_value[mip_mask]: 24\n",
            "nonzero p_value[mip_mask]: [[5]\n",
            " [5]\n",
            " [5]\n",
            " [6]\n",
            " [3]]\n",
            "high_charge_size  [[0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[6.1314e+01 1.1436e+02 8.2800e+02 5.0000e+00]\n",
            " [6.9965e+00 3.6766e+00 6.1000e+02 5.0000e+00]\n",
            " [6.8769e+01 8.9975e+01 2.2100e+02 4.0000e+00]\n",
            " [8.3800e+00 1.1481e+02 4.6720e+03 6.0000e+00]\n",
            " [1.2049e+02 8.1608e+01 9.0500e+02 5.0000e+00]\n",
            " [1.0041e+02 7.0527e+01 5.5600e+02 4.0000e+00]\n",
            " [8.8635e+00 3.0847e+01 1.6230e+03 6.0000e+00]\n",
            " [9.8871e+00 2.6065e+01 1.9640e+03 6.0000e+00]\n",
            " [3.3567e+01 2.4773e+01 1.0291e+04 1.1000e+01]\n",
            " [1.2524e+02 7.3924e+01 4.1500e+02 4.0000e+00]\n",
            " [1.2754e+02 6.6596e+01 2.5900e+02 4.0000e+00]\n",
            " [7.6068e+01 4.6266e+01 4.3500e+02 8.0000e+00]\n",
            " [8.0715e+01 3.2054e+01 6.5000e+02 5.0000e+00]\n",
            " [1.2874e+02 5.5191e+01 3.7200e+02 4.0000e+00]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [50000050.]\n",
            "\tPDG [50000050.] wrong >> skip\n",
            "index_particle 683  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False  True False False  True False\n",
            "  False False False False False False False  True]]\n",
            "q_padded  [[  18.   41.   17.    7.    6.   58.   15. 1327.    8.   26.  229.    7.\n",
            "    57.   70.   34.   28.   58.    9.    5.  829.]]\n",
            "values_data_dict q_values  [  18.   41.   17.    7.    6.   58.   15. 1327.    8.   26.  229.    7.\n",
            "   57.   70.   34.   28.   58.    9.    5.  829.]\n",
            "size_padded  [[2. 3. 1. 1. 1. 2. 1. 6. 1. 2. 4. 1. 4. 2. 3. 2. 1. 1. 1. 4.]]\n",
            "values_data_dict mSize_values  [2. 3. 1. 1. 1. 2. 1. 6. 1. 2. 4. 1. 4. 2. 3. 2. 1. 1. 1. 4.]\n",
            "mip_mask_condition true_count_mip 3\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 4\n",
            "nonzero p_value[z_mask]: [[1]\n",
            " [1]\n",
            " [1]\n",
            " [1]\n",
            " [0]]\n",
            "nonzero p_value[mip_mask]: 4\n",
            "nonzero p_value[mip_mask]: [[1]\n",
            " [1]\n",
            " [1]\n",
            " [1]\n",
            " [0]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 1]]\n",
            "num_tracks_in_event 0\n",
            "mips [[  85.4137   31.3052 1327.        6.    ]\n",
            " [  91.472    26.8261  229.        4.    ]\n",
            " [  60.0183   89.0516  829.        4.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "PDG [211.] skip >> ckovRecon [-11.]\n",
            "index_particle 684  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False  True False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[ 82.   7.  62.  20.  29.   4.  21. 825.  44.  56.  48.  65.  19.  22.\n",
            "   76.  32.   6.  76.  11.  29.]]\n",
            "values_data_dict q_values  [ 82.   7.  62.  20.  29.   4.  21. 825.  44.  56.  48.  65.  19.  22.\n",
            "  76.  32.   6.  76.  11.  29.]\n",
            "size_padded  [[3. 1. 4. 1. 2. 1. 2. 4. 2. 4. 2. 2. 1. 2. 3. 2. 1. 3. 1. 2.]]\n",
            "values_data_dict mSize_values  [3. 1. 4. 1. 2. 1. 2. 4. 2. 4. 2. 2. 1. 2. 3. 2. 1. 3. 1. 2.]\n",
            "mip_mask_condition true_count_mip 10\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 69\n",
            "nonzero p_value[z_mask]: [[17]\n",
            " [17]\n",
            " [17]\n",
            " [15]\n",
            " [ 3]]\n",
            "nonzero p_value[mip_mask]: 69\n",
            "nonzero p_value[mip_mask]: [[17]\n",
            " [17]\n",
            " [17]\n",
            " [15]\n",
            " [ 3]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[ 120.2304   76.7253  825.        4.    ]\n",
            " [  45.6275   86.9061  933.        4.    ]\n",
            " [  47.9763   91.3127  939.        6.    ]\n",
            " [  87.8      88.5983 1521.        7.    ]\n",
            " [  26.116    99.6738  880.        5.    ]\n",
            " [   5.4838  121.7634  316.        4.    ]\n",
            " [  45.3605   36.0565  216.        9.    ]\n",
            " [  15.6064   58.0949  244.        3.    ]\n",
            " [   4.2232    4.9771  208.        7.    ]\n",
            " [  11.5315   15.6107  264.        4.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 17 num_kaons 15 num_protons 3\n",
            "index_particle 685  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[  9. 123.  46.  57.  53.  22.  22.  60. 533.   5.  38.  86.  89.  82.\n",
            "  126.  61.  77.  17.  76. 121.]]\n",
            "values_data_dict q_values  [  9. 123.  46.  57.  53.  22.  22.  60. 533.   5.  38.  86.  89.  82.\n",
            " 126.  61.  77.  17.  76. 121.]\n",
            "size_padded  [[1. 3. 4. 3. 1. 2. 1. 2. 2. 1. 3. 3. 2. 4. 4. 3. 4. 2. 2. 3.]]\n",
            "values_data_dict mSize_values  [1. 3. 4. 3. 1. 2. 1. 2. 2. 1. 3. 3. 2. 4. 4. 3. 4. 2. 2. 3.]\n",
            "mip_mask_condition true_count_mip 8\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 7\n",
            "nonzero p_value[z_mask]: [[2]\n",
            " [2]\n",
            " [2]\n",
            " [1]\n",
            " [0]]\n",
            "nonzero p_value[mip_mask]: 7\n",
            "nonzero p_value[mip_mask]: [[2]\n",
            " [2]\n",
            " [2]\n",
            " [1]\n",
            " [0]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[4.1577e+01 2.1827e+01 1.0000e+04 8.0000e+00]\n",
            " [3.2532e+01 1.0067e+02 1.3430e+03 6.0000e+00]\n",
            " [3.2056e+01 3.4362e+01 2.1700e+02 7.0000e+00]\n",
            " [1.0345e+02 9.7046e+01 1.9180e+03 7.0000e+00]\n",
            " [1.1450e+02 1.7834e+01 2.2900e+02 4.0000e+00]\n",
            " [1.2256e+02 2.3814e+01 1.1273e+04 1.1000e+01]\n",
            " [1.1098e+02 2.8304e+01 1.0160e+03 5.0000e+00]\n",
            " [4.9098e+01 1.8720e+01 5.8700e+02 4.0000e+00]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [50000050.]\n",
            "\tPDG [50000050.] wrong >> skip\n",
            "index_particle 686  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False  True False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[ 82.   7.  62.  20.  29.   4.  21. 825.  44.  56.  48.  65.  19.  22.\n",
            "   76.  32.   6.  76.  11.  29.]]\n",
            "values_data_dict q_values  [ 82.   7.  62.  20.  29.   4.  21. 825.  44.  56.  48.  65.  19.  22.\n",
            "  76.  32.   6.  76.  11.  29.]\n",
            "size_padded  [[3. 1. 4. 1. 2. 1. 2. 4. 2. 4. 2. 2. 1. 2. 3. 2. 1. 3. 1. 2.]]\n",
            "values_data_dict mSize_values  [3. 1. 4. 1. 2. 1. 2. 4. 2. 4. 2. 2. 1. 2. 3. 2. 1. 3. 1. 2.]\n",
            "mip_mask_condition true_count_mip 10\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 120\n",
            "nonzero p_value[z_mask]: [[31]\n",
            " [32]\n",
            " [32]\n",
            " [25]\n",
            " [ 0]]\n",
            "nonzero p_value[mip_mask]: 120\n",
            "nonzero p_value[mip_mask]: [[31]\n",
            " [32]\n",
            " [32]\n",
            " [25]\n",
            " [ 0]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[ 120.2304   76.7253  825.        4.    ]\n",
            " [  45.6275   86.9061  933.        4.    ]\n",
            " [  47.9763   91.3127  939.        6.    ]\n",
            " [  87.8      88.5983 1521.        7.    ]\n",
            " [  26.116    99.6738  880.        5.    ]\n",
            " [   5.4838  121.7634  316.        4.    ]\n",
            " [  45.3605   36.0565  216.        9.    ]\n",
            " [  15.6064   58.0949  244.        3.    ]\n",
            " [   4.2232    4.9771  208.        7.    ]\n",
            " [  11.5315   15.6107  264.        4.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [50000050.]\n",
            "\tPDG [50000050.] wrong >> skip\n",
            "index_particle 687  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False  True False False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[  14.   30.   51.    7.   40. 1954.   12.   51.   53.   26.  132.   79.\n",
            "     5.    6.   79.   41.   17.   16.   36.   97.]]\n",
            "values_data_dict q_values  [  14.   30.   51.    7.   40. 1954.   12.   51.   53.   26.  132.   79.\n",
            "    5.    6.   79.   41.   17.   16.   36.   97.]\n",
            "size_padded  [[2. 2. 3. 1. 2. 7. 1. 2. 2. 1. 2. 2. 1. 1. 3. 3. 1. 1. 2. 4.]]\n",
            "values_data_dict mSize_values  [2. 2. 3. 1. 2. 7. 1. 2. 2. 1. 2. 2. 1. 1. 3. 3. 1. 1. 2. 4.]\n",
            "mip_mask_condition true_count_mip 17\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 32\n",
            "nonzero p_value[z_mask]: [[7]\n",
            " [7]\n",
            " [7]\n",
            " [5]\n",
            " [6]]\n",
            "nonzero p_value[mip_mask]: 32\n",
            "nonzero p_value[mip_mask]: [[7]\n",
            " [7]\n",
            " [7]\n",
            " [5]\n",
            " [6]]\n",
            "high_charge_size  [[0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[5.2918e+01 5.3078e+00 1.9540e+03 7.0000e+00]\n",
            " [4.3396e+01 5.2889e+01 1.1672e+04 9.0000e+00]\n",
            " [2.7334e+01 5.8024e+01 1.0000e+04 9.0000e+00]\n",
            " [3.2217e+01 7.1610e+01 9.2100e+02 7.0000e+00]\n",
            " [3.9811e+01 2.7904e+01 2.5100e+02 4.0000e+00]\n",
            " [3.7862e+01 1.4104e+01 2.4820e+03 6.0000e+00]\n",
            " [7.5254e+01 1.0933e+02 3.0700e+02 1.1000e+01]\n",
            " [4.0783e+01 6.3683e+01 6.6300e+02 4.0000e+00]\n",
            " [7.2912e+01 1.2055e+02 8.0600e+02 5.0000e+00]\n",
            " [3.7324e+01 5.5471e+01 2.1000e+02 3.0000e+00]\n",
            " [3.8701e+01 5.4764e+01 3.8000e+02 4.0000e+00]\n",
            " [7.8332e+01 9.7788e+01 5.4540e+03 8.0000e+00]\n",
            " [5.9841e+01 1.0792e+02 2.2000e+02 6.0000e+00]\n",
            " [1.0266e+02 3.9906e+01 1.3910e+03 4.0000e+00]\n",
            " [8.7106e+01 3.8355e+01 2.3900e+02 3.0000e+00]\n",
            " [4.6178e+01 6.4844e+01 6.6100e+02 6.0000e+00]\n",
            " [7.2614e+01 1.0559e+02 8.8700e+02 5.0000e+00]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 690  num_tracks_in_event 2\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False  True False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[  4.  34.   6.  57.   7.   5.  32. 857.  29.   9.   5.  43.  45.  20.\n",
            "   33.  56.  50.  48. 163.  39.]]\n",
            "values_data_dict q_values  [  4.  34.   6.  57.   7.   5.  32. 857.  29.   9.   5.  43.  45.  20.\n",
            "  33.  56.  50.  48. 163.  39.]\n",
            "size_padded  [[1. 3. 1. 2. 1. 1. 4. 6. 1. 1. 1. 3. 3. 2. 2. 4. 1. 2. 4. 3.]]\n",
            "values_data_dict mSize_values  [1. 3. 1. 2. 1. 1. 4. 6. 1. 1. 1. 3. 3. 2. 2. 4. 1. 2. 4. 3.]\n",
            "mip_mask_condition true_count_mip 9\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (3, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (3, 550, 5)\n",
            "shape of z-score array: (3, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 8250\n",
            "nonzero p_value: [[1650]\n",
            " [1650]\n",
            " [1650]\n",
            " [1650]\n",
            " [1650]]\n",
            "nonzero p_value[z_mask]: 195\n",
            "nonzero p_value[z_mask]: [[51]\n",
            " [51]\n",
            " [51]\n",
            " [39]\n",
            " [ 3]]\n",
            "nonzero p_value[mip_mask]: 195\n",
            "nonzero p_value[mip_mask]: [[51]\n",
            " [51]\n",
            " [51]\n",
            " [39]\n",
            " [ 3]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0]\n",
            " [0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0]\n",
            " [0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 2\n",
            "mips [[1.0977e+02 6.2586e+01 8.5700e+02 6.0000e+00]\n",
            " [7.0755e+01 2.1040e+01 1.3180e+03 4.0000e+00]\n",
            " [8.9242e+01 9.9326e+01 4.1600e+02 4.0000e+00]\n",
            " [7.8545e+01 2.7582e+01 4.4900e+02 4.0000e+00]\n",
            " [8.9962e-01 9.5244e+01 4.5900e+02 4.0000e+00]\n",
            " [1.7138e+01 6.7472e+01 6.2500e+02 4.0000e+00]\n",
            " [1.0608e+02 9.4503e+01 4.0000e+02 6.0000e+00]\n",
            " [5.4073e+01 9.0996e+01 5.0800e+02 5.0000e+00]\n",
            " [5.2911e+01 9.7538e+01 1.0350e+03 4.0000e+00]]\n",
            "L_all_tracks (550, 3) \n",
            "pion_mask2.shape (550, 3, 12)\n",
            "index 0 of 2 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 18 num_kaons 13 num_protons 0\n",
            "index 1 of 2 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 1\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 33 num_kaons 26 num_protons 3\n",
            "index 2 of 2 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 691  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False False  True  True\n",
            "  False False  True False  True False False False]]\n",
            "q_padded  [[  15.   57.   22.    8.   41.   42.   14.  108.   41.    6.  587.  365.\n",
            "    17.   92. 1031.   11.  436.  125.  124.   14.]]\n",
            "values_data_dict q_values  [  15.   57.   22.    8.   41.   42.   14.  108.   41.    6.  587.  365.\n",
            "   17.   92. 1031.   11.  436.  125.  124.   14.]\n",
            "size_padded  [[2. 3. 5. 1. 2. 4. 2. 4. 3. 1. 6. 3. 2. 2. 5. 1. 4. 6. 4. 2.]]\n",
            "values_data_dict mSize_values  [2. 3. 5. 1. 2. 4. 2. 4. 3. 1. 6. 3. 2. 2. 5. 1. 4. 6. 4. 2.]\n",
            "mip_mask_condition true_count_mip 4\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 32\n",
            "nonzero p_value[z_mask]: [[8]\n",
            " [8]\n",
            " [8]\n",
            " [8]\n",
            " [0]]\n",
            "nonzero p_value[mip_mask]: 32\n",
            "nonzero p_value[mip_mask]: [[8]\n",
            " [8]\n",
            " [8]\n",
            " [8]\n",
            " [0]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 0 1 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[   2.0035   53.021   587.        6.    ]\n",
            " [   6.1244   39.2109  365.        3.    ]\n",
            " [  95.5395  115.887  1031.        5.    ]\n",
            " [  96.1625   27.8405  436.        4.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [13.]\n",
            "\tPDG [13.] wrong >> skip\n",
            "index_particle 692  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False  True False  True False False False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[112.  22. 371.  13. 971.  19.   8. 108.  30.  23.   8. 143. 166.  23.\n",
            "  108.  20. 107.  21.  40. 124.]]\n",
            "values_data_dict q_values  [112.  22. 371.  13. 971.  19.   8. 108.  30.  23.   8. 143. 166.  23.\n",
            " 108.  20. 107.  21.  40. 124.]\n",
            "size_padded  [[2. 1. 4. 1. 6. 1. 1. 2. 4. 1. 1. 6. 4. 2. 3. 1. 4. 1. 2. 4.]]\n",
            "values_data_dict mSize_values  [2. 1. 4. 1. 6. 1. 1. 2. 4. 1. 1. 6. 4. 2. 3. 1. 4. 1. 2. 4.]\n",
            "mip_mask_condition true_count_mip 6\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 15\n",
            "nonzero p_value[z_mask]: [[4]\n",
            " [4]\n",
            " [4]\n",
            " [3]\n",
            " [0]]\n",
            "nonzero p_value[mip_mask]: 15\n",
            "nonzero p_value[mip_mask]: [[4]\n",
            " [4]\n",
            " [4]\n",
            " [3]\n",
            " [0]]\n",
            "high_charge_size  [[0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[ 106.5671   18.5473  371.        4.    ]\n",
            " [ 107.9604   68.7007  971.        6.    ]\n",
            " [  89.1846  123.1439 1048.       27.    ]\n",
            " [  88.288    69.689   205.        6.    ]\n",
            " [  84.3452   72.6178  866.        6.    ]\n",
            " [  76.0837   63.0794 1472.        4.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 694  num_tracks_in_event 1\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False False False False\n",
            "  False False False False  True False  True  True]]\n",
            "q_padded  [[  79.    4.  150.  105.   51.   55.   16.   62.   22.   16.  122.   22.\n",
            "    24.   46.   25.   51.  786.    6.  261. 2248.]]\n",
            "values_data_dict q_values  [  79.    4.  150.  105.   51.   55.   16.   62.   22.   16.  122.   22.\n",
            "   24.   46.   25.   51.  786.    6.  261. 2248.]\n",
            "size_padded  [[3. 1. 3. 6. 4. 2. 1. 2. 2. 1. 2. 2. 2. 2. 2. 3. 5. 1. 4. 6.]]\n",
            "values_data_dict mSize_values  [3. 1. 3. 6. 4. 2. 1. 2. 2. 1. 2. 2. 2. 2. 2. 3. 5. 1. 4. 6.]\n",
            "mip_mask_condition true_count_mip 5\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (2, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (2, 550, 5)\n",
            "shape of z-score array: (2, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 5500\n",
            "nonzero p_value: [[1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]]\n",
            "nonzero p_value[z_mask]: 80\n",
            "nonzero p_value[z_mask]: [[19]\n",
            " [20]\n",
            " [20]\n",
            " [18]\n",
            " [ 3]]\n",
            "nonzero p_value[mip_mask]: 80\n",
            "nonzero p_value[mip_mask]: [[19]\n",
            " [20]\n",
            " [20]\n",
            " [18]\n",
            " [ 3]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1]\n",
            " [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1]]\n",
            "num_tracks_in_event 1\n",
            "mips [[  13.2845   73.6183  786.        5.    ]\n",
            " [  90.5657  119.2634  261.        4.    ]\n",
            " [  28.4674  125.5447 2248.        6.    ]\n",
            " [  87.2378  114.1169 1449.        6.    ]\n",
            " [  97.8331  112.5494  357.        6.    ]]\n",
            "L_all_tracks (550, 2) \n",
            "pion_mask2.shape (550, 2, 12)\n",
            "index 0 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 20 num_kaons 18 num_protons 3\n",
            "index 1 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 696  num_tracks_in_event 1\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False  True False False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[  13.   74.   10.   15.   23. 1302.  155.   21.   28.   11.   33.   17.\n",
            "    45.   55.   35.   12.  112.   59.   74.    6.]]\n",
            "values_data_dict q_values  [  13.   74.   10.   15.   23. 1302.  155.   21.   28.   11.   33.   17.\n",
            "   45.   55.   35.   12.  112.   59.   74.    6.]\n",
            "size_padded  [[1. 1. 1. 2. 3. 7. 2. 1. 2. 1. 4. 1. 2. 3. 2. 1. 3. 1. 2. 1.]]\n",
            "values_data_dict mSize_values  [1. 1. 1. 2. 3. 7. 2. 1. 2. 1. 4. 1. 2. 3. 2. 1. 3. 1. 2. 1.]\n",
            "mip_mask_condition true_count_mip 19\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (2, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (2, 550, 5)\n",
            "shape of z-score array: (2, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 5500\n",
            "nonzero p_value: [[1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]]\n",
            "nonzero p_value[z_mask]: 91\n",
            "nonzero p_value[z_mask]: [[22]\n",
            " [22]\n",
            " [22]\n",
            " [21]\n",
            " [ 4]]\n",
            "nonzero p_value[mip_mask]: 91\n",
            "nonzero p_value[mip_mask]: [[22]\n",
            " [22]\n",
            " [22]\n",
            " [21]\n",
            " [ 4]]\n",
            "high_charge_size  [[0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n",
            " [0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 1\n",
            "mips [[1.0454e+02 4.4478e+01 1.3020e+03 7.0000e+00]\n",
            " [6.9434e+01 2.4653e+01 8.3800e+02 5.0000e+00]\n",
            " [7.8535e+01 1.2460e+01 2.2100e+02 4.0000e+00]\n",
            " [1.2203e+02 1.1951e+02 5.5130e+03 7.0000e+00]\n",
            " [1.0988e+02 1.2316e+02 3.9700e+02 5.0000e+00]\n",
            " [1.0815e+02 1.8340e+01 2.2000e+02 5.0000e+00]\n",
            " [5.2008e+01 4.9282e+01 7.1200e+02 6.0000e+00]\n",
            " [7.8412e+01 7.3156e+01 1.9980e+03 8.0000e+00]\n",
            " [8.8490e+01 7.7213e+01 1.2840e+03 6.0000e+00]\n",
            " [1.0470e+02 9.6076e+01 1.5630e+03 6.0000e+00]\n",
            " [1.0398e+02 9.4242e+01 1.4260e+03 4.0000e+00]\n",
            " [1.0850e+02 5.9626e+01 2.1940e+03 7.0000e+00]\n",
            " [3.9069e+01 5.0784e+01 5.2700e+02 5.0000e+00]\n",
            " [3.9236e+01 1.8249e+01 3.0300e+02 6.0000e+00]\n",
            " [8.5480e+01 1.4497e+01 2.6200e+02 3.0000e+00]\n",
            " [9.3768e+01 7.7316e+01 2.1200e+02 3.0000e+00]\n",
            " [9.4858e+01 7.9341e+01 2.8050e+03 6.0000e+00]\n",
            " [8.4049e+01 7.8372e+01 2.1500e+02 5.0000e+00]\n",
            " [8.3303e+01 7.5050e+01 5.3410e+03 9.0000e+00]]\n",
            "L_all_tracks (550, 2) \n",
            "pion_mask2.shape (550, 2, 12)\n",
            "index 0 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 22 num_kaons 21 num_protons 4\n",
            "index 1 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 697  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False False False  True\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[ 37.  18.  35.  59.  10.  41.   5.  32.  21.  34.  22. 657.  34.  45.\n",
            "   10.  20.  67.  11.  23.  38.]]\n",
            "values_data_dict q_values  [ 37.  18.  35.  59.  10.  41.   5.  32.  21.  34.  22. 657.  34.  45.\n",
            "  10.  20.  67.  11.  23.  38.]\n",
            "size_padded  [[4. 1. 2. 1. 1. 3. 1. 2. 2. 2. 1. 4. 2. 2. 1. 2. 4. 1. 1. 2.]]\n",
            "values_data_dict mSize_values  [4. 1. 2. 1. 1. 3. 1. 2. 2. 2. 1. 4. 2. 2. 1. 2. 4. 1. 1. 2.]\n",
            "mip_mask_condition true_count_mip 4\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 50\n",
            "nonzero p_value[z_mask]: [[13]\n",
            " [13]\n",
            " [13]\n",
            " [11]\n",
            " [ 0]]\n",
            "nonzero p_value[mip_mask]: 50\n",
            "nonzero p_value[mip_mask]: [[13]\n",
            " [13]\n",
            " [13]\n",
            " [11]\n",
            " [ 0]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[  93.2299   32.7409  657.        4.    ]\n",
            " [ 125.3552   13.0583 2859.        5.    ]\n",
            " [  63.4982   13.6575 1273.        5.    ]\n",
            " [  58.398    25.1359  218.        6.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 13 num_kaons 11 num_protons 0\n",
            "index_particle 699  num_tracks_in_event 1\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[ 65.  31.   4.   7.  56.  36.  28.  90.  22. 135.   8.  87. 142. 100.\n",
            "   23.  27.  39.  43.  26.  52.]]\n",
            "values_data_dict q_values  [ 65.  31.   4.   7.  56.  36.  28.  90.  22. 135.   8.  87. 142. 100.\n",
            "  23.  27.  39.  43.  26.  52.]\n",
            "size_padded  [[2. 3. 1. 1. 1. 2. 1. 2. 1. 2. 1. 3. 4. 3. 1. 1. 1. 3. 3. 2.]]\n",
            "values_data_dict mSize_values  [2. 3. 1. 1. 1. 2. 1. 2. 1. 2. 1. 3. 4. 3. 1. 1. 1. 3. 3. 2.]\n",
            "mip_mask_condition true_count_mip 8\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (2, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (2, 550, 5)\n",
            "shape of z-score array: (2, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 5500\n",
            "nonzero p_value: [[1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]]\n",
            "nonzero p_value[z_mask]: 54\n",
            "nonzero p_value[z_mask]: [[15]\n",
            " [14]\n",
            " [14]\n",
            " [11]\n",
            " [ 0]]\n",
            "nonzero p_value[mip_mask]: 54\n",
            "nonzero p_value[mip_mask]: [[15]\n",
            " [14]\n",
            " [14]\n",
            " [11]\n",
            " [ 0]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n",
            " [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 1\n",
            "mips [[1.1030e+02 1.0590e+02 9.6900e+02 5.0000e+00]\n",
            " [9.0795e+01 9.6791e+01 2.5300e+02 4.0000e+00]\n",
            " [1.0189e+02 9.4810e+01 3.6200e+02 4.0000e+00]\n",
            " [2.5728e+01 1.0803e+02 2.5090e+03 7.0000e+00]\n",
            " [9.8951e+01 2.0459e+01 3.6800e+02 4.0000e+00]\n",
            " [5.5176e+01 3.3479e+01 4.9140e+03 6.0000e+00]\n",
            " [1.2666e+01 2.3032e+01 5.1100e+02 5.0000e+00]\n",
            " [1.1477e+01 1.2583e+02 1.0970e+03 4.0000e+00]]\n",
            "L_all_tracks (550, 2) \n",
            "pion_mask2.shape (550, 2, 12)\n",
            "index 0 of 1 : pdg [50000050.]\n",
            "\tPDG [50000050.] wrong >> skip\n",
            "index 1 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 702  num_tracks_in_event 2\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False  True False False False False False False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[  58. 1002.   70.   70.    4.   43.   29.    5.   56.   20.   43.   33.\n",
            "     7.   10.   17.   38.    9.   81.    7.   51.]]\n",
            "values_data_dict q_values  [  58. 1002.   70.   70.    4.   43.   29.    5.   56.   20.   43.   33.\n",
            "    7.   10.   17.   38.    9.   81.    7.   51.]\n",
            "size_padded  [[3. 5. 4. 5. 1. 3. 1. 1. 3. 1. 1. 3. 1. 2. 1. 2. 1. 2. 1. 1.]]\n",
            "values_data_dict mSize_values  [3. 5. 4. 5. 1. 3. 1. 1. 3. 1. 1. 3. 1. 2. 1. 2. 1. 2. 1. 1.]\n",
            "mip_mask_condition true_count_mip 12\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (3, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (3, 550, 5)\n",
            "shape of z-score array: (3, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 8250\n",
            "nonzero p_value: [[1650]\n",
            " [1650]\n",
            " [1650]\n",
            " [1650]\n",
            " [1650]]\n",
            "nonzero p_value[z_mask]: 154\n",
            "nonzero p_value[z_mask]: [[37]\n",
            " [38]\n",
            " [38]\n",
            " [33]\n",
            " [ 8]]\n",
            "nonzero p_value[mip_mask]: 154\n",
            "nonzero p_value[mip_mask]: [[37]\n",
            " [38]\n",
            " [38]\n",
            " [33]\n",
            " [ 8]]\n",
            "high_charge_size  [[0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n",
            " [0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n",
            " [0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 2\n",
            "mips [[2.1049e+00 1.0110e+02 1.0020e+03 5.0000e+00]\n",
            " [8.9045e+01 4.8820e+01 5.5800e+03 5.0000e+00]\n",
            " [8.0757e+01 3.6723e+00 5.7400e+02 4.0000e+00]\n",
            " [8.8513e+01 7.5539e+00 2.1500e+02 4.0000e+00]\n",
            " [9.7372e+01 7.9319e+00 4.6000e+02 5.0000e+00]\n",
            " [1.1712e+02 2.5850e+01 7.6500e+02 4.0000e+00]\n",
            " [2.0550e+01 1.0892e+02 6.4500e+02 4.0000e+00]\n",
            " [6.7656e+01 6.6600e+01 5.9200e+02 4.0000e+00]\n",
            " [1.2399e+02 2.2363e+01 4.0700e+02 4.0000e+00]\n",
            " [1.2392e+02 1.7675e+01 6.0600e+02 7.0000e+00]\n",
            " [1.2654e+02 4.3380e+00 4.2600e+02 4.0000e+00]\n",
            " [1.0983e+02 5.4300e+01 2.3800e+02 4.0000e+00]]\n",
            "L_all_tracks (550, 3) \n",
            "pion_mask2.shape (550, 3, 12)\n",
            "index 0 of 2 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 20 num_kaons 15 num_protons 1\n",
            "index 1 of 2 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 1\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 18 num_kaons 18 num_protons 7\n",
            "index 2 of 2 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 703  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False  True False False\n",
            "  False False False False False False False  True]]\n",
            "q_padded  [[ 42.  92.  14. 188.  14. 171.   7.  57.  35. 407.  73.  47.  42.  90.\n",
            "   19.  94. 167.   9.  18. 251.]]\n",
            "values_data_dict q_values  [ 42.  92.  14. 188.  14. 171.   7.  57.  35. 407.  73.  47.  42.  90.\n",
            "  19.  94. 167.   9.  18. 251.]\n",
            "size_padded  [[4. 2. 1. 3. 2. 3. 1. 2. 2. 5. 1. 2. 4. 2. 1. 4. 5. 1. 2. 4.]]\n",
            "values_data_dict mSize_values  [4. 2. 1. 3. 2. 3. 1. 2. 2. 5. 1. 2. 4. 2. 1. 4. 5. 1. 2. 4.]\n",
            "mip_mask_condition true_count_mip 7\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 7\n",
            "nonzero p_value[z_mask]: [[1]\n",
            " [3]\n",
            " [3]\n",
            " [0]\n",
            " [0]]\n",
            "nonzero p_value[mip_mask]: 7\n",
            "nonzero p_value[mip_mask]: [[1]\n",
            " [3]\n",
            " [3]\n",
            " [0]\n",
            " [0]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1]]\n",
            "num_tracks_in_event 0\n",
            "mips [[7.4216e+01 9.3456e+01 4.0700e+02 5.0000e+00]\n",
            " [1.0579e+02 6.2099e+01 2.5100e+02 4.0000e+00]\n",
            " [1.5006e+01 1.0976e+02 2.8500e+02 4.0000e+00]\n",
            " [9.7037e+01 3.1396e+00 2.4970e+03 6.0000e+00]\n",
            " [4.5479e+01 5.2111e+01 1.1030e+03 4.0000e+00]\n",
            " [7.9174e+01 5.3813e+01 2.0300e+02 3.0000e+00]\n",
            " [8.9545e+01 5.5188e+01 4.8640e+03 7.0000e+00]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [50000050.]\n",
            "\tPDG [50000050.] wrong >> skip\n",
            "index_particle 704  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[ 10.  20.  77. 121.  23.  33.  20.  79.  42. 162.  37.  49.   5. 167.\n",
            "   28.  11.   4.  12.  29.   9.]]\n",
            "values_data_dict q_values  [ 10.  20.  77. 121.  23.  33.  20.  79.  42. 162.  37.  49.   5. 167.\n",
            "  28.  11.   4.  12.  29.   9.]\n",
            "size_padded  [[1. 1. 2. 3. 2. 2. 1. 4. 2. 4. 2. 3. 1. 4. 2. 1. 1. 2. 1. 1.]]\n",
            "values_data_dict mSize_values  [1. 1. 2. 3. 2. 2. 1. 4. 2. 4. 2. 3. 1. 4. 2. 1. 1. 2. 1. 1.]\n",
            "mip_mask_condition true_count_mip 6\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 80\n",
            "nonzero p_value[z_mask]: [[21]\n",
            " [21]\n",
            " [21]\n",
            " [16]\n",
            " [ 1]]\n",
            "nonzero p_value[mip_mask]: 80\n",
            "nonzero p_value[mip_mask]: [[21]\n",
            " [21]\n",
            " [21]\n",
            " [16]\n",
            " [ 1]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[  95.5376   62.7769  573.        5.    ]\n",
            " [  63.5978   94.7377  949.        3.    ]\n",
            " [   4.9553   71.1815 1219.        5.    ]\n",
            " [  30.5662   50.629  2453.        6.    ]\n",
            " [  56.3117   63.3542  638.        5.    ]\n",
            " [  20.809    20.2141  765.        4.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 21 num_kaons 16 num_protons 1\n",
            "index_particle 707  num_tracks_in_event 2\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False  True False False False False False  True False False False\n",
            "  False False False  True False False False False]]\n",
            "q_padded  [[ 84.   6. 717.   9. 180.  38.  52. 151. 212.  19.   5.  61.  16.   7.\n",
            "   27. 219.  11.  53. 143.  55.]]\n",
            "values_data_dict q_values  [ 84.   6. 717.   9. 180.  38.  52. 151. 212.  19.   5.  61.  16.   7.\n",
            "  27. 219.  11.  53. 143.  55.]\n",
            "size_padded  [[4. 1. 4. 1. 3. 2. 2. 5. 6. 1. 1. 2. 2. 1. 2. 3. 1. 2. 3. 1.]]\n",
            "values_data_dict mSize_values  [4. 1. 4. 1. 3. 2. 2. 5. 6. 1. 1. 2. 2. 1. 2. 3. 1. 2. 3. 1.]\n",
            "mip_mask_condition true_count_mip 10\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (3, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (3, 550, 5)\n",
            "shape of z-score array: (3, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 8250\n",
            "nonzero p_value: [[1650]\n",
            " [1650]\n",
            " [1650]\n",
            " [1650]\n",
            " [1650]]\n",
            "nonzero p_value[z_mask]: 425\n",
            "nonzero p_value[z_mask]: [[109]\n",
            " [108]\n",
            " [108]\n",
            " [ 88]\n",
            " [ 12]]\n",
            "nonzero p_value[mip_mask]: 425\n",
            "nonzero p_value[mip_mask]: [[109]\n",
            " [108]\n",
            " [108]\n",
            " [ 88]\n",
            " [ 12]]\n",
            "high_charge_size  [[0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0]\n",
            " [0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0]\n",
            " [0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0]]\n",
            "num_tracks_in_event 2\n",
            "mips [[4.0260e+00 3.5989e+01 7.1700e+02 4.0000e+00]\n",
            " [1.3794e+01 3.7791e+01 2.1200e+02 6.0000e+00]\n",
            " [1.0209e+02 5.7490e+01 2.1900e+02 3.0000e+00]\n",
            " [4.8942e+01 1.2049e+02 1.0690e+03 5.0000e+00]\n",
            " [5.0933e+01 3.2263e+01 2.0100e+02 4.0000e+00]\n",
            " [2.8909e+01 7.7176e+00 9.5900e+02 4.0000e+00]\n",
            " [3.9789e+01 3.0963e+01 5.6400e+02 4.0000e+00]\n",
            " [2.6577e+01 8.3967e+00 3.0410e+03 6.0000e+00]\n",
            " [4.0529e+01 9.3479e+01 4.7300e+02 4.0000e+00]\n",
            " [3.2332e+01 2.5854e+01 4.0300e+02 4.0000e+00]]\n",
            "L_all_tracks (550, 3) \n",
            "pion_mask2.shape (550, 3, 12)\n",
            "index 0 of 2 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 49 num_kaons 40 num_protons 3\n",
            "index 1 of 2 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 1\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 59 num_kaons 48 num_protons 9\n",
            "index 2 of 2 : pdg [50000050.]\n",
            "\tPDG [50000050.] wrong >> skip\n",
            "index_particle 709  num_tracks_in_event 1\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False False  True False\n",
            "  False False False False False  True False False]]\n",
            "q_padded  [[ 109.   17.  124.    7.   18.   17.   59.   17.   66.   97. 3217.   70.\n",
            "    31.   73.   36.  103.   73. 1017.   46.  139.]]\n",
            "values_data_dict q_values  [ 109.   17.  124.    7.   18.   17.   59.   17.   66.   97. 3217.   70.\n",
            "   31.   73.   36.  103.   73. 1017.   46.  139.]\n",
            "size_padded  [[4. 1. 4. 1. 2. 2. 1. 2. 2. 5. 7. 2. 2. 2. 2. 2. 4. 5. 3. 4.]]\n",
            "values_data_dict mSize_values  [4. 1. 4. 1. 2. 2. 1. 2. 2. 5. 7. 2. 2. 2. 2. 2. 4. 5. 3. 4.]\n",
            "mip_mask_condition true_count_mip 20\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (2, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (2, 550, 5)\n",
            "shape of z-score array: (2, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 5500\n",
            "nonzero p_value: [[1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]]\n",
            "nonzero p_value[z_mask]: 212\n",
            "nonzero p_value[z_mask]: [[54]\n",
            " [53]\n",
            " [52]\n",
            " [42]\n",
            " [11]]\n",
            "nonzero p_value[mip_mask]: 212\n",
            "nonzero p_value[mip_mask]: [[54]\n",
            " [53]\n",
            " [52]\n",
            " [42]\n",
            " [11]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0]\n",
            " [0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0]]\n",
            "num_tracks_in_event 1\n",
            "mips [[5.5312e+01 4.6911e+01 3.2170e+03 7.0000e+00]\n",
            " [1.2234e+02 1.2018e+02 1.0170e+03 5.0000e+00]\n",
            " [4.7652e+01 9.7830e+01 2.6800e+02 3.0000e+00]\n",
            " [1.0004e+02 3.2123e+01 1.6750e+03 6.0000e+00]\n",
            " [6.1141e+01 6.4641e+01 1.2680e+03 6.0000e+00]\n",
            " [6.2120e+01 6.5686e+01 4.3200e+02 4.0000e+00]\n",
            " [7.1222e+01 6.0366e+01 2.9600e+02 5.0000e+00]\n",
            " [1.2585e+02 8.9062e+01 5.4300e+02 6.0000e+00]\n",
            " [1.2182e+02 5.5087e+01 7.9170e+03 7.0000e+00]\n",
            " [1.1879e+02 5.8515e+01 8.4400e+02 5.0000e+00]\n",
            " [4.1086e+01 9.6155e+01 7.4800e+02 6.0000e+00]\n",
            " [4.1544e+01 9.8091e+01 3.9900e+02 5.0000e+00]\n",
            " [5.2374e+01 9.8562e+01 2.1200e+02 3.0000e+00]\n",
            " [2.1577e+01 6.0173e+01 1.1810e+03 6.0000e+00]\n",
            " [2.1767e+01 6.2398e+01 7.5000e+02 4.0000e+00]\n",
            " [2.9958e+01 7.5381e+01 2.1200e+02 3.0000e+00]\n",
            " [4.5640e+01 2.0289e+01 3.0900e+02 4.0000e+00]\n",
            " [4.7552e+01 1.7719e+01 8.4600e+02 6.0000e+00]\n",
            " [1.4652e+01 8.6294e+01 4.9000e+02 3.0000e+00]\n",
            " [3.8550e+01 6.7981e+01 2.9800e+02 4.0000e+00]]\n",
            "L_all_tracks (550, 2) \n",
            "pion_mask2.shape (550, 2, 12)\n",
            "index 0 of 1 : pdg [11.]\n",
            "\tPDG [11.] wrong >> skip\n",
            "index 1 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 712  num_tracks_in_event 2\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False  True False False\n",
            "  False False  True False False False False False]]\n",
            "q_padded  [[ 39.  22.  48.  79.  14.  42.  22.   9.  24. 301.  29. 133.  28. 106.\n",
            "  316. 123.  64. 129.   4. 174.]]\n",
            "values_data_dict q_values  [ 39.  22.  48.  79.  14.  42.  22.   9.  24. 301.  29. 133.  28. 106.\n",
            " 316. 123.  64. 129.   4. 174.]\n",
            "size_padded  [[3. 1. 4. 4. 2. 2. 2. 1. 2. 3. 2. 2. 2. 2. 4. 4. 3. 2. 1. 3.]]\n",
            "values_data_dict mSize_values  [3. 1. 4. 4. 2. 2. 2. 1. 2. 3. 2. 2. 2. 2. 4. 4. 3. 2. 1. 3.]\n",
            "mip_mask_condition true_count_mip 21\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (3, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (3, 550, 5)\n",
            "shape of z-score array: (3, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 8250\n",
            "nonzero p_value: [[1650]\n",
            " [1650]\n",
            " [1650]\n",
            " [1650]\n",
            " [1650]]\n",
            "nonzero p_value[z_mask]: 439\n",
            "nonzero p_value[z_mask]: [[109]\n",
            " [107]\n",
            " [107]\n",
            " [101]\n",
            " [ 15]]\n",
            "nonzero p_value[mip_mask]: 439\n",
            "nonzero p_value[mip_mask]: [[109]\n",
            " [107]\n",
            " [107]\n",
            " [101]\n",
            " [ 15]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0]\n",
            " [0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0]\n",
            " [0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0]]\n",
            "num_tracks_in_event 2\n",
            "mips [[  62.9121   22.4215  301.        3.    ]\n",
            " [  74.6405   27.4081  316.        4.    ]\n",
            " [  86.4482   12.1502  958.        5.    ]\n",
            " [ 121.6243  103.8525  468.        4.    ]\n",
            " [  98.5489  104.6303 1275.        6.    ]\n",
            " [  70.2689   36.8474  655.        5.    ]\n",
            " [  14.5521  114.484   600.        4.    ]\n",
            " [  27.0849   65.5605 2383.        4.    ]\n",
            " [  25.7849   57.6198  267.        7.    ]\n",
            " [ 109.7085   43.2807 1231.        4.    ]\n",
            " [ 124.3423  111.9499  205.        3.    ]\n",
            " [ 129.753     3.547   852.        4.    ]\n",
            " [ 100.2956   89.9443  749.        4.    ]\n",
            " [  79.3001   27.4624  880.        5.    ]\n",
            " [ 130.0265  124.4127  601.        4.    ]\n",
            " [  99.3524   18.2244  326.        4.    ]\n",
            " [ 111.0481   21.      398.        4.    ]\n",
            " [ 129.4883   13.0377  287.        4.    ]\n",
            " [  84.4894   20.4448  566.        5.    ]\n",
            " [ 125.3164   75.7299  302.        4.    ]]\n",
            "L_all_tracks (550, 3) \n",
            "pion_mask2.shape (550, 3, 12)\n",
            "index 0 of 2 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 52 num_kaons 50 num_protons 8\n",
            "index 1 of 2 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 1\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 55 num_kaons 51 num_protons 7\n",
            "index 2 of 2 : pdg [50000050.]\n",
            "\tPDG [50000050.] wrong >> skip\n",
            "index_particle 713  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False False False False\n",
            "  False  True False False False False False False]]\n",
            "q_padded  [[ 54.  22.  98.  13.  60.  90.  34.  49.   5.  18.  14.   9.   9. 519.\n",
            "   17.  16.  41.  28.   4. 119.]]\n",
            "values_data_dict q_values  [ 54.  22.  98.  13.  60.  90.  34.  49.   5.  18.  14.   9.   9. 519.\n",
            "  17.  16.  41.  28.   4. 119.]\n",
            "size_padded  [[3. 2. 4. 1. 1. 4. 2. 3. 1. 1. 1. 1. 1. 6. 1. 2. 2. 3. 1. 3.]]\n",
            "values_data_dict mSize_values  [3. 2. 4. 1. 1. 4. 2. 3. 1. 1. 1. 1. 1. 6. 1. 2. 2. 3. 1. 3.]\n",
            "mip_mask_condition true_count_mip 17\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 74\n",
            "nonzero p_value[z_mask]: [[20]\n",
            " [20]\n",
            " [20]\n",
            " [ 5]\n",
            " [ 9]]\n",
            "nonzero p_value[mip_mask]: 74\n",
            "nonzero p_value[mip_mask]: [[20]\n",
            " [20]\n",
            " [20]\n",
            " [ 5]\n",
            " [ 9]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[  75.4245   63.4953  519.        6.    ]\n",
            " [  87.3627   53.3996  260.        3.    ]\n",
            " [  60.3359   65.4347  203.        3.    ]\n",
            " [  46.6007   92.9682 1359.        7.    ]\n",
            " [  62.8328   78.8097  580.        4.    ]\n",
            " [ 123.4549   33.3187  747.        5.    ]\n",
            " [ 125.6304   63.3307  883.        5.    ]\n",
            " [  11.877   125.3018 1067.        4.    ]\n",
            " [  10.022    71.9321  700.        5.    ]\n",
            " [ 103.8702   70.9356  923.        5.    ]\n",
            " [  93.2797   76.3258  346.       18.    ]\n",
            " [  94.8663   95.3593  853.        6.    ]\n",
            " [  69.1772   22.3849  893.        5.    ]\n",
            " [  87.2286  116.2797  780.        4.    ]\n",
            " [ 129.7088   21.7726  348.        4.    ]\n",
            " [  92.6349   93.8923 1460.        5.    ]\n",
            " [ 124.234    16.8024  215.        3.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 714  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False  True False False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[  98.   18.  166.   22.   46. 1090.   15.  153.    8.   40.   40.   23.\n",
            "    70.    8.   56.    4.   37.   19.   42.   37.]]\n",
            "values_data_dict q_values  [  98.   18.  166.   22.   46. 1090.   15.  153.    8.   40.   40.   23.\n",
            "   70.    8.   56.    4.   37.   19.   42.   37.]\n",
            "size_padded  [[2. 1. 3. 1. 1. 7. 2. 4. 1. 1. 1. 1. 3. 1. 4. 1. 4. 1. 3. 2.]]\n",
            "values_data_dict mSize_values  [2. 1. 3. 1. 1. 7. 2. 4. 1. 1. 1. 1. 3. 1. 4. 1. 4. 1. 3. 2.]\n",
            "mip_mask_condition true_count_mip 10\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 27\n",
            "nonzero p_value[z_mask]: [[6]\n",
            " [6]\n",
            " [6]\n",
            " [5]\n",
            " [4]]\n",
            "nonzero p_value[mip_mask]: 27\n",
            "nonzero p_value[mip_mask]: [[6]\n",
            " [6]\n",
            " [6]\n",
            " [5]\n",
            " [4]]\n",
            "high_charge_size  [[0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[  79.8221   94.4037 1090.        7.    ]\n",
            " [  92.5592    2.6306  235.        3.    ]\n",
            " [  43.0921   56.0974  202.        3.    ]\n",
            " [  36.7541   61.9691  247.        4.    ]\n",
            " [  37.3769  113.2932 1856.        6.    ]\n",
            " [ 113.6201   92.6391  965.        6.    ]\n",
            " [ 125.5082   98.7498  354.        3.    ]\n",
            " [  37.8283  106.1659  285.        4.    ]\n",
            " [  80.4692   79.3049  530.        4.    ]\n",
            " [  92.1482   76.8268  222.        3.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 716  num_tracks_in_event 1\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False  True False False False False False False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[ 18. 312.  43.   4.  28.  64.  42.  58.  42. 151. 122.  26.   7.  41.\n",
            "   53.  94. 115.  58.  87.  11.]]\n",
            "values_data_dict q_values  [ 18. 312.  43.   4.  28.  64.  42.  58.  42. 151. 122.  26.   7.  41.\n",
            "  53.  94. 115.  58.  87.  11.]\n",
            "size_padded  [[1. 4. 6. 1. 1. 2. 2. 1. 1. 3. 3. 2. 1. 3. 2. 4. 3. 1. 4. 1.]]\n",
            "values_data_dict mSize_values  [1. 4. 6. 1. 1. 2. 2. 1. 1. 3. 3. 2. 1. 3. 2. 4. 3. 1. 4. 1.]\n",
            "mip_mask_condition true_count_mip 4\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (2, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (2, 550, 5)\n",
            "shape of z-score array: (2, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 5500\n",
            "nonzero p_value: [[1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]]\n",
            "nonzero p_value[z_mask]: 58\n",
            "nonzero p_value[z_mask]: [[15]\n",
            " [15]\n",
            " [15]\n",
            " [13]\n",
            " [ 0]]\n",
            "nonzero p_value[mip_mask]: 58\n",
            "nonzero p_value[mip_mask]: [[15]\n",
            " [15]\n",
            " [15]\n",
            " [13]\n",
            " [ 0]]\n",
            "high_charge_size  [[0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n",
            " [0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 1\n",
            "mips [[106.5489  45.9234 312.       4.    ]\n",
            " [ 69.1492  64.3101 588.       4.    ]\n",
            " [ 46.7999  99.1624 216.       3.    ]\n",
            " [ 89.472  102.8778 681.       5.    ]]\n",
            "L_all_tracks (550, 2) \n",
            "pion_mask2.shape (550, 2, 12)\n",
            "index 0 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 15 num_kaons 13 num_protons 0\n",
            "index 1 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 717  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False  True False False False False False False False False False\n",
            "  False False  True False False False False False]]\n",
            "q_padded  [[ 108.  143. 1020.   28.   28.   69.   45.   21.   15.    6.  152.   21.\n",
            "    68.   46.  292.   64.   44.   22.  101.   15.]]\n",
            "values_data_dict q_values  [ 108.  143. 1020.   28.   28.   69.   45.   21.   15.    6.  152.   21.\n",
            "   68.   46.  292.   64.   44.   22.  101.   15.]\n",
            "size_padded  [[3. 3. 4. 2. 1. 3. 2. 2. 2. 1. 3. 2. 3. 1. 9. 3. 2. 2. 4. 2.]]\n",
            "values_data_dict mSize_values  [3. 3. 4. 2. 1. 3. 2. 2. 2. 1. 3. 2. 3. 1. 9. 3. 2. 2. 4. 2.]\n",
            "mip_mask_condition true_count_mip 6\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 24\n",
            "nonzero p_value[z_mask]: [[6]\n",
            " [6]\n",
            " [6]\n",
            " [5]\n",
            " [1]]\n",
            "nonzero p_value[mip_mask]: 24\n",
            "nonzero p_value[mip_mask]: [[6]\n",
            " [6]\n",
            " [6]\n",
            " [5]\n",
            " [1]]\n",
            "high_charge_size  [[0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[1.0443e+02 1.1189e+02 1.0200e+03 4.0000e+00]\n",
            " [9.7369e+01 1.0765e+02 2.9200e+02 9.0000e+00]\n",
            " [5.8856e+01 6.0446e+01 1.8660e+03 7.0000e+00]\n",
            " [1.1757e+02 4.3888e+01 3.8700e+02 4.0000e+00]\n",
            " [1.3194e+00 1.0441e+02 2.6330e+03 7.0000e+00]\n",
            " [7.8635e+00 5.1368e+01 5.1500e+02 6.0000e+00]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 719  num_tracks_in_event 1\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False  True False False False False False\n",
            "   True False False False False False False False]]\n",
            "q_padded  [[  5. 133.   7.  39. 124.   5. 312.  63.  25.  93.  12. 131. 247.  78.\n",
            "   22.  10.   9. 137.  38. 101.]]\n",
            "values_data_dict q_values  [  5. 133.   7.  39. 124.   5. 312.  63.  25.  93.  12. 131. 247.  78.\n",
            "  22.  10.   9. 137.  38. 101.]\n",
            "size_padded  [[1. 3. 1. 2. 4. 1. 4. 3. 2. 3. 2. 3. 4. 2. 1. 1. 1. 4. 2. 2.]]\n",
            "values_data_dict mSize_values  [1. 3. 1. 2. 4. 1. 4. 3. 2. 3. 2. 3. 4. 2. 1. 1. 1. 4. 2. 2.]\n",
            "mip_mask_condition true_count_mip 12\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (2, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (2, 550, 5)\n",
            "shape of z-score array: (2, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 5500\n",
            "nonzero p_value: [[1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]]\n",
            "nonzero p_value[z_mask]: 89\n",
            "nonzero p_value[z_mask]: [[20]\n",
            " [21]\n",
            " [21]\n",
            " [20]\n",
            " [ 7]]\n",
            "nonzero p_value[mip_mask]: 89\n",
            "nonzero p_value[mip_mask]: [[20]\n",
            " [21]\n",
            " [21]\n",
            " [20]\n",
            " [ 7]]\n",
            "high_charge_size  [[0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0]\n",
            " [0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 1\n",
            "mips [[  35.6504   35.8592  312.        4.    ]\n",
            " [  43.0803   46.4279  247.        4.    ]\n",
            " [ 114.8678   44.255   425.        5.    ]\n",
            " [  93.1497   75.8562  203.        4.    ]\n",
            " [  95.3225   71.732   206.        4.    ]\n",
            " [  75.3637  114.5351  320.        4.    ]\n",
            " [  42.1247   17.7508  243.        4.    ]\n",
            " [  45.0661   37.9108  914.        5.    ]\n",
            " [  40.7676    7.1124 2090.        4.    ]\n",
            " [  61.7609   88.8438  437.        4.    ]\n",
            " [  11.6384   55.6018  301.        3.    ]\n",
            " [  19.8929   52.9937  267.        4.    ]]\n",
            "L_all_tracks (550, 2) \n",
            "pion_mask2.shape (550, 2, 12)\n",
            "index 0 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 21 num_kaons 20 num_protons 7\n",
            "index 1 of 1 : pdg [11.]\n",
            "\tPDG [11.] wrong >> skip\n",
            "index_particle 720  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False False False False\n",
            "  False  True False False False False False False]]\n",
            "q_padded  [[  46.   11.    6.   48.  107.   48.   18.    4.   44.   12.  126.  179.\n",
            "    19. 1772.    9.   62.    0.    0.    0.    0.]]\n",
            "values_data_dict q_values  [  46.   11.    6.   48.  107.   48.   18.    4.   44.   12.  126.  179.\n",
            "   19. 1772.    9.   62.    0.    0.    0.    0.]\n",
            "size_padded  [[1. 1. 1. 2. 3. 2. 2. 1. 2. 1. 3. 4. 1. 4. 1. 3. 0. 0. 0. 0.]]\n",
            "values_data_dict mSize_values  [1. 1. 1. 2. 3. 2. 2. 1. 2. 1. 3. 4. 1. 4. 1. 3. 0. 0. 0. 0.]\n",
            "mip_mask_condition true_count_mip 1\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 12\n",
            "nonzero p_value[z_mask]: [[3]\n",
            " [3]\n",
            " [3]\n",
            " [2]\n",
            " [1]]\n",
            "nonzero p_value[mip_mask]: 12\n",
            "nonzero p_value[mip_mask]: [[3]\n",
            " [3]\n",
            " [3]\n",
            " [2]\n",
            " [1]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[   7.1884   45.3604 1772.        4.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [50000050.]\n",
            "\tPDG [50000050.] wrong >> skip\n",
            "index_particle 721  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False False False False\n",
            "  False False False False  True False False False]]\n",
            "q_padded  [[ 38.  33.   4.  33.  78.  22.  18.  17.  60.  81.  51.  16.   4.  74.\n",
            "  160.  89. 233.  90.  20.  24.]]\n",
            "values_data_dict q_values  [ 38.  33.   4.  33.  78.  22.  18.  17.  60.  81.  51.  16.   4.  74.\n",
            " 160.  89. 233.  90.  20.  24.]\n",
            "size_padded  [[3. 2. 1. 3. 2. 2. 2. 2. 3. 2. 3. 1. 1. 2. 3. 4. 4. 4. 3. 2.]]\n",
            "values_data_dict mSize_values  [3. 2. 1. 3. 2. 2. 2. 2. 3. 2. 3. 1. 1. 2. 3. 4. 4. 4. 3. 2.]\n",
            "mip_mask_condition true_count_mip 8\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 1\n",
            "nonzero p_value[z_mask]: [[0]\n",
            " [0]\n",
            " [0]\n",
            " [0]\n",
            " [1]]\n",
            "nonzero p_value[mip_mask]: 1\n",
            "nonzero p_value[mip_mask]: [[0]\n",
            " [0]\n",
            " [0]\n",
            " [0]\n",
            " [1]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[1.0412e+02 1.8309e+01 2.3300e+02 4.0000e+00]\n",
            " [5.2554e+01 5.5893e+01 9.2900e+02 5.0000e+00]\n",
            " [6.2418e+01 5.1105e+01 7.3100e+02 4.0000e+00]\n",
            " [1.1869e+02 1.1353e+02 6.0100e+02 4.0000e+00]\n",
            " [1.1343e+02 1.4500e+01 3.4920e+03 7.0000e+00]\n",
            " [7.7564e+01 1.0540e+02 1.4020e+03 6.0000e+00]\n",
            " [7.1630e+01 1.0806e+02 9.2200e+02 5.0000e+00]\n",
            " [1.9937e-01 8.6640e+01 5.3760e+03 4.0000e+00]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "PDG [211.] skip >> ckovRecon [-11.]\n",
            "index_particle 722  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False False False False\n",
            "   True False False False  True False False False]]\n",
            "q_padded  [[  60.  157.   35.   17.  107.   14.   32.   26.   69.   13.   33.    0.\n",
            "  3074.    4.   30.    8. 2425.   43.    9.   30.]]\n",
            "values_data_dict q_values  [  60.  157.   35.   17.  107.   14.   32.   26.   69.   13.   33.    0.\n",
            " 3074.    4.   30.    8. 2425.   43.    9.   30.]\n",
            "size_padded  [[3. 2. 2. 1. 7. 1. 1. 1. 2. 1. 1. 8. 7. 1. 1. 1. 7. 3. 1. 1.]]\n",
            "values_data_dict mSize_values  [3. 2. 2. 1. 7. 1. 1. 1. 2. 1. 1. 8. 7. 1. 1. 1. 7. 3. 1. 1.]\n",
            "mip_mask_condition true_count_mip 17\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 51\n",
            "nonzero p_value[z_mask]: [[13]\n",
            " [13]\n",
            " [13]\n",
            " [12]\n",
            " [ 0]]\n",
            "nonzero p_value[mip_mask]: 51\n",
            "nonzero p_value[mip_mask]: [[13]\n",
            " [13]\n",
            " [13]\n",
            " [12]\n",
            " [ 0]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[5.7704e+01 5.0682e+01 3.0740e+03 7.0000e+00]\n",
            " [4.4244e+01 6.7704e+01 2.4250e+03 7.0000e+00]\n",
            " [8.3508e+01 1.0441e+02 9.9400e+02 4.0000e+00]\n",
            " [8.3349e+01 5.7115e+01 2.0700e+02 4.0000e+00]\n",
            " [4.7520e+01 6.8455e+01 1.3950e+03 5.0000e+00]\n",
            " [1.1845e+01 4.9813e+01 1.3520e+03 5.0000e+00]\n",
            " [7.6861e+01 8.6884e+01 2.1200e+02 4.0000e+00]\n",
            " [9.5754e+01 9.5088e+01 9.4750e+03 7.0000e+00]\n",
            " [8.9203e+01 5.7109e+01 2.2000e+02 4.0000e+00]\n",
            " [1.0054e+02 5.6507e+01 1.6880e+03 7.0000e+00]\n",
            " [1.0017e+02 5.8051e+01 2.0700e+03 4.0000e+00]\n",
            " [5.6515e+01 6.0598e+01 1.5260e+03 6.0000e+00]\n",
            " [7.8555e+01 6.5848e+01 3.1260e+03 6.0000e+00]\n",
            " [7.1094e+01 1.8369e+01 4.2500e+02 4.0000e+00]\n",
            " [4.3820e+01 9.7507e+01 1.5340e+03 5.0000e+00]\n",
            " [1.2729e+02 3.1792e+01 1.5720e+03 4.0000e+00]\n",
            " [9.7505e+01 7.5771e+01 2.5200e+02 4.0000e+00]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 13 num_kaons 12 num_protons 0\n",
            "index_particle 723  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False  True  True False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[ 18. 107.  41.  43. 122.  55.   7. 928. 280. 192.  55. 103.   6.  43.\n",
            "   29.  20.  20.  57.  18.  20.]]\n",
            "values_data_dict q_values  [ 18. 107.  41.  43. 122.  55.   7. 928. 280. 192.  55. 103.   6.  43.\n",
            "  29.  20.  20.  57.  18.  20.]\n",
            "size_padded  [[2. 3. 3. 2. 2. 3. 1. 6. 4. 3. 2. 7. 1. 2. 2. 1. 1. 2. 1. 2.]]\n",
            "values_data_dict mSize_values  [2. 3. 3. 2. 2. 3. 1. 6. 4. 3. 2. 7. 1. 2. 2. 1. 1. 2. 1. 2.]\n",
            "mip_mask_condition true_count_mip 9\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 56\n",
            "nonzero p_value[z_mask]: [[14]\n",
            " [14]\n",
            " [14]\n",
            " [13]\n",
            " [ 1]]\n",
            "nonzero p_value[mip_mask]: 56\n",
            "nonzero p_value[mip_mask]: [[14]\n",
            " [14]\n",
            " [14]\n",
            " [13]\n",
            " [ 1]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[  43.4552   96.1081  928.        6.    ]\n",
            " [  33.1586   91.5254  280.        4.    ]\n",
            " [  87.3983   63.9737  266.        4.    ]\n",
            " [ 108.6131   78.8863  924.        6.    ]\n",
            " [  59.5551   78.1724  640.        6.    ]\n",
            " [ 105.8689   89.5268 1399.        6.    ]\n",
            " [  99.0136   91.4823  407.        4.    ]\n",
            " [  75.1806  105.5103  409.        4.    ]\n",
            " [  77.9215   21.2806  263.        4.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 14 num_kaons 13 num_protons 1\n",
            "index_particle 724  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False  True False False False False False False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[ 37. 814.  28.  99.  91.  66.  17. 134.  11.  30.  11.  52. 147.  42.\n",
            "   23.  49.  95.  18.  17.  22.]]\n",
            "values_data_dict q_values  [ 37. 814.  28.  99.  91.  66.  17. 134.  11.  30.  11.  52. 147.  42.\n",
            "  23.  49.  95.  18.  17.  22.]\n",
            "size_padded  [[2. 4. 2. 3. 2. 4. 2. 3. 1. 1. 1. 1. 5. 2. 2. 2. 3. 2. 2. 1.]]\n",
            "values_data_dict mSize_values  [2. 4. 2. 3. 2. 4. 2. 3. 1. 1. 1. 1. 5. 2. 2. 2. 3. 2. 2. 1.]\n",
            "mip_mask_condition true_count_mip 13\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 11\n",
            "nonzero p_value[z_mask]: [[1]\n",
            " [1]\n",
            " [2]\n",
            " [4]\n",
            " [3]]\n",
            "nonzero p_value[mip_mask]: 11\n",
            "nonzero p_value[mip_mask]: [[1]\n",
            " [1]\n",
            " [2]\n",
            " [4]\n",
            " [3]]\n",
            "high_charge_size  [[0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[1.2269e+02 3.3733e+01 8.1400e+02 4.0000e+00]\n",
            " [9.6577e+01 4.7902e+01 4.2000e+02 5.0000e+00]\n",
            " [9.5413e+01 4.3227e+01 1.9320e+03 4.0000e+00]\n",
            " [2.8301e+01 9.5938e+01 3.9200e+02 4.0000e+00]\n",
            " [1.1277e+02 4.9506e+01 3.5900e+02 4.0000e+00]\n",
            " [6.0107e+00 1.0700e+02 5.5800e+02 4.0000e+00]\n",
            " [3.8404e+00 1.2237e+02 5.7500e+02 4.0000e+00]\n",
            " [2.5919e+01 7.0599e+01 8.3500e+02 5.0000e+00]\n",
            " [4.8520e+01 1.3118e+01 6.3200e+02 5.0000e+00]\n",
            " [5.2867e+01 1.0870e+02 7.6200e+02 4.0000e+00]\n",
            " [1.0043e+02 9.0454e+01 8.8400e+02 5.0000e+00]\n",
            " [7.8806e+01 8.6528e-01 4.5400e+02 4.0000e+00]\n",
            " [3.7063e+01 3.8075e+01 3.6880e+03 6.0000e+00]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 725  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False  True False False  True False False False False False\n",
            "  False  True False False False False False  True]]\n",
            "q_padded  [[ 75.  69.  15. 632. 143.  48. 564.  48.  26. 107.  11.  13.   8. 282.\n",
            "   41.  11.  35.   6. 348. 899.]]\n",
            "values_data_dict q_values  [ 75.  69.  15. 632. 143.  48. 564.  48.  26. 107.  11.  13.   8. 282.\n",
            "  41.  11.  35.   6. 348. 899.]\n",
            "size_padded  [[2. 4. 2. 6. 4. 2. 4. 4. 2. 3. 1. 2. 2. 4. 1. 1. 1. 1. 2. 5.]]\n",
            "values_data_dict mSize_values  [2. 4. 2. 6. 4. 2. 4. 4. 2. 3. 1. 2. 2. 4. 1. 1. 1. 1. 2. 5.]\n",
            "mip_mask_condition true_count_mip 11\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 28\n",
            "nonzero p_value[z_mask]: [[7]\n",
            " [7]\n",
            " [7]\n",
            " [7]\n",
            " [0]]\n",
            "nonzero p_value[mip_mask]: 28\n",
            "nonzero p_value[mip_mask]: [[7]\n",
            " [7]\n",
            " [7]\n",
            " [7]\n",
            " [0]]\n",
            "high_charge_size  [[0 0 0 1 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 1]]\n",
            "num_tracks_in_event 0\n",
            "mips [[ 122.5978   98.5883  632.        6.    ]\n",
            " [ 102.8118   78.6248  564.        4.    ]\n",
            " [ 108.6125   76.4338  282.        4.    ]\n",
            " [  93.7013   20.7146  899.        5.    ]\n",
            " [ 103.8155   37.5859  204.        3.    ]\n",
            " [  14.5157   10.1441  213.        4.    ]\n",
            " [  92.2203   21.9976  641.        4.    ]\n",
            " [  77.7325  103.2124 1709.        6.    ]\n",
            " [ 110.952    99.8648  714.        7.    ]\n",
            " [   4.5635   55.7795  361.        3.    ]\n",
            " [ 112.9859   98.6832  288.        4.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 726  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[ 50.  53.  79.   5.  80. 125.  59.  24.  14.  23.  27.  22.  14.  54.\n",
            "   50.  69.  47.   6.  74.  57.]]\n",
            "values_data_dict q_values  [ 50.  53.  79.   5.  80. 125.  59.  24.  14.  23.  27.  22.  14.  54.\n",
            "  50.  69.  47.   6.  74.  57.]\n",
            "size_padded  [[1. 4. 2. 1. 3. 3. 2. 2. 1. 2. 1. 2. 1. 2. 2. 4. 1. 1. 4. 3.]]\n",
            "values_data_dict mSize_values  [1. 4. 2. 1. 3. 3. 2. 2. 1. 2. 1. 2. 1. 2. 2. 4. 1. 1. 4. 3.]\n",
            "mip_mask_condition true_count_mip 8\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 20\n",
            "nonzero p_value[z_mask]: [[5]\n",
            " [5]\n",
            " [5]\n",
            " [5]\n",
            " [0]]\n",
            "nonzero p_value[mip_mask]: 20\n",
            "nonzero p_value[mip_mask]: [[5]\n",
            " [5]\n",
            " [5]\n",
            " [5]\n",
            " [0]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[1.2068e+02 5.3884e+01 3.9900e+02 4.0000e+00]\n",
            " [1.2382e+02 3.3763e+01 2.2380e+03 6.0000e+00]\n",
            " [1.2310e+02 3.3126e+01 9.1600e+02 4.0000e+00]\n",
            " [9.0323e+01 5.6713e+01 5.1600e+02 5.0000e+00]\n",
            " [7.8395e+01 8.0543e+01 1.4777e+04 1.1000e+01]\n",
            " [5.7526e+01 1.2388e+02 2.0310e+03 6.0000e+00]\n",
            " [9.0988e+01 6.8164e+01 7.2770e+03 9.0000e+00]\n",
            " [8.7410e+01 5.2599e+01 5.0900e+02 6.0000e+00]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 728  num_tracks_in_event 1\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False  True False False False False\n",
            "  False False  True False False False False False]]\n",
            "q_padded  [[  7. 197.  28.  22.  22. 124. 134. 327.  50.  58. 128.  81.  22.  57.\n",
            "  613.  75.  73.  35.  13.  46.]]\n",
            "values_data_dict q_values  [  7. 197.  28.  22.  22. 124. 134. 327.  50.  58. 128.  81.  22.  57.\n",
            " 613.  75.  73.  35.  13.  46.]\n",
            "size_padded  [[1. 5. 2. 2. 3. 4. 4. 5. 3. 4. 2. 3. 2. 2. 5. 4. 2. 2. 1. 3.]]\n",
            "values_data_dict mSize_values  [1. 5. 2. 2. 3. 4. 4. 5. 3. 4. 2. 3. 2. 2. 5. 4. 2. 2. 1. 3.]\n",
            "mip_mask_condition true_count_mip 13\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (2, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (2, 550, 5)\n",
            "shape of z-score array: (2, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 5500\n",
            "nonzero p_value: [[1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]]\n",
            "nonzero p_value[z_mask]: 117\n",
            "nonzero p_value[z_mask]: [[30]\n",
            " [30]\n",
            " [30]\n",
            " [25]\n",
            " [ 2]]\n",
            "nonzero p_value[mip_mask]: 117\n",
            "nonzero p_value[mip_mask]: [[30]\n",
            " [30]\n",
            " [30]\n",
            " [25]\n",
            " [ 2]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0]\n",
            " [0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0]]\n",
            "num_tracks_in_event 1\n",
            "mips [[  23.7817   28.7614  327.        5.    ]\n",
            " [  24.2967  118.8375  613.        5.    ]\n",
            " [  67.6604   86.2571  881.        4.    ]\n",
            " [  33.8585   87.1324 1759.        7.    ]\n",
            " [  15.6587   34.3373  821.        7.    ]\n",
            " [   4.645    81.7226  620.        4.    ]\n",
            " [  83.6143   62.0323  431.        4.    ]\n",
            " [  36.3734   52.2077  541.        6.    ]\n",
            " [  75.1178  108.4114 1738.        6.    ]\n",
            " [  33.188   116.4517  487.       23.    ]\n",
            " [ 117.7031   90.0732  574.        4.    ]\n",
            " [  78.3866   16.5355 1045.        6.    ]\n",
            " [  86.7802   49.4461  518.        4.    ]]\n",
            "L_all_tracks (550, 2) \n",
            "pion_mask2.shape (550, 2, 12)\n",
            "index 0 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 30 num_kaons 25 num_protons 2\n",
            "index 1 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 730  num_tracks_in_event 1\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False  True False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[ 51.  41.  56.  56.  25.  37.  29. 733. 158. 124.  70.  50.  52.  62.\n",
            "   79.  11. 114.  11.  15.   4.]]\n",
            "values_data_dict q_values  [ 51.  41.  56.  56.  25.  37.  29. 733. 158. 124.  70.  50.  52.  62.\n",
            "  79.  11. 114.  11.  15.   4.]\n",
            "size_padded  [[3. 1. 1. 2. 2. 2. 2. 4. 4. 4. 3. 3. 2. 3. 2. 1. 2. 2. 1. 1.]]\n",
            "values_data_dict mSize_values  [3. 1. 1. 2. 2. 2. 2. 4. 4. 4. 3. 3. 2. 3. 2. 1. 2. 2. 1. 1.]\n",
            "mip_mask_condition true_count_mip 15\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (2, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (2, 550, 5)\n",
            "shape of z-score array: (2, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 5500\n",
            "nonzero p_value: [[1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]]\n",
            "nonzero p_value[z_mask]: 96\n",
            "nonzero p_value[z_mask]: [[24]\n",
            " [24]\n",
            " [24]\n",
            " [19]\n",
            " [ 5]]\n",
            "nonzero p_value[mip_mask]: 96\n",
            "nonzero p_value[mip_mask]: [[24]\n",
            " [24]\n",
            " [24]\n",
            " [19]\n",
            " [ 5]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0]\n",
            " [0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 1\n",
            "mips [[1.1250e+02 3.1922e+01 7.3300e+02 4.0000e+00]\n",
            " [3.5216e+01 6.7316e+01 1.3510e+03 4.0000e+00]\n",
            " [3.0745e+01 6.8070e+01 1.6970e+03 6.0000e+00]\n",
            " [5.2349e+01 6.0381e+01 5.6000e+02 4.0000e+00]\n",
            " [1.2426e+02 6.6992e+01 2.0000e+02 4.0000e+00]\n",
            " [7.9791e+01 5.3306e+01 3.0500e+02 6.0000e+00]\n",
            " [8.6001e+01 3.8263e+01 2.0136e+04 1.4000e+01]\n",
            " [9.4540e+01 5.7859e+01 3.5500e+02 5.0000e+00]\n",
            " [1.8347e+01 2.4988e+01 2.3640e+03 6.0000e+00]\n",
            " [1.4395e+01 1.2191e+02 2.3300e+02 4.0000e+00]\n",
            " [1.7992e+00 1.2109e+02 2.1300e+02 6.0000e+00]\n",
            " [2.1777e+00 3.0790e+01 6.9800e+02 5.0000e+00]\n",
            " [2.8842e+01 6.1070e+01 7.6600e+02 6.0000e+00]\n",
            " [3.7056e+01 5.8004e+01 1.9590e+03 1.0000e+01]\n",
            " [9.5203e+01 8.7459e+01 1.0834e+04 8.0000e+00]]\n",
            "L_all_tracks (550, 2) \n",
            "pion_mask2.shape (550, 2, 12)\n",
            "index 0 of 1 : pdg [50000050.]\n",
            "\tPDG [50000050.] wrong >> skip\n",
            "index 1 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 731  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[ 18.  11.  15.   7.  19. 116.  24.  11.  24.  17.  84.  70.  41.  53.\n",
            "   62.  59.  25.  33.   5.  92.]]\n",
            "values_data_dict q_values  [ 18.  11.  15.   7.  19. 116.  24.  11.  24.  17.  84.  70.  41.  53.\n",
            "  62.  59.  25.  33.   5.  92.]\n",
            "size_padded  [[2. 1. 1. 1. 2. 3. 2. 2. 3. 2. 5. 2. 2. 3. 4. 1. 2. 2. 1. 4.]]\n",
            "values_data_dict mSize_values  [2. 1. 1. 1. 2. 3. 2. 2. 3. 2. 5. 2. 2. 3. 4. 1. 2. 2. 1. 4.]\n",
            "mip_mask_condition true_count_mip 6\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 40\n",
            "nonzero p_value[z_mask]: [[10]\n",
            " [10]\n",
            " [10]\n",
            " [10]\n",
            " [ 0]]\n",
            "nonzero p_value[mip_mask]: 40\n",
            "nonzero p_value[mip_mask]: [[10]\n",
            " [10]\n",
            " [10]\n",
            " [10]\n",
            " [ 0]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[  74.7698  113.7522  466.        4.    ]\n",
            " [  74.9033   49.5138  812.        5.    ]\n",
            " [ 105.7758  102.0378  277.        4.    ]\n",
            " [  95.5456   91.4807 1433.        5.    ]\n",
            " [  23.6838   11.6408  213.        3.    ]\n",
            " [  39.2098   25.961   332.       14.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 732  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False  True False False False False False False False  True False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[  48.   25. 3617.    8.   53.   22.   41.  146.    7.  197.  220.   34.\n",
            "     6.   37.   27.   46.   38.   35.    8.   20.]]\n",
            "values_data_dict q_values  [  48.   25. 3617.    8.   53.   22.   41.  146.    7.  197.  220.   34.\n",
            "    6.   37.   27.   46.   38.   35.    8.   20.]\n",
            "size_padded  [[4. 2. 7. 1. 2. 2. 2. 4. 1. 4. 4. 2. 1. 1. 1. 1. 1. 3. 1. 1.]]\n",
            "values_data_dict mSize_values  [4. 2. 7. 1. 2. 2. 2. 4. 1. 4. 4. 2. 1. 1. 1. 1. 1. 3. 1. 1.]\n",
            "mip_mask_condition true_count_mip 6\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 31\n",
            "nonzero p_value[z_mask]: [[8]\n",
            " [8]\n",
            " [8]\n",
            " [6]\n",
            " [1]]\n",
            "nonzero p_value[mip_mask]: 31\n",
            "nonzero p_value[mip_mask]: [[8]\n",
            " [8]\n",
            " [8]\n",
            " [6]\n",
            " [1]]\n",
            "high_charge_size  [[0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[1.0158e+02 2.9414e+01 3.6170e+03 7.0000e+00]\n",
            " [1.2600e+02 2.5640e+01 2.2000e+02 4.0000e+00]\n",
            " [1.0860e+02 1.1979e+02 2.0200e+02 4.0000e+00]\n",
            " [1.1128e+02 8.2913e+01 6.5700e+02 3.0000e+00]\n",
            " [1.2077e+02 1.8783e+01 2.0100e+02 3.0000e+00]\n",
            " [9.7698e+01 1.2451e+02 6.8300e+02 4.0000e+00]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 733  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False  True False False False False False False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[191. 240.  46.  14.  25.   7.  15.  17.  32.  10.   5.  33. 337.  32.\n",
            "    8.   8. 181.  11.  83.  27.]]\n",
            "values_data_dict q_values  [191. 240.  46.  14.  25.   7.  15.  17.  32.  10.   5.  33. 337.  32.\n",
            "   8.   8. 181.  11.  83.  27.]\n",
            "size_padded  [[4. 3. 5. 2. 1. 1. 1. 1. 1. 1. 1. 3. 2. 2. 1. 1. 4. 1. 3. 1.]]\n",
            "values_data_dict mSize_values  [4. 3. 5. 2. 1. 1. 1. 1. 1. 1. 1. 3. 2. 2. 1. 1. 4. 1. 3. 1.]\n",
            "mip_mask_condition true_count_mip 9\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 62\n",
            "nonzero p_value[z_mask]: [[16]\n",
            " [16]\n",
            " [16]\n",
            " [14]\n",
            " [ 0]]\n",
            "nonzero p_value[mip_mask]: 62\n",
            "nonzero p_value[mip_mask]: [[16]\n",
            " [16]\n",
            " [16]\n",
            " [14]\n",
            " [ 0]]\n",
            "high_charge_size  [[0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[3.5886e+01 7.5546e+01 2.4000e+02 3.0000e+00]\n",
            " [1.1461e+02 7.0187e+01 1.0500e+03 6.0000e+00]\n",
            " [1.1332e+02 6.8520e+01 6.4700e+02 5.0000e+00]\n",
            " [1.1954e+02 1.3121e+01 5.0800e+02 5.0000e+00]\n",
            " [7.1903e+01 9.7347e+01 4.7340e+03 8.0000e+00]\n",
            " [7.3780e+01 9.3194e+01 1.1740e+03 4.0000e+00]\n",
            " [6.8332e+01 9.5996e+01 2.4130e+03 6.0000e+00]\n",
            " [6.6998e+01 8.1497e+01 3.0960e+03 5.0000e+00]\n",
            " [6.1620e+01 1.0488e+02 7.9880e+03 1.2000e+01]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 16 num_kaons 14 num_protons 0\n",
            "index_particle 734  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False False  True False\n",
            "  False False False False  True False False False]]\n",
            "q_padded  [[  86.   42.   49.   22.   93.   42.   47.   46.   42.   29. 1780.   91.\n",
            "   106.   56.   29.   14.  244.   30.   49.   52.]]\n",
            "values_data_dict q_values  [  86.   42.   49.   22.   93.   42.   47.   46.   42.   29. 1780.   91.\n",
            "  106.   56.   29.   14.  244.   30.   49.   52.]\n",
            "size_padded  [[3. 4. 2. 2. 3. 2. 2. 2. 4. 1. 6. 8. 3. 3. 4. 2. 3. 1. 1. 2.]]\n",
            "values_data_dict mSize_values  [3. 4. 2. 2. 3. 2. 2. 2. 4. 1. 6. 8. 3. 3. 4. 2. 3. 1. 1. 2.]\n",
            "mip_mask_condition true_count_mip 16\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 19\n",
            "nonzero p_value[z_mask]: [[4]\n",
            " [4]\n",
            " [4]\n",
            " [4]\n",
            " [3]]\n",
            "nonzero p_value[mip_mask]: 19\n",
            "nonzero p_value[mip_mask]: [[4]\n",
            " [4]\n",
            " [4]\n",
            " [4]\n",
            " [3]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[8.9833e-01 2.0560e+01 1.7800e+03 6.0000e+00]\n",
            " [1.0556e+02 5.1928e+01 2.4400e+02 3.0000e+00]\n",
            " [8.2689e+01 1.2166e+02 8.9300e+02 5.0000e+00]\n",
            " [2.0445e+01 4.3443e+01 4.5400e+02 4.0000e+00]\n",
            " [2.1494e+01 1.1260e+02 7.8500e+02 4.0000e+00]\n",
            " [1.2254e+02 2.5779e+01 6.0300e+02 4.0000e+00]\n",
            " [8.7951e+01 5.4183e+01 7.7000e+02 5.0000e+00]\n",
            " [1.0602e+02 5.0915e+01 2.4700e+02 4.0000e+00]\n",
            " [2.1459e+01 6.4405e+01 3.9800e+02 4.0000e+00]\n",
            " [1.2551e+01 5.0950e+01 2.0900e+02 3.0000e+00]\n",
            " [7.4642e+01 5.3233e+01 7.2300e+02 4.0000e+00]\n",
            " [1.2364e+02 3.8989e+01 1.3400e+03 6.0000e+00]\n",
            " [6.5837e-01 8.1290e+00 5.4300e+02 4.0000e+00]\n",
            " [1.0569e+02 3.6020e+01 1.1540e+03 4.0000e+00]\n",
            " [2.8883e+01 1.0776e+02 2.2300e+02 4.0000e+00]\n",
            " [7.7402e+01 5.6542e+01 1.0110e+03 7.0000e+00]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [11.]\n",
            "\tPDG [11.] wrong >> skip\n",
            "index_particle 735  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False  True False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[ 78. 125.  16.  32.  56.  36.  64. 189.  94. 579.   5.  14. 184.  13.\n",
            "   93.  64.  43.  45.  31.  64.]]\n",
            "values_data_dict q_values  [ 78. 125.  16.  32.  56.  36.  64. 189.  94. 579.   5.  14. 184.  13.\n",
            "  93.  64.  43.  45.  31.  64.]\n",
            "size_padded  [[2. 3. 1. 1. 2. 1. 3. 4. 2. 4. 1. 2. 4. 1. 2. 2. 3. 3. 1. 1.]]\n",
            "values_data_dict mSize_values  [2. 3. 1. 1. 2. 1. 3. 4. 2. 4. 1. 2. 4. 1. 2. 2. 3. 3. 1. 1.]\n",
            "mip_mask_condition true_count_mip 15\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 7\n",
            "nonzero p_value[z_mask]: [[1]\n",
            " [1]\n",
            " [1]\n",
            " [1]\n",
            " [3]]\n",
            "nonzero p_value[mip_mask]: 7\n",
            "nonzero p_value[mip_mask]: [[1]\n",
            " [1]\n",
            " [1]\n",
            " [1]\n",
            " [3]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[7.8697e+01 3.7969e+01 5.7900e+02 4.0000e+00]\n",
            " [7.0424e+01 3.8615e+01 2.3200e+02 4.0000e+00]\n",
            " [1.9288e+01 3.3690e+01 8.9930e+03 8.0000e+00]\n",
            " [1.7805e+01 4.7204e+01 7.3040e+03 9.0000e+00]\n",
            " [2.2043e+01 3.8738e+01 2.7600e+02 3.0000e+00]\n",
            " [2.8139e+01 2.8431e+01 2.3700e+02 4.0000e+00]\n",
            " [2.1726e+01 1.2960e+01 2.8310e+03 7.0000e+00]\n",
            " [7.4416e+01 4.7540e+01 7.4100e+02 4.0000e+00]\n",
            " [2.7621e+01 1.2305e+02 3.9300e+02 4.0000e+00]\n",
            " [9.4931e+01 4.4725e+01 2.6900e+02 3.0000e+00]\n",
            " [1.2492e+02 8.0358e+01 6.6650e+03 7.0000e+00]\n",
            " [5.7572e+01 2.0508e+01 2.5090e+03 6.0000e+00]\n",
            " [7.5865e+01 7.2972e+01 6.3200e+02 5.0000e+00]\n",
            " [7.3436e+01 8.0093e+01 3.6860e+03 7.0000e+00]\n",
            " [9.8777e+01 7.8265e+01 5.1700e+02 4.0000e+00]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [50000050.]\n",
            "\tPDG [50000050.] wrong >> skip\n",
            "index_particle 736  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False  True False False  True False False False False False\n",
            "  False  True False False False False False  True]]\n",
            "q_padded  [[ 75.  69.  15. 632. 143.  48. 564.  48.  26. 107.  11.  13.   8. 282.\n",
            "   41.  11.  35.   6. 348. 899.]]\n",
            "values_data_dict q_values  [ 75.  69.  15. 632. 143.  48. 564.  48.  26. 107.  11.  13.   8. 282.\n",
            "  41.  11.  35.   6. 348. 899.]\n",
            "size_padded  [[2. 4. 2. 6. 4. 2. 4. 4. 2. 3. 1. 2. 2. 4. 1. 1. 1. 1. 2. 5.]]\n",
            "values_data_dict mSize_values  [2. 4. 2. 6. 4. 2. 4. 4. 2. 3. 1. 2. 2. 4. 1. 1. 1. 1. 2. 5.]\n",
            "mip_mask_condition true_count_mip 11\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 61\n",
            "nonzero p_value[z_mask]: [[13]\n",
            " [13]\n",
            " [13]\n",
            " [12]\n",
            " [10]]\n",
            "nonzero p_value[mip_mask]: 61\n",
            "nonzero p_value[mip_mask]: [[13]\n",
            " [13]\n",
            " [13]\n",
            " [12]\n",
            " [10]]\n",
            "high_charge_size  [[0 0 0 1 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 1]]\n",
            "num_tracks_in_event 0\n",
            "mips [[ 122.5978   98.5883  632.        6.    ]\n",
            " [ 102.8118   78.6248  564.        4.    ]\n",
            " [ 108.6125   76.4338  282.        4.    ]\n",
            " [  93.7013   20.7146  899.        5.    ]\n",
            " [ 103.8155   37.5859  204.        3.    ]\n",
            " [  14.5157   10.1441  213.        4.    ]\n",
            " [  92.2203   21.9976  641.        4.    ]\n",
            " [  77.7325  103.2124 1709.        6.    ]\n",
            " [ 110.952    99.8648  714.        7.    ]\n",
            " [   4.5635   55.7795  361.        3.    ]\n",
            " [ 112.9859   98.6832  288.        4.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [11.]\n",
            "\tPDG [11.] wrong >> skip\n",
            "index_particle 738  num_tracks_in_event 1\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False False  True False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[  52.   70.    6.    7.   30.   64.   12.   24.   15.   82. 1523.  139.\n",
            "    11.   40.    7.   48.    4.   10.   43.   85.]]\n",
            "values_data_dict q_values  [  52.   70.    6.    7.   30.   64.   12.   24.   15.   82. 1523.  139.\n",
            "   11.   40.    7.   48.    4.   10.   43.   85.]\n",
            "size_padded  [[1. 2. 1. 1. 5. 2. 1. 1. 2. 2. 6. 5. 2. 2. 1. 3. 1. 1. 3. 1.]]\n",
            "values_data_dict mSize_values  [1. 2. 1. 1. 5. 2. 1. 1. 2. 2. 6. 5. 2. 2. 1. 3. 1. 1. 3. 1.]\n",
            "mip_mask_condition true_count_mip 13\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (2, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (2, 550, 5)\n",
            "shape of z-score array: (2, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 5500\n",
            "nonzero p_value: [[1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]]\n",
            "nonzero p_value[z_mask]: 25\n",
            "nonzero p_value[z_mask]: [[6]\n",
            " [6]\n",
            " [6]\n",
            " [5]\n",
            " [2]]\n",
            "nonzero p_value[mip_mask]: 25\n",
            "nonzero p_value[mip_mask]: [[6]\n",
            " [6]\n",
            " [6]\n",
            " [5]\n",
            " [2]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0]\n",
            " [0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 1\n",
            "mips [[1.2292e+02 4.4471e+01 1.5230e+03 6.0000e+00]\n",
            " [5.6058e+01 1.2359e+01 4.8300e+02 4.0000e+00]\n",
            " [1.0892e+02 8.7798e+01 9.7100e+02 5.0000e+00]\n",
            " [4.7634e+01 1.0685e+02 4.9800e+02 6.0000e+00]\n",
            " [6.9679e+01 9.4305e+01 2.0600e+02 5.0000e+00]\n",
            " [6.3791e+01 9.7076e+01 1.0530e+03 4.0000e+00]\n",
            " [6.2177e+01 1.0245e+02 1.9170e+03 6.0000e+00]\n",
            " [6.1937e+01 9.9790e+01 3.1300e+02 5.0000e+00]\n",
            " [5.8967e+01 8.9314e+01 6.4450e+03 1.0000e+01]\n",
            " [2.6063e+01 9.2657e+01 2.3500e+02 3.0000e+00]\n",
            " [7.4569e+01 5.5822e+01 1.1770e+03 6.0000e+00]\n",
            " [1.2595e+02 1.0581e+02 1.4860e+03 5.0000e+00]\n",
            " [7.4920e+01 1.2257e+02 6.1500e+02 8.0000e+00]]\n",
            "L_all_tracks (550, 2) \n",
            "pion_mask2.shape (550, 2, 12)\n",
            "index 0 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index 1 of 1 : pdg [50000050.]\n",
            "\tPDG [50000050.] wrong >> skip\n",
            "index_particle 740  num_tracks_in_event 1\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[  6.  33.  80.  15.  45.  49.  74.  85.  35.  42.  37. 110.  14.  14.\n",
            "   39.  71.  46.   9.  28.  32.]]\n",
            "values_data_dict q_values  [  6.  33.  80.  15.  45.  49.  74.  85.  35.  42.  37. 110.  14.  14.\n",
            "  39.  71.  46.   9.  28.  32.]\n",
            "size_padded  [[1. 2. 2. 1. 3. 3. 4. 3. 2. 1. 1. 4. 1. 2. 1. 3. 2. 2. 1. 2.]]\n",
            "values_data_dict mSize_values  [1. 2. 2. 1. 3. 3. 4. 3. 2. 1. 1. 4. 1. 2. 1. 3. 2. 2. 1. 2.]\n",
            "mip_mask_condition true_count_mip 13\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (2, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (2, 550, 5)\n",
            "shape of z-score array: (2, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 5500\n",
            "nonzero p_value: [[1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]]\n",
            "nonzero p_value[z_mask]: 42\n",
            "nonzero p_value[z_mask]: [[11]\n",
            " [11]\n",
            " [11]\n",
            " [ 9]\n",
            " [ 0]]\n",
            "nonzero p_value[mip_mask]: 42\n",
            "nonzero p_value[mip_mask]: [[11]\n",
            " [11]\n",
            " [11]\n",
            " [ 9]\n",
            " [ 0]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n",
            " [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 1\n",
            "mips [[2.2502e+01 1.1515e+02 2.0700e+02 3.0000e+00]\n",
            " [1.7215e+00 1.2182e+02 2.1500e+02 4.0000e+00]\n",
            " [1.5210e+01 6.2807e+01 5.2800e+02 4.0000e+00]\n",
            " [6.0315e+01 7.9067e+01 3.5800e+02 4.0000e+00]\n",
            " [6.8845e+00 4.6963e+01 1.0490e+03 5.0000e+00]\n",
            " [6.8530e+01 5.4268e+01 6.6300e+02 5.0000e+00]\n",
            " [3.1549e+01 6.1034e+01 1.3260e+03 5.0000e+00]\n",
            " [2.6720e+01 5.2183e+01 2.6900e+02 4.0000e+00]\n",
            " [1.1694e+02 7.3637e+01 4.8000e+02 5.0000e+00]\n",
            " [6.9637e+01 2.3961e+01 5.5900e+02 4.0000e+00]\n",
            " [1.7556e+01 1.2218e+02 2.2300e+02 5.0000e+00]\n",
            " [2.4816e+01 1.1672e+02 9.8000e+02 9.0000e+00]\n",
            " [3.6270e+01 5.8116e+01 3.4640e+03 7.0000e+00]]\n",
            "L_all_tracks (550, 2) \n",
            "pion_mask2.shape (550, 2, 12)\n",
            "index 0 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 11 num_kaons 9 num_protons 0\n",
            "index 1 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 741  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False False False False False\n",
            "   True False False False False False  True False]]\n",
            "q_padded  [[  10.   27.   93.   98.   59.   22.   93.   22.   25.   32.   70.   85.\n",
            "  2434.   14.   32.  134.    4.   81. 1035.   90.]]\n",
            "values_data_dict q_values  [  10.   27.   93.   98.   59.   22.   93.   22.   25.   32.   70.   85.\n",
            " 2434.   14.   32.  134.    4.   81. 1035.   90.]\n",
            "size_padded  [[1. 1. 3. 4. 1. 1. 4. 2. 2. 2. 1. 3. 6. 1. 4. 2. 1. 3. 6. 4.]]\n",
            "values_data_dict mSize_values  [1. 1. 3. 4. 1. 1. 4. 2. 2. 2. 1. 3. 6. 1. 4. 2. 1. 3. 6. 4.]\n",
            "mip_mask_condition true_count_mip 11\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 2\n",
            "nonzero p_value[z_mask]: [[0]\n",
            " [0]\n",
            " [1]\n",
            " [1]\n",
            " [0]]\n",
            "nonzero p_value[mip_mask]: 2\n",
            "nonzero p_value[mip_mask]: [[0]\n",
            " [0]\n",
            " [1]\n",
            " [1]\n",
            " [0]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[1.1634e+02 1.2091e+02 2.4340e+03 6.0000e+00]\n",
            " [5.2833e+01 2.1497e+01 1.0350e+03 6.0000e+00]\n",
            " [4.6827e+01 1.1206e+02 3.2400e+02 4.0000e+00]\n",
            " [4.0269e+01 1.2455e+02 1.1520e+03 5.0000e+00]\n",
            " [8.2057e+01 3.2017e+00 6.1000e+02 4.0000e+00]\n",
            " [6.0600e+01 5.5485e+00 5.2100e+02 4.0000e+00]\n",
            " [6.9737e+01 2.6840e+00 9.5900e+02 5.0000e+00]\n",
            " [2.0030e+01 1.5922e+01 2.5650e+03 4.0000e+00]\n",
            " [1.9076e+01 1.6257e+01 1.4490e+03 5.0000e+00]\n",
            " [5.1173e+01 2.8950e+00 3.8770e+03 7.0000e+00]\n",
            " [2.8302e+01 1.0600e+02 2.3200e+02 6.0000e+00]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [50000050.]\n",
            "\tPDG [50000050.] wrong >> skip\n",
            "index_particle 743  num_tracks_in_event 1\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False False False False  True False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[ 11.  26.   5.  44.  62.  40. 135. 149. 238.  83.  57. 104.  22.  39.\n",
            "   45.   5.  61.  49.   4.  24.]]\n",
            "values_data_dict q_values  [ 11.  26.   5.  44.  62.  40. 135. 149. 238.  83.  57. 104.  22.  39.\n",
            "  45.   5.  61.  49.   4.  24.]\n",
            "size_padded  [[1. 1. 1. 2. 3. 3. 4. 4. 4. 3. 3. 3. 2. 2. 3. 1. 3. 2. 1. 1.]]\n",
            "values_data_dict mSize_values  [1. 1. 1. 2. 3. 3. 4. 4. 4. 3. 3. 3. 2. 2. 3. 1. 3. 2. 1. 1.]\n",
            "mip_mask_condition true_count_mip 12\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (2, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (2, 550, 5)\n",
            "shape of z-score array: (2, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 5500\n",
            "nonzero p_value: [[1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]]\n",
            "nonzero p_value[z_mask]: 101\n",
            "nonzero p_value[z_mask]: [[25]\n",
            " [25]\n",
            " [25]\n",
            " [25]\n",
            " [ 1]]\n",
            "nonzero p_value[mip_mask]: 101\n",
            "nonzero p_value[mip_mask]: [[25]\n",
            " [25]\n",
            " [25]\n",
            " [25]\n",
            " [ 1]]\n",
            "high_charge_size  [[0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0]\n",
            " [0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 1\n",
            "mips [[7.9429e+01 9.1721e+00 2.3800e+02 4.0000e+00]\n",
            " [1.8018e+01 6.6554e+01 1.1020e+03 6.0000e+00]\n",
            " [6.8677e+01 4.3636e+01 1.1900e+03 5.0000e+00]\n",
            " [1.1760e+01 1.3165e+01 3.0450e+03 9.0000e+00]\n",
            " [9.4053e+01 1.0547e+02 2.7100e+02 3.0000e+00]\n",
            " [8.7308e+01 1.1171e+02 1.0830e+03 4.0000e+00]\n",
            " [5.3139e+01 4.8698e+01 8.2800e+02 5.0000e+00]\n",
            " [5.4247e+01 5.1773e+01 3.6600e+02 3.0000e+00]\n",
            " [5.2778e+01 5.1313e+01 3.1700e+02 4.0000e+00]\n",
            " [1.0588e+02 1.0509e+02 7.2600e+02 4.0000e+00]\n",
            " [1.5045e+01 1.0394e+02 6.7400e+02 5.0000e+00]\n",
            " [9.0197e+01 8.7110e+01 9.8400e+02 5.0000e+00]]\n",
            "L_all_tracks (550, 2) \n",
            "pion_mask2.shape (550, 2, 12)\n",
            "index 0 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 25 num_kaons 25 num_protons 1\n",
            "index 1 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 744  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False False False  True False False False False False False\n",
            "  False False False False False False False False]]\n",
            "q_padded  [[ 98.  34.  31.  61.  69. 200.  19.  48.   6.  69.  77.  81.  14.   4.\n",
            "   59.  87.  40. 122.  28. 101.]]\n",
            "values_data_dict q_values  [ 98.  34.  31.  61.  69. 200.  19.  48.   6.  69.  77.  81.  14.   4.\n",
            "  59.  87.  40. 122.  28. 101.]\n",
            "size_padded  [[2. 1. 2. 3. 2. 4. 1. 3. 1. 3. 2. 2. 2. 1. 4. 4. 2. 4. 2. 2.]]\n",
            "values_data_dict mSize_values  [2. 1. 2. 3. 2. 4. 1. 3. 1. 3. 2. 2. 2. 1. 4. 4. 2. 4. 2. 2.]\n",
            "mip_mask_condition true_count_mip 2\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 41\n",
            "nonzero p_value[z_mask]: [[10]\n",
            " [10]\n",
            " [10]\n",
            " [11]\n",
            " [ 0]]\n",
            "nonzero p_value[mip_mask]: 40\n",
            "nonzero p_value[mip_mask]: [[10]\n",
            " [10]\n",
            " [10]\n",
            " [10]\n",
            " [ 0]]\n",
            "high_charge_size  [[0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]\n",
            "num_tracks_in_event 0\n",
            "mips [[ 41.7553 110.0117 200.       4.    ]\n",
            " [ 46.6937 116.6022 434.       5.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 746  num_tracks_in_event 1\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[ True  True  True False False False False False False False False False\n",
            "  False False False False  True  True False False]]\n",
            "q_padded  [[2126.  237.  218.  136.   23.    9.   27.   21.   30.   95.   43.   30.\n",
            "    14.   10.   62.  183.  884. 3055.   43.   22.]]\n",
            "values_data_dict q_values  [2126.  237.  218.  136.   23.    9.   27.   21.   30.   95.   43.   30.\n",
            "   14.   10.   62.  183.  884. 3055.   43.   22.]\n",
            "size_padded  [[ 9.  4. 14.  4.  1.  1.  2.  1.  2.  3.  2.  2.  2.  2.  2.  4.  6.  4.\n",
            "   2.  1.]]\n",
            "values_data_dict mSize_values  [ 9.  4. 14.  4.  1.  1.  2.  1.  2.  3.  2.  2.  2.  2.  2.  4.  6.  4.\n",
            "  2.  1.]\n",
            "mip_mask_condition true_count_mip 12\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (2, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (2, 550, 5)\n",
            "shape of z-score array: (2, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 5500\n",
            "nonzero p_value: [[1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]\n",
            " [1100]]\n",
            "nonzero p_value[z_mask]: 72\n",
            "nonzero p_value[z_mask]: [[18]\n",
            " [18]\n",
            " [18]\n",
            " [15]\n",
            " [ 3]]\n",
            "nonzero p_value[mip_mask]: 72\n",
            "nonzero p_value[mip_mask]: [[18]\n",
            " [18]\n",
            " [18]\n",
            " [15]\n",
            " [ 3]]\n",
            "high_charge_size  [[1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0]\n",
            " [1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0]]\n",
            "num_tracks_in_event 1\n",
            "mips [[1.2249e+02 1.0580e+01 2.1260e+03 9.0000e+00]\n",
            " [1.2325e+02 1.7856e+01 2.3700e+02 4.0000e+00]\n",
            " [1.0565e+02 1.8072e+01 2.1800e+02 1.4000e+01]\n",
            " [1.2533e+02 7.9009e+01 8.8400e+02 6.0000e+00]\n",
            " [1.2657e+02 8.2935e+01 3.0550e+03 4.0000e+00]\n",
            " [5.1744e+01 8.7806e+01 3.7500e+02 3.0000e+00]\n",
            " [9.9754e+01 5.9013e+01 6.4600e+02 5.0000e+00]\n",
            " [1.0060e+02 1.0092e+02 5.6700e+02 6.0000e+00]\n",
            " [1.1621e+02 1.0450e+02 2.1800e+02 4.0000e+00]\n",
            " [1.3021e+02 1.0486e+02 1.4950e+03 3.0000e+00]\n",
            " [1.2893e+02 1.0639e+02 2.6300e+02 3.0000e+00]\n",
            " [1.1995e+01 1.0069e+02 7.0500e+02 4.0000e+00]]\n",
            "L_all_tracks (550, 2) \n",
            "pion_mask2.shape (550, 2, 12)\n",
            "index 0 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "PDG [211.] passed num_phot_thresh\n",
            "fill_dict_for_index_N reading index 0\n",
            "key PIONS\n",
            "key KAONS\n",
            "key PROTONS\n",
            "abs_pdg [211.] num_pions 18 num_kaons 15 num_protons 3\n",
            "index 1 of 1 : pdg [211.]\n",
            "Passed ckovReconstructed and in PDG\n",
            "PDG [211.] passed treshold momentum\n",
            "index_particle 747  num_tracks_in_event 0\n",
            "\n",
            "\n",
            " ====================== \n",
            "\n",
            "\n",
            "mip_mask_condition  [[False False False  True False False  True False False False False False\n",
            "  False  True False False False False False  True]]\n",
            "q_padded  [[ 75.  69.  15. 632. 143.  48. 564.  48.  26. 107.  11.  13.   8. 282.\n",
            "   41.  11.  35.   6. 348. 899.]]\n",
            "values_data_dict q_values  [ 75.  69.  15. 632. 143.  48. 564.  48.  26. 107.  11.  13.   8. 282.\n",
            "  41.  11.  35.   6. 348. 899.]\n",
            "size_padded  [[2. 4. 2. 6. 4. 2. 4. 4. 2. 3. 1. 2. 2. 4. 1. 1. 1. 1. 2. 5.]]\n",
            "values_data_dict mSize_values  [2. 4. 2. 6. 4. 2. 4. 4. 2. 3. 1. 2. 2. 4. 1. 1. 1. 1. 2. 5.]\n",
            "mip_mask_condition true_count_mip 11\n",
            "shape of theta_c_hyps_expanded: (9, 550, 5)\n",
            "shape of theta_cer_padded_expanded: (1, 550, 5)\n",
            "shape of sigma_ring_padded_expanded: (1, 550, 5)\n",
            "shape of z-score array: (1, 550, 5)\n",
            "SHAPE  Valid counts per photon: (550,)\n",
            "nonzero p_value: 2750\n",
            "nonzero p_value: [[550]\n",
            " [550]\n",
            " [550]\n",
            " [550]\n",
            " [550]]\n",
            "nonzero p_value[z_mask]: 61\n",
            "nonzero p_value[z_mask]: [[13]\n",
            " [13]\n",
            " [13]\n",
            " [12]\n",
            " [10]]\n",
            "nonzero p_value[mip_mask]: 61\n",
            "nonzero p_value[mip_mask]: [[13]\n",
            " [13]\n",
            " [13]\n",
            " [12]\n",
            " [10]]\n",
            "high_charge_size  [[0 0 0 1 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 1]]\n",
            "num_tracks_in_event 0\n",
            "mips [[ 122.5978   98.5883  632.        6.    ]\n",
            " [ 102.8118   78.6248  564.        4.    ]\n",
            " [ 108.6125   76.4338  282.        4.    ]\n",
            " [  93.7013   20.7146  899.        5.    ]\n",
            " [ 103.8155   37.5859  204.        3.    ]\n",
            " [  14.5157   10.1441  213.        4.    ]\n",
            " [  92.2203   21.9976  641.        4.    ]\n",
            " [  77.7325  103.2124 1709.        6.    ]\n",
            " [ 110.952    99.8648  714.        7.    ]\n",
            " [   4.5635   55.7795  361.        3.    ]\n",
            " [ 112.9859   98.6832  288.        4.    ]]\n",
            "L_all_tracks (550, 1) \n",
            "pion_mask2.shape (550, 1, 12)\n",
            "index 0 of 0 : pdg [11.]\n",
            "\tPDG [11.] wrong >> skip\n"
          ]
        }
      ],
      "source": [
        "\n",
        "\n",
        "print(\"classifier = MassClassifier(percentage_to_read = 100, resolution = 4) # pass percentage of dataset to read\")\n",
        "classifier = MassClassifier(percentage_to_read = 100, resolution = 4) # pass percentage of dataset to read\n",
        "\n",
        "file_to_read = \"test/diffLandSegm/ParticleInfoPb20k.h5\" # PbPB 2STD, 20k particles\n",
        "\n",
        "\n",
        "\n",
        "import glob\n",
        "drive_path = '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/'\n",
        "\n",
        "\n",
        "\n",
        "files_to_read = glob.glob(drive_path  +  \"NewSegment/RR/\" + \"*321**1725*h5\") # ok\n",
        "files_to_read = files_to_read + glob.glob(drive_path  +  \"NewSegment/RR/\" + \"*211**1725*h5\") # ok\n",
        "\n",
        "\n",
        "files_to_read = glob.glob(drive_path  +  \"NewSegment/mCkov/\" + \"*1725*h5\") # ok\n",
        "files_to_read = files_to_read + glob.glob(drive_path  +  \"NewSegment/mCkov/pp/AApr/\" + \"*1725*h5\") # ok\n",
        "files_to_read = files_to_read + glob.glob(drive_path  +  \"NewSegment/mCkov/\" + \"*full*h5\") # ok\n",
        "files_to_read = files_to_read + glob.glob(drive_path  +  \"NewSegment/mCkov/pp/\" + \"*1725*h5\") # ok\n",
        "\n",
        "\n",
        "files_to_read = files_to_read + glob.glob(drive_path  +  \"NewSegment/mCkov/pp/kk2/\" + \"*1725*h5\") # ok\n",
        "\n",
        "files_to_read = files_to_read + glob.glob(drive_path  +  \"NewSegment/mCkov/pp/pp3/\" + \"*1725*h5\") # ok\n",
        "\n",
        "\n",
        "\n",
        "files_to_read = files_to_read + glob.glob(drive_path  +  \"NewSegment/mCkov/pp/pion__/\" + \"*1725*h5\") # ok\n",
        "#files_to_read = files_to_read + glob.glob(drive_path  +  \"NewSegment/mCkov/pp/pion/\" + \"*1725*h5\") # problem med denne n√• ?\n",
        "files_to_read = files_to_read + glob.glob(drive_path  +  \"NewSegment/mCkov/pp/kaon/\" + \"*1725*h5\") # ok\n",
        "\n",
        "\n",
        "\n",
        "files_to_read = files_to_read + glob.glob(drive_path  +  \"NewSegment/mCkov/pp/doesWork?Kaon/\" + \"*1725*h5\") # ok\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "# alle over er med boxgun = 30\n",
        "\n",
        "\n",
        "# 50\n",
        "files_to_read = files_to_read + glob.glob(drive_path  +  \"NewSegment/mCkov/pp/pion??/\" + \"*1725*h5\") # ok\n",
        "files_to_read = files_to_read + glob.glob(drive_path  +  \"NewSegment/mCkov/pp/pion??2/\" + \"*1725*h5\") # ok\n",
        "\n",
        "# 90\n",
        "\n",
        "files_to_read = files_to_read + glob.glob(drive_path  +  \"NewSegment/mCkov/pp/kaon?/\" + \"*1725*h5\") # ok\n",
        "\n",
        "files_to_read = files_to_read + glob.glob(drive_path  +  \"NewSegment/mCkov/pp/kaon?2/\" + \"*1725*h5\") # ok\n",
        "\n",
        "\n",
        "\n",
        "files_to_read2 = glob.glob(drive_path  +  \"NewSegment/mCkov/pp/proton?/\" + \"*1725*h5\") # ok?\n",
        "files_to_read2 = files_to_read2 + glob.glob(drive_path  +  \"NewSegment/mCkov/pp/proton?2/\" + \"*1725*h5\") # ok\n",
        "\n",
        "#files_to_read = files_to_read + glob.glob(drive_path  +  \"NewSegment/mCkov/pp/kaon?????/\" + \"*h5\") # denne har ikke sigmaRingValues, phiCerValues...\n",
        "\n",
        "\n",
        "files_to_read2 = files_to_read2 + glob.glob(drive_path  +  \"NewSegment/mCkov/pp/kaon?????/\" + \"*h5\") # denne har ikke sigmaRingValues, phiCerValues...\n",
        "\n",
        "files_to_read3 =  glob.glob(drive_path  +  \"NewSegment/mCkov/pp/proton?????/\" + \"*h5\") # denne har ikke sigmaRingValues, phiCerValues...\n",
        "\n",
        "\n",
        "files_to_read3 = files_to_read3 + glob.glob(drive_path  +  \"NewSegment/mCkov/pp/kaon10/\" + \"*h5\") # denne har ikke sigmaRingValues, phiCerValues...\n",
        "\n",
        "\n",
        "files_to_read3 = files_to_read3 + glob.glob(drive_path  +  \"NewSegment/mCkov/pp/Proton/\" + \"*h5\") # denne har ikke sigmaRingValues, phiCerValues...\n",
        "\n",
        "\n",
        "files_to_read3 = files_to_read3# + glob.glob(drive_path  +  \"NewSegment/mCkov/pp/Proton/\" + \"*h5\") # denne har ikke sigmaRingValues, phiCerValues...\n",
        "\n",
        "# 3\n",
        "files_to_read4 = glob.glob(drive_path  +  \"NewSegment/mCkov/pp/kaon__/\" + \"*h5\") # denne har ikke sigmaRingValues, phiCerValues...\n",
        "files_to_read5 = glob.glob(drive_path  +  \"NewSegment/mCkov/pp/pionN/\" + \"*h5\") # denne har ikke sigmaRingValues, phiCerValues...\n",
        "\n",
        "directory = '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/tt/'\n",
        "\n",
        "# 5:\n",
        "files_to_read6 = glob.glob(directory + \"*h5\") # denne har ikke sigmaRingValues, phiCerValues...\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "directory = '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/pions/'\n",
        "# 5:\n",
        "files_to_read7 = glob.glob(directory + \"*h5\") # denne har ikke sigmaRingValues, phiCerValues...\n",
        "\n",
        "\n",
        "\n",
        "files_to_read1 = glob.glob(drive_path + \"NewSegment/RR/\" + \"*321**1725*h5\")\n",
        "\n",
        "files_to_read2 = glob.glob(drive_path + \"NewSegment/RR/\" + \"*211**1725*h5\")\n",
        "\n",
        "files_to_read3 = glob.glob(drive_path + \"NewSegment/mCkov/\" + \"*1725*h5\")\n",
        "\n",
        "files_to_read4 = glob.glob(drive_path + \"NewSegment/mCkov/pp/AApr/\" + \"*1725*h5\")\n",
        "\n",
        "files_to_read5 = glob.glob(drive_path + \"NewSegment/mCkov/\" + \"*full*h5\")\n",
        "\n",
        "files_to_read6 = glob.glob(drive_path + \"NewSegment/mCkov/pp/\" + \"*1725*h5\")\n",
        "\n",
        "files_to_read7 = glob.glob(drive_path + \"NewSegment/mCkov/pp/kk2/\" + \"*1725*h5\")\n",
        "\n",
        "files_to_read8 = glob.glob(drive_path + \"NewSegment/mCkov/pp/pp3/\" + \"*1725*h5\")\n",
        "\n",
        "files_to_read9 = glob.glob(drive_path + \"NewSegment/mCkov/pp/pion__/\" + \"*1725*h5\")\n",
        "\n",
        "# Skipped problematic line as per your instructions\n",
        "# files_to_read10 = glob.glob(drive_path + \"NewSegment/mCkov/pp/pion/\" + \"*1725*h5\")\n",
        "\n",
        "files_to_read10 = glob.glob(drive_path + \"NewSegment/mCkov/pp/kaon/\" + \"*1725*h5\")\n",
        "\n",
        "files_to_read11 = glob.glob(drive_path + \"NewSegment/mCkov/pp/doesWork?Kaon/\" + \"*1725*h5\")\n",
        "\n",
        "files_to_read12 = glob.glob(drive_path + \"NewSegment/mCkov/pp/pion??/\" + \"*1725*h5\")\n",
        "\n",
        "files_to_read13 = glob.glob(drive_path + \"NewSegment/mCkov/pp/pion??2/\" + \"*1725*h5\")\n",
        "\n",
        "files_to_read14 = glob.glob(drive_path + \"NewSegment/mCkov/pp/kaon?/\" + \"*1725*h5\")\n",
        "\n",
        "files_to_read15 = glob.glob(drive_path + \"NewSegment/mCkov/pp/kaon?2/\" + \"*1725*h5\")\n",
        "\n",
        "files_to_read16 = glob.glob(drive_path + \"NewSegment/mCkov/pp/proton?/\" + \"*1725*h5\")\n",
        "\n",
        "files_to_read17 = glob.glob(drive_path + \"NewSegment/mCkov/pp/proton?2/\" + \"*1725*h5\")\n",
        "\n",
        "files_to_read18 = glob.glob(drive_path + \"NewSegment/mCkov/pp/kaon?????/\" + \"*h5\")\n",
        "\n",
        "files_to_read19 = glob.glob(drive_path + \"NewSegment/mCkov/pp/proton?????/\" + \"*h5\")\n",
        "\n",
        "files_to_read20 = glob.glob(drive_path + \"NewSegment/mCkov/pp/kaon10/\" + \"*h5\")\n",
        "\n",
        "files_to_read21 = glob.glob(drive_path + \"NewSegment/mCkov/pp/Proton/\" + \"*h5\")\n",
        "\n",
        "files_to_read22 = glob.glob(drive_path + \"NewSegment/mCkov/pp/kaon__/\" + \"*h5\")\n",
        "\n",
        "files_to_read23 = glob.glob(drive_path + \"NewSegment/mCkov/pp/pionN/\" + \"*h5\")\n",
        "\n",
        "directory_tt = '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/tt/'\n",
        "files_to_read24 = glob.glob(directory_tt + \"*h5\")\n",
        "\n",
        "directory_pions = '/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/pions2/'\n",
        "files_to_read25 = glob.glob(directory_pions + \"*h5\")\n",
        "\n",
        "all_files_to_read = [files_to_read3, files_to_read4, files_to_read5,\n",
        "                     files_to_read6, files_to_read7, files_to_read8, files_to_read9, files_to_read10,\n",
        "                     files_to_read11, files_to_read12, files_to_read13, files_to_read14, files_to_read15,\n",
        "                     files_to_read16, files_to_read17, files_to_read18, files_to_read19, files_to_read20,\n",
        "                     files_to_read21, files_to_read22, files_to_read23, files_to_read24, files_to_read25]\n",
        "\n",
        "all_files_to_read = [files_to_read3]\n",
        "\n",
        "\n",
        "mask = [1, 1, 1, 1]\n",
        "k_n = 40\n",
        "import pickle\n",
        "\n",
        "# Move saved files to destination directory\n",
        "!mv /content/dataPions{i+1}.npz \"/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/\"\n",
        "#!mv /content/data{i+1}.pkl \"/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/\"\n",
        "\n",
        "\n",
        "# Loop through the list of files_to_read variables\n",
        "for i, files in enumerate(all_files_to_read):\n",
        "    try:\n",
        "      print(\"Attempting to open:\", files)\n",
        "\n",
        "      # Initialize MassClassifier and load data\n",
        "\n",
        "      classifier = MassClassifier(percentage_to_read=100, resolution=4)\n",
        "      classifier.load_data(files)\n",
        "      print(files)\n",
        "      # Preprocess data\n",
        "      datasets, X_train_scaled, X_test_scaled, X_train, X_test, y_train, y_test, regions = classifier.preprocess_data(k_n)\n",
        "\n",
        "      # Save data as pickle\n",
        "      #with open(f'data{i+1}.pkl', 'wb') as f:\n",
        "      #    pickle.dump((datasets, X_train_scaled, X_test_scaled, X_train, X_test, y_train, y_test, regions), f)\n",
        "\n",
        "      # Save data as npz\n",
        "      np.savez(f'data_extended{i+1}.npz', datasets=datasets, X_train_scaled=X_train_scaled, X_test_scaled=X_test_scaled,\n",
        "              X_train=X_train, X_test=X_test, y_train=y_train, y_test=y_test, regions=regions)\n",
        "\n",
        "      # Move saved files to destination directory\n",
        "      !mv /content/data_extended{i+1}.npz \"/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/\"\n",
        "      #!mv /content/data{i+1}.pkl \"/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/\"\n",
        "    except Exception as e : print(e)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "70qh0T4eP4XW"
      },
      "outputs": [],
      "source": [
        "!mv /content/dataPions{1}.npz \"/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/\""
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "03T63KCg4atu"
      },
      "outputs": [],
      "source": [
        "\n",
        "\n",
        "\n",
        "\n",
        "X_mCluCharge = datasets['mCluCharge']\n",
        "X_mCluSize = datasets['mCluSize']\n",
        "X_pion_candidates = datasets['pion_candidates']\n",
        "X_kaon_candidates = datasets['kaon_candidates']\n",
        "X_proton_candidates = datasets['proton_candidates']\n",
        "X_non_candidates = datasets['non_candidates']\n",
        "X_momentum = datasets['momentum']\n",
        "X_refractive_index = datasets['refractive_index']\n",
        "X_phi = datasets['phi']\n",
        "X_theta = datasets['theta']\n",
        "X_mip_position = datasets['mip_position']\n",
        "X_rad_position = datasets['rad_position']\n",
        "X_map_pion = datasets['map_pion']\n",
        "X_map_kaon = datasets['map_kaon']\n",
        "X_map_proton = datasets['map_proton']\n",
        "X_pion_flag = datasets['pion_flag']\n",
        "X_kaon_flag = datasets['kaon_flag']\n",
        "X_proton_flag = datasets['proton_flag']\n",
        "X_index_particle = datasets['index_particle']\n",
        "y = datasets['y_cp']\n",
        "\n",
        "\n",
        "#X_pion_constr_min = regions[\"X_pion_constr_min\"]\n",
        "#X_pion_constr_max = regions[\"X_pion_constr_max\"]\n",
        "#X_kaon_constr_min = regions[\"X_kaon_constr_min\"]\n",
        "#X_kaon_constr_max = regions[\"X_kaon_constr_max\"]\n",
        "#X_proton_constr_min = regions[\"X_proton_constr_min\"]\n",
        "#X_proton_constr_max = regions[\"X_proton_constr_max\"]\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "XZIFisppZxjI"
      },
      "outputs": [],
      "source": [
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "RRJVz_krv97E"
      },
      "outputs": [],
      "source": [
        "\n",
        "with open('data4.pkl', 'wb') as f:\n",
        "    pickle.dump((datasets, X_train_scaled, X_test_scaled, X_train, X_test, y_train, y_test, regions), f)\n",
        "\n",
        "\n",
        "import numpy as np\n",
        "\n",
        "np.savez('data4.npz', datasets=datasets, X_train_scaled=X_train_scaled, X_test_scaled=X_test_scaled,\n",
        "         X_train=X_train, X_test=X_test, y_train=y_train, y_test=y_test, regions=regions)\n",
        "\n",
        "\n",
        "#data = np.load('data3.npz', allow_pickle=True)\n",
        "#datasets = data['datasets']\n",
        "#X_train_scaled = data['X_train_scaled']\n",
        "\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "wdGxPuQ6VRFK"
      },
      "outputs": [],
      "source": [
        "\n",
        "\n",
        "#!mv /content/data3.npz \"/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/\"\n",
        "#!mv /content/data3.pkl \"/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/\"\n",
        "\n",
        "#!mv /content/data.pkl \"/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/\"\n",
        "\n",
        "#!mv /content/data.npz \"/content/drive/MyDrive/Colab Notebooks/CERN_ML/CNN_PID/\"\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "iixtSp0OSqxl"
      },
      "outputs": [],
      "source": [
        "from google.colab import files\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "4z0VcnUJUgI7"
      },
      "outputs": [],
      "source": [
        "from google.colab import drive\n",
        "drive.mount('/content/drive')"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "4bFx13EZ40ha"
      },
      "outputs": [],
      "source": [
        "\n",
        "\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "VRrcGqJzL0yO"
      },
      "source": [
        "# Plotting histograms of Training Versus Test Sets"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "aGcPI9SNAYC4"
      },
      "outputs": [],
      "source": [
        "!wget https://raw.githubusercontent.com/eflatlan/CNN_PID/models_sacved/misc_helper_functions.py\n",
        "from misc_helper_functions import *"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "AXfgrBxNi0Gb"
      },
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "TS8iVdaej4S-"
      },
      "outputs": [],
      "source": [
        "# print(\"===== Evaluating Training Data =====\")\n",
        "# for feature, data in X_train.items():\n",
        "#     print(f\"Evaluating feature: {feature}\")\n",
        "#     eval_data(np.array(data))  # Assuming your function is designed to work with numpy arrays\n",
        "#     print(\"---------------------------\")\n",
        "\n",
        "# # Loop through test_data dictionary\n",
        "# print(\"===== Evaluating Test Data =====\")\n",
        "# for feature, data in X_test.items():\n",
        "#     print(f\"Evaluating feature: {feature}\")\n",
        "#     eval_data(np.array(data))  # Assuming your function is designed to work with numpy arrays\n",
        "#     print(\"---------------------------\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "yodihp5E2k9X"
      },
      "outputs": [],
      "source": [
        "# plot_hist(X_train=X_train, X_test=X_test, description = \"Unscaled\")\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "-Hue3RFcmfSu"
      },
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "qw-tBHZEp_ph"
      },
      "source": [
        "# Plot samples"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "e5rA7r6VJzF9"
      },
      "outputs": [],
      "source": [
        "\n",
        "X_train_pion_candidates = X_train[\"X_train_pion_candidates\"]\n",
        "X_train_kaon_candidates = X_train[\"X_train_kaon_candidates\"]\n",
        "X_train_proton_candidates = X_train[\"X_train_proton_candidates\"]\n",
        "X_train_non_candidates = X_train[\"X_train_non_candidates\"]\n",
        "X_train_non_candidates = X_train[\"X_train_non_candidates\"]\n",
        "\n",
        "X_train_momentum = X_train[\"X_train_momentum\"]\n",
        "X_train_refractive_index = X_train[\"X_train_refractive_index\"]\n",
        "X_train_phi = X_train[\"X_train_phi\"]\n",
        "X_train_theta = X_train[\"X_train_theta\"]\n",
        "\n",
        "X_train_mip_position = X_train[\"X_train_mip_position\"]\n",
        "X_train_rad_position = X_train[\"X_train_rad_position\"]\n",
        "\n",
        "\n",
        "X_test_non_candidates = X_test[\"X_test_non_candidates\"]\n",
        "\n",
        "X_test_pion_candidates = X_test[\"X_test_pion_candidates\"]\n",
        "X_test_kaon_candidates = X_test[\"X_test_kaon_candidates\"]\n",
        "X_test_proton_candidates = X_test[\"X_test_proton_candidates\"]\n",
        "X_test_momentum = X_test[\"X_test_momentum\"]\n",
        "X_test_refractive_index = X_test[\"X_test_refractive_index\"]\n",
        "X_test_phi = X_test[\"X_test_phi\"]\n",
        "X_test_theta = X_test[\"X_test_theta\"]\n",
        "X_test_mip_position = X_test[\"X_test_mip_position\"]\n",
        "X_test_rad_position = X_test[\"X_test_rad_position\"]\n",
        "\n",
        "below_zero_indexes = np.where(X_train_phi < 0)[0]\n",
        "n = 10\n",
        "first_n_below_zero_indexes = below_zero_indexes[:n]\n",
        "\n",
        "print(first_n_below_zero_indexes)\n",
        "#ef : TODO fix this again\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "LEcxmpVi2mxO"
      },
      "source": [
        "# PDG of train vs test"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "2DlGQeDT2l1S"
      },
      "outputs": [],
      "source": [
        "import matplotlib.pyplot as plt\n",
        "import numpy as np\n",
        "\n",
        "\n",
        "# for i in range(1,5):\n",
        "#   print(y_test[i])\n",
        "\n",
        "\n",
        "\n",
        "# # Counting occurrences in the training set\n",
        "\n",
        "\n",
        "\n",
        "print(f\"shape : y_test {y_test.shape}\")\n",
        "print(f\"shape : y_train {y_train.shape}\")\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "train_pion_count = np.sum(y_train[:, 0])\n",
        "test_pion_count = np.sum(y_test[:, 0])\n",
        "print(f\"Train counts - Pion: {train_pion_count},  | Test counts - Pion: {test_pion_count}\")\n",
        "\n",
        "\n",
        "train_kaon_count = np.sum(y_train[:, 1])\n",
        "train_proton_count = np.sum(y_train[:, 2])\n",
        "\n",
        "# # Counting occurrences in the test set\n",
        "test_kaon_count = np.sum(y_test[:, 0])\n",
        "test_proton_count = np.sum(y_test[:, 2])\n",
        "\n",
        "# print(f'Train : pion_count {train_pion_count}  kaon_count {train_kaon_count} proton_count {train_proton_count}')\n",
        "# print(f'Test : pion_count {test_pion_count}  kaon_count {test_kaon_count} proton_count {test_proton_count}')\n",
        "\n",
        "# # Create subplots\n",
        "fig, axs = plt.subplots(1, 2, figsize=(12, 6))\n",
        "\n",
        "# # Training set histogram\n",
        "axs[0].bar(['Pion', 'Kaon', 'Proton'], [train_pion_count, train_kaon_count, train_proton_count])\n",
        "axs[0].set_title('Training Set')\n",
        "axs[0].set_xlabel('Particle Type')\n",
        "axs[0].set_ylabel('Frequency')\n",
        "\n",
        "# # Test set histogram\n",
        "axs[1].bar(['Pion', 'Kaon', 'Proton'], [test_pion_count, test_kaon_count, test_proton_count])\n",
        "axs[1].set_title('Test Set')\n",
        "axs[1].set_xlabel('Particle Type')\n",
        "axs[1].set_ylabel('Frequency')\n",
        "\n",
        "plt.show()\n",
        "\n",
        "\n",
        "print(f\"Train counts - Pion: {train_pion_count}, Kaon: {train_kaon_count}, Proton: {train_proton_count} | Test counts - Pion: {test_pion_count}, Kaon: {test_kaon_count}, Proton: {test_proton_count}\")\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "qqd9OiuKd8AF"
      },
      "outputs": [],
      "source": [
        "#plot_first_instance(1, X_train_pion_candidates, X_train_kaon_candidates, X_train_proton_candidates,\\\n",
        "#                    X_train_non_candidates,X_train_mCluSize, X_train_mip_position, X_train_rad_position, X_train_phi, X_train_theta, y_train)\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "awUAR6mnhmSM"
      },
      "outputs": [],
      "source": [
        "#plot_combined_types(1, X_train_pion_candidates, X_train_kaon_candidates, X_train_proton_candidates, X_train_non_candidates)\n",
        "# plot_individual_types(5, X_train_pion_candidates, X_train_kaon_candidates, X_train_proton_candidates, X_train_non_candidates)\n",
        "\n",
        "X_train_index_particle = X_train[\"X_train_index_particle\"]\n",
        "X_test_index_particle = X_test[\"X_test_index_particle\"]\n",
        "\n",
        "index = 2\n",
        "X_train_mCluCharge = X_train[\"X_train_mCluCharge\"]\n",
        "X_train_mCluSize = X_train[\"X_train_mCluSize\"]\n",
        "X_test_mCluCharge = X_test[\"X_test_mCluCharge\"]\n",
        "X_test_mCluSize = X_test[\"X_test_mCluSize\"]\n",
        "\n",
        "#print(f\"X_test_mCluCharge shape {X_test_mCluCharge[1]}\")\n",
        "\n",
        "#print(f\"X_test_rad_position  {X_test_rad_position[0,:,:]}\")\n",
        "\n",
        "#print(f\"X_test_mip_position  {X_test_mip_position[0,:,:]}\")\n",
        "\n",
        "#def plot_individual_types(idx, x_pion, x_kaon, x_proton, x_non, MIP_charge, MIP_position, RAD_position, y_train, log_scale):\n",
        "\n",
        "\n",
        "#print(X_test_refractive_index[:10])\n",
        "\n",
        "# X_train_pion_candidates = X_train[\"X_train_pion_candidates\"]\n",
        "# X_train_kaon_candidates = X_train[\"X_train_kaon_candidates\"]\n",
        "# X_train_proton_candidates = X_train[\"X_train_proton_candidates\"]\n",
        "# X_train_momentum = X_train[\"X_train_momentum\"]\n",
        "# X_train_refractive_index = X_train[\"X_train_refractive_index\"]\n",
        "# X_train_phi = X_train[\"X_train_phi\"]\n",
        "# X_train_theta = X_train[\"X_train_theta\"]\n",
        "# X_train_mip_position = X_train[\"X_train_mip_position\"]\n",
        "# X_train_rad_position = X_train[\"X_train_rad_position\"]\n",
        "\n",
        "# X_test_pion_candidates = X_test[\"X_test_pion_candidates\"]\n",
        "# X_test_kaon_candidates = X_test[\"X_test_kaon_candidates\"]\n",
        "# X_test_proton_candidates = X_test[\"X_test_proton_candidates\"]\n",
        "# X_test_momentum = X_test[\"X_test_momentum\"]\n",
        "# X_test_refractive_index = X_test[\"X_test_refractive_index\"]\n",
        "# X_test_phi = X_test[\"X_test_phi\"]\n",
        "# X_test_theta = X_test[\"X_test_theta\"]\n",
        "# X_test_mip_position = X_test[\"X_test_mip_position\"]\n",
        "# X_test_rad_position = X_test[\"X_test_rad_position\"]\n",
        "\n",
        "def process_and_plot(datasets, index, regions):\n",
        "    x_pion = datasets['pion_candidates']\n",
        "    x_kaon = datasets['kaon_candidates']\n",
        "    x_proton = datasets['proton_candidates']\n",
        "    x_non = datasets['non_candidates']\n",
        "    MIP_charge = datasets['mCluCharge']\n",
        "    MIP_position = datasets['mip_position']\n",
        "    RAD_position = datasets['rad_position']\n",
        "    phi = datasets['phi']\n",
        "    y_train = datasets['y_cp']\n",
        "    X_index = datasets['index_particle']\n",
        "    thetaP = datasets['theta']\n",
        "\n",
        "    plot_individual_types(idx=index, x_pion=x_pion, x_kaon=x_kaon, x_proton=x_proton, x_non=x_non,\n",
        "                          MIP_charge=MIP_charge, MIP_position=MIP_position, RAD_position=RAD_position,\n",
        "                          phi=phi, theta = thetaP, y_train=y_train, log_scale=True, X_index=X_index, regions=regions)\n",
        "\n",
        "    plot_combined_types(index, x_pion, x_kaon, x_proton, x_non, MIP_position, RAD_position, phi, thetaP, y_train=y_train, X_index=X_index, regions=regions)\n",
        "\n",
        "\n",
        "# Usage\n",
        "for index in range(10):\n",
        "    process_and_plot(datasets=datasets, index=index, regions=regions)\n",
        "\n",
        "#plot_combined_types3(index, X_test_pion_candidates, X_test_kaon_candidates, X_test_proton_candidates, X_test_non_candidates,X_test_mip_position, X_test_rad_position, X_test_phi, X_test_theta, y_test)\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "y0L-vSrSIZoZ"
      },
      "outputs": [],
      "source": [
        "\n",
        "def count_non_zero_charges(datasets, idx, titles):\n",
        "    non_zero_counts = {}\n",
        "    for data, title in zip(datasets, titles):\n",
        "        non_zero_charges = np.count_nonzero(data[idx, :, 3])\n",
        "        non_zero_counts[title] = non_zero_charges\n",
        "    return non_zero_counts\n",
        "def count_non_zero_charges_vectorized(datasets):\n",
        "    return [np.count_nonzero(data[:, :, 3], axis=1) for data in datasets]\n",
        "\n",
        "datasets = [X_pion_candidates, X_kaon_candidates, X_proton_candidates]\n",
        "non_zero_counts = count_non_zero_charges_vectorized(datasets)\n",
        "\n",
        "fig, ax = plt.subplots(2, 2, figsize=(15, 10), tight_layout=True)\n",
        "\n",
        "# Determine global bin range for consistency\n",
        "max_count = max(np.max(counts) for counts in non_zero_counts)\n",
        "bins = np.linspace(0, max_count, 50)  # or adjust the number of bins as desired\n",
        "\n",
        "titles = [\"Pion\", \"Kaon\", \"Proton\", \"Non\"]\n",
        "colors = ['r', 'g', 'b', 'y']\n",
        "\n",
        "for i, (counts, title, color) in enumerate(zip(non_zero_counts, titles, colors)):\n",
        "    row, col = divmod(i, 2)\n",
        "    ax[row, col].hist(counts, bins=bins, color=color, alpha=0.7, label=title)\n",
        "    ax[row, col].set_title(title)\n",
        "    ax[row, col].set_xlabel('Number of Non-Zero Charges')\n",
        "    ax[row, col].set_ylabel('Frequency')\n",
        "\n",
        "plt.show()\n",
        "def get_max_non_zero_counts(datasets, titles):\n",
        "    max_counts = {}\n",
        "    for data, title in zip(datasets, titles):\n",
        "        # Count the non-zero charges for each sequence in the dataset\n",
        "        non_zero_counts_per_sequence = np.count_nonzero(data[:, :, 3], axis=1)\n",
        "        # Get the maximum count for the dataset\n",
        "        max_counts[title] = np.max(non_zero_counts_per_sequence)\n",
        "    return max_counts\n",
        "\n",
        "titles = [\"Pion\", \"Kaon\", \"Proton\"]\n",
        "max_non_zero_counts = get_max_non_zero_counts(datasets, titles)\n",
        "\n",
        "print(max_non_zero_counts)\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "SpNLoItBFzjX"
      },
      "outputs": [],
      "source": [
        "\n",
        "def count_non_zero_charges(datasets, idx, titles):\n",
        "    non_zero_counts = {}\n",
        "    for data, title in zip(datasets, titles):\n",
        "        non_zero_charges = np.count_nonzero(data[idx, :, 3])\n",
        "        non_zero_counts[title] = non_zero_charges\n",
        "    return non_zero_counts\n",
        "\n",
        "datasets = [x_pion, x_kaon, x_proton, x_non]\n",
        "titles = [\"Pion\", \"Kaon\", \"Proton\", \"Non\"]\n",
        "non_zero_counts = count_non_zero_charges(datasets, idx, titles)\n",
        "\n",
        "def get_lengths_and_global_max(sequences):\n",
        "  def last_non_zero_index(seq):\n",
        "      non_zero_indices = np.where(np.any(seq != 0, axis=1))[0]\n",
        "      return non_zero_indices[-1] + 1 if len(non_zero_indices) > 0 else 0\n",
        "\n",
        "  lengths = [last_non_zero_index(seq) for seq in sequences]\n",
        "  return lengths, max(lengths)\n",
        "\n",
        "# Extract lengths and max lengths\n",
        "pion_lengths, pion_global_max_length = get_lengths_and_global_max(X_pion_candidates)\n",
        "kaon_lengths, kaon_global_max_length = get_lengths_and_global_max(X_kaon_candidates)\n",
        "proton_lengths, proton_global_max_length = get_lengths_and_global_max(X_proton_candidates)\n",
        "\n",
        "\n",
        "\n",
        "# Plotting\n",
        "fig, ax = plt.subplots(2, 2, figsize=(15, 10), tight_layout=True)\n",
        "bins = range(100, max(pion_global_max_length, kaon_global_max_length, proton_global_max_length) + 5, 5)\n",
        "\n",
        "ax[0, 0].hist(pion_lengths, bins=bins, color='r', alpha=0.7, label='Pion')\n",
        "ax[0, 0].set_title('Pion')\n",
        "ax[0, 0].set_xlabel('Length')\n",
        "ax[0, 0].set_ylabel('Frequency')\n",
        "\n",
        "ax[0, 1].hist(kaon_lengths, bins=bins, color='g', alpha=0.7, label='Kaon')\n",
        "ax[0, 1].set_title('Kaon')\n",
        "ax[0, 1].set_xlabel('Length')\n",
        "ax[0, 1].set_ylabel('Frequency')\n",
        "\n",
        "ax[1, 0].hist(proton_lengths, bins=bins, color='b', alpha=0.7, label='Proton')\n",
        "ax[1, 0].set_title('Proton')\n",
        "ax[1, 0].set_xlabel('Length')\n",
        "ax[1, 0].set_ylabel('Frequency')"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "82LnNwwvL7Ys"
      },
      "source": [
        "# Training the model\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "ti16RD0oVawr"
      },
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "ZARs3NKt4ToR"
      },
      "outputs": [],
      "source": [
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "!wget -O ParticleDataUtilsCp.py https://raw.githubusercontent.com/eflatlan/CNN_PID/models_sacved/ParticleDataUtils21.py\n",
        "from ParticleDataUtilsCp import ParticleDataUtils, classify_candidates_with_pad_sequences\n",
        "\n",
        "!wget -O misc_helper_functions.py https://raw.githubusercontent.com/eflatlan/CNN_PID/models_sacved/misc_helper_functions5.py\n",
        "from misc_helper_functions import build_species_layers, calculate_theta, filter_data, create_lr_scheduler,plot_lr, extract_neighborhood_map, create_cnn_model # plot_worst\n",
        "\n",
        "!wget -O helper_functions.py https://raw.githubusercontent.com/eflatlan/CNN_PID/models_sacved/helper_functions.py\n",
        "!wget -O plot_helper_functions.py https://raw.githubusercontent.com/eflatlan/CNN_PID/models_sacved/plot_helper_functions22.py\n",
        "\n",
        "\n",
        "\n",
        "from plot_helper_functions import plot_hist, plot_training_history, plot_confusion_matrix\n",
        "\n",
        "\n",
        "print(classify_candidates_with_pad_sequences)\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "q1vhz4I-Sgmu"
      },
      "outputs": [],
      "source": [
        "# plot_helper_functions.plot_hist(X_train=X_train, X_test=X_test, description = \"Unscaled\")\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "X4MLTLJX2mA1"
      },
      "outputs": [],
      "source": [
        "mask = [1,1,1,1]\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "fc1_unit = 64\n",
        "units = [fc1_unit * i for i in [8,4, 2, 2, 1,1,1]]\n",
        "units2 = [fc1_unit * i for i in [8,4, 2, 2, 1,1,1,]]\n",
        "# units = [fc1_unit * i for i in [2,  1]]\n",
        "# units2 = [fc1_unit * i for i in [2, 1]]\n",
        "\n",
        "final_concat_units = [128, 32, 16 * i for i in [1]]\n",
        "\n",
        "# units = [fc1_unit * i for i in [16, 8, 4, 2, 2, 1]]\n",
        "# units2 = [fc1_unit * i for i in [16, 8, 4, 2, 2, 1]]\n",
        "\n",
        "CNN_units =  [8, 4, 2, 2, 1]\n",
        "n_epochs = 200\n",
        "\n",
        "\n",
        "#datasets , X_train_scaled, X_test_scaled, X_train, X_test, y_train, y_test, regions = classifier.preprocess_data(k_n)\n",
        "\n",
        "\n",
        "model, history, variables = classifier.train(X_train = X_train_scaled, X_test = X_test_scaled, y_train = y_train, y_test = y_test, mask = mask, num_epochs=n_epochs, include_cnn = True, units = units, units2 = units2, final_concat_units = final_concat_units, CNN_units = CNN_units)\n",
        "\n",
        "#model, history, variables = classifier.train(X_train = X_train, X_test = X_test, y_train = y_train, y_test = y_test, mask = mask, num_epochs=n_epochs, include_cnn = True, units = units, units2 = units2, final_concat_units = final_concat_units, CNN_units = CNN_units)\n",
        "\n",
        "model.summary()\n",
        "\n",
        "#\n",
        "\n",
        "# weight_list = [layer.get_weights()[0] for layer in model.layers if len(layer.get_weights()) > 0]\n",
        "# import matplotlib.pyplot as plt\n",
        "\n",
        "# for i, w in enumerate(weight_list):\n",
        "#     plt.hist(w.flatten(), bins=50)\n",
        "#     plt.title(f\"Layer {i} Weight Distribution\")\n",
        "#     plt.show()\n",
        "\n",
        "# import seaborn as sns\n",
        "\n",
        "# for i, w in enumerate(weights):\n",
        "#     if len(w.shape) == 2:  # Ensure it's a 2D matrix\n",
        "#         plt.figure(figsize=(10, 10))\n",
        "#         sns.heatmap(w, cmap='viridis')\n",
        "#         plt.title(f\"Layer {i} Weight Heatmap\")\n",
        "#         plt.show()\n",
        "\n",
        "\n",
        "# import matplotlib.pyplot as plt\n",
        "# import numpy as np\n",
        "\n",
        "# for index, weights in enumerate(weight_list):\n",
        "#     plt.figure(figsize=(10, 5))\n",
        "\n",
        "#     # You can take the absolute value if you're interested in magnitude\n",
        "#     # Otherwise, just remove np.abs\n",
        "#     plt.imshow(np.abs(weights), cmap='hot', interpolation='nearest')\n",
        "\n",
        "#     plt.colorbar()\n",
        "#     plt.title(f'Layer {index} Weights Intensity')\n",
        "#     plt.show()\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "nvoFVjKWNJ_T"
      },
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "uGrsefEDQfFy"
      },
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "Gyoj0ofB6UFi"
      },
      "outputs": [],
      "source": [
        "\n",
        "%reload_ext tensorboard\n",
        "\n",
        "%tensorboard --logdir logs/fit"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "wYQgGnIEddR2"
      },
      "outputs": [],
      "source": [
        "X_train_pion_candidates = X_train[\"X_train_pion_candidates\"]\n",
        "X_train_kaon_candidates = X_train[\"X_train_kaon_candidates\"]\n",
        "X_train_proton_candidates = X_train[\"X_train_proton_candidates\"]\n",
        "\n",
        "\n",
        "X_train_non_candidates = X_train[\"X_train_non_candidates\"]\n",
        "X_train_momentum = X_train[\"X_train_momentum\"]\n",
        "X_train_refractive_index = X_train[\"X_train_refractive_index\"]\n",
        "X_train_phi = X_train[\"X_train_phi\"]\n",
        "X_train_theta = X_train[\"X_train_theta\"]\n",
        "X_train_mip_position = X_train[\"X_train_mip_position\"]\n",
        "X_train_rad_position = X_train[\"X_train_rad_position\"]\n",
        "X_train_map_pion = X_train[\"X_train_map_pion\"]\n",
        "X_train_map_kaon = X_train[\"X_train_map_kaon\"]\n",
        "X_train_map_proton = X_train[\"X_train_map_proton\"]\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "X_test_pion_candidates = X_test[\"X_test_pion_candidates\"]\n",
        "X_test_kaon_candidates = X_test[\"X_test_kaon_candidates\"]\n",
        "X_test_proton_candidates = X_test[\"X_test_proton_candidates\"]\n",
        "X_test_non_candidates = X_test[\"X_test_non_candidates\"]\n",
        "X_test_momentum = X_test[\"X_test_momentum\"]\n",
        "X_test_refractive_index = X_test[\"X_test_refractive_index\"]\n",
        "X_test_phi = X_test[\"X_test_phi\"]\n",
        "X_test_theta = X_test[\"X_test_theta\"]\n",
        "X_test_mip_position = X_test[\"X_test_mip_position\"]\n",
        "X_test_rad_position = X_test[\"X_test_rad_position\"]\n",
        "X_test_map_pion = X_test[\"X_test_map_pion\"]\n",
        "X_test_map_kaon = X_test[\"X_test_map_kaon\"]\n",
        "X_test_map_proton = X_test[\"X_test_map_proton\"]\n",
        "\n",
        "X_train_mCluCharge = X_train[\"X_train_mCluCharge\"]\n",
        "X_train_mCluSize = X_train[\"X_train_mCluSize\"]\n",
        "X_test_mCluCharge = X_test[\"X_test_mCluCharge\"]\n",
        "X_test_mCluSize = X_test[\"X_test_mCluSize\"]\n",
        "\n",
        "\n",
        "train_variables = variables[0]\n",
        "y_train = variables[1]\n",
        "test_variables = variables[2]\n",
        "y_test = variables[3]\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "aQ06PNqd9K2i"
      },
      "outputs": [],
      "source": [
        "from __future__ import print_function\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import warnings\n",
        "from sklearn.preprocessing import label_binarize\n",
        "from sklearn.metrics import precision_recall_curve, confusion_matrix, f1_score\n",
        "\n",
        "def plot_confusion_matrix(ax, cm, title=\"Confusion Matrix\"):\n",
        "    \"\"\"Utility function to plot the confusion matrix.\"\"\"\n",
        "    ax.imshow(cm, cmap='Blues', interpolation='nearest')\n",
        "    ax.set_xticks(np.arange(3))\n",
        "    ax.set_yticks(np.arange(3))\n",
        "    ax.set_xticklabels(['Pion', 'Kaon', 'Proton'])\n",
        "    ax.set_yticklabels(['Pion', 'Kaon', 'Proton'])\n",
        "    ax.set_title(title)\n",
        "    for x in range(3):\n",
        "        for y in range(3):\n",
        "            percent = cm[x, y] / np.sum(cm[x, :]) * 100\n",
        "            ax.text(y, x, f\"{cm[x, y]} ({percent:.1f}%)\", ha='center', va='center', color='red')\n",
        "\n",
        "def plot_training_history(history, y_pred_train, y_pred_test, y_train_true, y_test_true):\n",
        "    fig2, axs2 = plt.subplots(1, 2, figsize=(25, 6))\n",
        "    cm_train = confusion_matrix(y_train_true.argmax(axis=1), y_pred_train.argmax(axis=1))\n",
        "    cm_test = confusion_matrix(y_test_true.argmax(axis=1), y_pred_test.argmax(axis=1))\n",
        "    plot_confusion_matrix(axs2[0], cm_train, title=\"Train Confusion Matrix\")\n",
        "    plot_confusion_matrix(axs2[1], cm_test, title=\"Validation Confusion Matrix\")\n",
        "    plt.tight_layout()\n",
        "    plt.show()\n",
        "\n",
        "    fig, axs = plt.subplots(1, 2, figsize=(16, 18))\n",
        "    axs[0].plot(history.history[\"loss\"], label=\"Train Loss\")\n",
        "    axs[0].plot(history.history[\"val_loss\"], label=\"Validation Loss\")\n",
        "    axs[0].set_xlabel(\"Epochs\")\n",
        "    axs[0].set_ylabel(\"Loss\")\n",
        "    axs[0].legend()\n",
        "\n",
        "    axs[1].plot(history.history[\"accuracy\"], label=\"Train Accuracy\")\n",
        "    axs[1].plot(history.history[\"val_accuracy\"], label=\"Validation Accuracy\")\n",
        "    axs[1].set_xlabel(\"Epochs\")\n",
        "    axs[1].set_ylabel(\"Accuracy\")\n",
        "    axs[1].legend()\n",
        "\n",
        "    class_labels = ['Pion', 'Kaon', 'Proton']\n",
        "    fig, axs = plt.subplots(1, 3, figsize=(36, 12))\n",
        "\n",
        "    # Train P-R Curve and F1 Score\n",
        "    y_train_bin = label_binarize(y_train_true, classes=[0, 1, 2])\n",
        "    for i in range(3):\n",
        "        precision_train, recall_train, _ = precision_recall_curve(y_train_bin[:, i], y_pred_train[:, i])\n",
        "        axs[0].plot(recall_train, precision_train, lw=2, label=f\"Train {class_labels[i]}\", linestyle='--', color=f'C{i}')\n",
        "        f1_train = 2 * (precision_train * recall_train) / (precision_train + recall_train)\n",
        "        axs[2].plot(recall_train, f1_train, lw=2, label=f\"Train {class_labels[i]}\", linestyle='--', color=f'C{i}')\n",
        "\n",
        "    # Validation P-R Curve and F1 Score\n",
        "    y_test_bin = label_binarize(y_test_true, classes=[0, 1, 2])\n",
        "    for i in range(3):\n",
        "        precision_test, recall_test, _ = precision_recall_curve(y_test_bin[:, i], y_pred_test[:, i])\n",
        "        axs[1].plot(recall_test, precision_test, lw=2, label=f\"Validation {class_labels[i]}\", color=f'C{i}')\n",
        "        f1_test = 2 * (precision_test * recall_test) / (precision_test + recall_test)\n",
        "        axs[2].plot(recall_test, f1_test, lw=2, label=f\"Validation {class_labels[i]}\", color=f'C{i}')\n",
        "\n",
        "    axs[0].set_title(\"P-R Curve for Training Data\")\n",
        "    axs[1].set_title(\"P-R Curve for Validation Data\")\n",
        "    axs[2].set_title(\"F1 Score Curve\")\n",
        "    axs[0].legend()\n",
        "    axs[1].legend()\n",
        "    axs[2].legend()\n",
        "\n",
        "    plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "IHE-pjOx9uhe"
      },
      "outputs": [],
      "source": [
        "import warnings\n",
        "\n",
        "#train_variables = [X_train_pion_candidates, X_train_kaon_candidates, X_train_proton_candidates, X_train_non_candidates, X_train_momentum, X_train_refractive_index, X_train_phi, X_train_theta, X_train_mip_position, X_train_rad_position, X_train_mCluCharge, X_train_mCluSize]\n",
        "#test_variables = [X_test_pion_candidates, X_test_kaon_candidates, X_test_proton_candidates, X_test_non_candidates, X_test_momentum, X_test_refractive_index, X_test_phi, X_test_theta, X_test_mip_position, X_test_rad_position, X_test_mCluCharge, X_test_mCluSize]\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "y_pred_train = model.predict(train_variables)\n",
        "y_pred_test = model.predict(test_variables)\n",
        "# First function call with 'self'\n",
        "try:\n",
        "    plot_training_history(history=history, y_pred_train=y_pred_train, y_pred_test=y_pred_test, y_train_true=y_train, y_test_true=y_test)\n",
        "except Exception as e:\n",
        "    warnings.warn(f\"Exception caught during first function call: {e}\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "yVgyzRzN1exI"
      },
      "outputs": [],
      "source": [
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "from matplotlib.colors import LogNorm\n",
        "\n",
        "def plot_histograms(X_train_pion_candidates, X_train_kaon_candidates, X_train_proton_candidates, y_train):\n",
        "    labels = ['piontrack', 'kaontrack', 'protontrack']\n",
        "    segments = ['pionsegm', 'kaonsegm', 'protonsegm']\n",
        "\n",
        "    # Extract and store data\n",
        "    data_matrix = {}\n",
        "    for track in labels:\n",
        "        data_matrix[track] = {}\n",
        "        for segm in segments:\n",
        "            data_matrix[track][segm] = {'charge': [], 'size': []}\n",
        "\n",
        "    for idx, track in enumerate(labels):\n",
        "        mask = np.all(y_train == np.eye(3)[idx], axis=1)\n",
        "\n",
        "        data_matrix[track]['pionsegm']['charge'].extend(X_train_pion_candidates[mask, :, 3].ravel())\n",
        "        data_matrix[track]['pionsegm']['size'].extend(X_train_pion_candidates[mask, :, 2].ravel())\n",
        "        data_matrix[track]['kaonsegm']['charge'].extend(X_train_kaon_candidates[mask, :, 3].ravel())\n",
        "        data_matrix[track]['kaonsegm']['size'].extend(X_train_kaon_candidates[mask, :, 2].ravel())\n",
        "        data_matrix[track]['protonsegm']['charge'].extend(X_train_proton_candidates[mask, :, 3].ravel())\n",
        "        data_matrix[track]['protonsegm']['size'].extend(X_train_proton_candidates[mask, :, 2].ravel())\n",
        "\n",
        "    # Helper function to plot\n",
        "    def generate_plot(filtered_charge=0, filtered_size=0, plot_type=\"all\"):\n",
        "        fig_hist, ax_hist = plt.subplots(3, 3, figsize=(15, 15))\n",
        "\n",
        "        for i, track_type in enumerate(labels):\n",
        "            for j, segm_type in enumerate(segments):\n",
        "                charges = [c for c in data_matrix[track_type][segm_type]['charge'] if c > filtered_charge]\n",
        "                sizes = [s for s in data_matrix[track_type][segm_type]['size'] if s > filtered_size]\n",
        "\n",
        "                if plot_type == \"charge\":\n",
        "                    ax_hist[i, j].set_yscale('log')\n",
        "                    ax_hist[i, j].hist(charges, bins=125, range=(0, 250), edgecolor='black', alpha=0.6)\n",
        "                    ax_hist[i, j].set_title(f\"{track_type}, {segm_type} - Charge\")\n",
        "\n",
        "                elif plot_type == \"size\":\n",
        "                    ax_hist[i, j].hist(sizes, bins=6, range=(0, 6), edgecolor='black', alpha=0.6)\n",
        "                    ax_hist[i, j].set_yscale('log')\n",
        "                    ax_hist[i, j].set_title(f\"{track_type}, {segm_type} - Size\")\n",
        "\n",
        "                elif plot_type == \"2d\":\n",
        "                    valid_charges = [c for idx, c in enumerate(data_matrix[track_type][segm_type]['charge']) if c > filtered_charge and data_matrix[track_type][segm_type]['size'][idx] > filtered_size]\n",
        "                    valid_sizes = [s for idx, s in enumerate(data_matrix[track_type][segm_type]['size']) if data_matrix[track_type][segm_type]['charge'][idx] > filtered_charge and s > filtered_size]\n",
        "\n",
        "                    hist = ax_hist[i, j].hist2d(valid_charges, valid_sizes, bins=(25, 6), range=[[0, 250], [0, 6]], cmin=1, norm=LogNorm())\n",
        "                    plt.colorbar(hist[3], ax=ax_hist[i, j])\n",
        "                    ax_hist[i, j].set_title(f\"{track_type}, {segm_type} - 2D Charge vs Size\")\n",
        "\n",
        "        plt.tight_layout()\n",
        "        plt.show()\n",
        "\n",
        "    # Generate the plots\n",
        "    generate_plot(plot_type=\"size\")\n",
        "    generate_plot(plot_type=\"charge\")\n",
        "    generate_plot(plot_type=\"2d\")\n",
        "    generate_plot(filtered_size=1, plot_type=\"size\")\n",
        "    generate_plot(filtered_charge=10, plot_type=\"charge\")\n",
        "    generate_plot(filtered_charge=10, filtered_size=1, plot_type=\"2d\")\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "_pSbGJbh1h6G"
      },
      "outputs": [],
      "source": [
        "\n",
        "y_train = variables[1]#, test_variables = variables[2], y_test = variables[3]\n",
        "\n",
        "plot_histograms(X_train_pion_candidates, X_train_kaon_candidates, X_train_proton_candidates, y_train)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "O6vEDnIw9fKi"
      },
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "muTlVCz1djh3"
      },
      "outputs": [],
      "source": [
        "\n",
        "def freedman_diaconis_bins(data):\n",
        "    \"\"\"Calculate number of hist bins using Freedman-Diaconis rule.\"\"\"\n",
        "    # Assuming data is 1D array\n",
        "    data_range = np.nanmax(data) - np.nanmin(data)\n",
        "    iqr = np.subtract(*np.percentile(data, [75, 25]))\n",
        "    bin_width = 2 * iqr * (len(data) ** -0.33)\n",
        "    return int(data_range / bin_width) if bin_width > 0 else 1\n",
        "\n",
        "def check_nan_inf(arr):\n",
        "    \"\"\"Check if array contains NaN or Inf values.\"\"\"\n",
        "    return np.isnan(arr).any(), np.isinf(arr).any()\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "def plot_hist(X_train=None, X_test=None, y_train = None, y_test = None, description=None):\n",
        "    try:\n",
        "\n",
        "        def plot_specialized_histograms(data, y_data, title):\n",
        "\n",
        "\n",
        "          try:\n",
        "\n",
        "              fig, axs = plt.subplots(3, 4, figsize=(25, 12))\n",
        "              fig.suptitle(f\"{title}\", fontsize=20)\n",
        "\n",
        "              # Separate data based on y-labels\n",
        "              pion_indices = np.where(y_data == np.array([1, 0, 0]))[0]\n",
        "              kaon_indices = np.where(y_data == np.array([0, 1, 0]))[0]\n",
        "              proton_indices = np.where(y_data == np.array([0, 0, 1]))[0]\n",
        "              print(y_data.shape)\n",
        "              data_map = {\n",
        "              'Pion': pion_indices,\n",
        "              'Kaon': kaon_indices,\n",
        "              'Proton': proton_indices\n",
        "              }\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "              for idx, (particle, indices) in enumerate(data_map.items()):\n",
        "                  clu_size = data['mCluSize'][indices]\n",
        "                  clu_charge = data['mCluCharge'][indices]\n",
        "\n",
        "\n",
        "                  clu_size = clu_size.reshape(-1)\n",
        "                  clu_charge = clu_charge.reshape(-1)\n",
        "\n",
        "                  print(f\"np.any(np.isnan(clu_size)) {np.any(np.isnan(clu_size))}\")\n",
        "\n",
        "                  print(f\"np.any(np.isnan(clu_charge)) {np.any(np.isnan(clu_charge))}\")\n",
        "                  print(f\"np.any(np.isinf(clu_size)) {np.any(np.isinf(clu_size))}\")\n",
        "                  print(f\"np.any(np.isinf(clu_charge)) {np.any(np.isinf(clu_charge))}\")\n",
        "\n",
        "\n",
        "\n",
        "                  print(f\"len(clu_size) {len(clu_size)}\")\n",
        "                  print(f\"len(clu_charge) {len(clu_charge)}\")\n",
        "                  print(f\"pion_indices.shape {pion_indices.shape}\")\n",
        "                  print(f\"kaon_indices.shape {kaon_indices.shape}\")\n",
        "                  print(f\"proton_indices.shape {proton_indices.shape}\")\n",
        "\n",
        "\n",
        "                  # 1D histograms\n",
        "                  axs[idx, 0].hist(clu_size, bins=9, range=(2, 11), edgecolor='black', alpha=0.6, label='MIP Cluster size')\n",
        "                  axs[idx, 0].legend()\n",
        "                  axs[idx, 0].set_title(f\"{particle} MIP Cluster Size \")\n",
        "\n",
        "\n",
        "                  # 1D histograms\n",
        "                  axs[idx, 1].hist(clu_charge, bins=200, range=(0, 4000), edgecolor='black', alpha=0.6, label='MIP Cluster charge')\n",
        "                  axs[idx, 1].legend()\n",
        "                  axs[idx, 1].set_title(f\"{particle} 'MIP Cluster charge\")\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "                  try: # works!!\n",
        "\n",
        "                      gridx = np.linspace(min(clu_size), max(clu_size),11)\n",
        "                      gridy = np.linspace(min(clu_charge), max(clu_charge),200)\n",
        "                      try:\n",
        "                          h, xedges, yedges = np.histogram2d(clu_size, clu_charge, bins=[9, 30], range=[(2, 11), (200, 800)])\n",
        "                      except ValueError as ve:\n",
        "                          print(\"Error unpacking histogram2d results:\", ve)\n",
        "                          results = np.histogram2d(clu_size, clu_charge, bins=[gridx, gridy])\n",
        "                          print(\"Results returned from histogram2d:\", results)\n",
        "\n",
        "                      norm = LogNorm()  # Define the logarithmic normalization\n",
        "                      im = axs[idx, 2].pcolormesh(xedges, yedges, h.T, cmap='viridis', norm=norm)\n",
        "                      axs[idx, 2].set_title(f\"{particle} 2D Hist\")\n",
        "                      axs[idx, 2].set_xlabel(\"'MIP Cluster size\")\n",
        "                      axs[idx, 2].set_ylabel(\"'MIP Cluster charge\")\n",
        "                      #axs[idx, 2].set_yscale('log')\n",
        "\n",
        "                      plt.colorbar(im, ax=axs[idx, 2])  # Add colorbar with logarithmic scale\n",
        "\n",
        "                  except Exception as e:\n",
        "                      warnings.warn(f\"plot_specialized_histograms failed histogram2d : {e}\")\n",
        "                  try:\n",
        "                      try:\n",
        "                          h, xedges, yedges = np.histogram2d(clu_size, clu_charge, bins=[11, 200], range=[(0, 11), (0, 8000)])\n",
        "\n",
        "                          ax_3d = axs[idx, 3]\n",
        "\n",
        "                          ax_3d = fig.add_subplot(3, 4, 4 * idx + 4, projection='3d')  # change the layout\n",
        "                          x_pos, y_pos = np.meshgrid(xedges[:-1], yedges[:-1], indexing=\"ij\")\n",
        "                          x_pos = x_pos.flatten('F')\n",
        "                          y_pos = y_pos.flatten('F')\n",
        "                          z_pos = np.zeros_like(x_pos)\n",
        "                          dx = dy = 0.5\n",
        "                          dz = h.flatten()\n",
        "                          ax_3d.bar3d(x_pos, y_pos, z_pos, dx, dy, dz, shade=True)\n",
        "                          ax_3d.set_title(f\"{particle} 3D Bar Chart\")\n",
        "                          ax_3d.set_xlabel(\"mCluSize\")\n",
        "                          ax_3d.set_ylabel(\"mCluCharge\")\n",
        "                          ax_3d.set_zlabel(\"Counts\")\n",
        "\n",
        "                      except Exception as e:\n",
        "                          warnings.warn(f\"plot_specialized_histograms failed  np.histogram2 w : {e}\")\n",
        "                  except Exception as e:\n",
        "                      warnings.warn(f\"plot_specialized_histograms failed  # 3D View w : {e}\")\n",
        "\n",
        "\n",
        "              plt.tight_layout()\n",
        "              plt.show()\n",
        "\n",
        "          except Exception as e:\n",
        "                warnings.warn(f\"Exception caught during plot_specialized_histograms: {e}\")\n",
        "\n",
        "\n",
        "        # Call the new function to generate plots for training and testing datasets\n",
        "        train_data = {\n",
        "            'mCluSize': X_train[\"X_train_mCluSize\"],\n",
        "            \"mCluCharge\": X_train[\"X_train_mCluCharge\"]\n",
        "        }\n",
        "\n",
        "        test_data = {\n",
        "            'mCluSize': X_test[\"X_test_mCluSize\"],\n",
        "            \"mCluCharge\": X_test[\"X_test_mCluCharge\"]\n",
        "        }\n",
        "\n",
        "        plot_specialized_histograms(train_data, y_train, title=\"Training Data\")\n",
        "        plot_specialized_histograms(test_data, y_test, title=\"Testing Data\")\n",
        "\n",
        "\n",
        "        fig, axs = plt.subplots(2, 4, figsize=(25, 10)) # For 'Refractive Index', 'Momentum', 'Phi', and 'Theta'\n",
        "        fig.suptitle(f\"Training and Testing Data: {description}\", fontsize=20)\n",
        "\n",
        "        fig_mClu, axs_mClu = plt.subplots(2, 2, figsize=(16, 10)) # For 'mCluSize' and 'mCluCharge'\n",
        "        fig_mClu.suptitle(f\"Cluster Features: {description}\", fontsize=20)\n",
        "\n",
        "        fig3, axs3 = plt.subplots(2, 5, figsize=(25, 10))\n",
        "        fig3.suptitle(f\"Training and Testing Data: {description}\", fontsize=20)\n",
        "\n",
        "\n",
        "\n",
        "        # impact points on rad / MIP spatial distribution\n",
        "        fig1, axs1 = plt.subplots(2, 3, figsize=(18, 10))\n",
        "        fig1.suptitle(f\"2D Maps and Projections: {description}\", fontsize=20)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "        for key, value in X_train.items():\n",
        "            print(key, type(value))\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "        def plot_routine(variables, row_idx):\n",
        "            axs_idx = 0\n",
        "            axs_idx = 0\n",
        "            axs_mClu_idx = 0\n",
        "            for label, variable in variables.items():\n",
        "                has_nan, has_inf = check_nan_inf(variable)\n",
        "                if has_nan or has_inf:\n",
        "                    warnings.warn(f\"{label} contains NaN or Inf values. This may lead to issues.\")\n",
        "\n",
        "                bins = freedman_diaconis_bins(variable)\n",
        "                range_val = (np.nanmin(variable), np.nanmax(variable))\n",
        "\n",
        "                if label == 'MIP Position' or label == 'Rad Position':\n",
        "                    variable = np.asarray(variable).reshape(-1, 2)\n",
        "                    mask = (variable[:, 0] != 0) & (variable[:, 1] != 0)\n",
        "                    variable = variable[mask]\n",
        "                    axs1[row_idx, 0].scatter(variable[:, 0], variable[:, 1], marker='o', s=10)\n",
        "                    axs1[row_idx, 0].set_title(f\"{'Train' if row_idx == 0 else 'Test'} 2D Map: {label}\")\n",
        "                    axs1[row_idx, 1].hist(variable[:, 0], bins=bins, range=range_val, edgecolor='black')\n",
        "                    axs1[row_idx, 1].set_title(f\"{label} X\")\n",
        "                    axs1[row_idx, 2].hist(variable[:, 1], bins=bins, range=range_val, edgecolor='black')\n",
        "                    axs1[row_idx, 2].set_title(f\"{label} Y\")\n",
        "\n",
        "\n",
        "                elif label == 'mCluSize':\n",
        "                    axs_mClu[row_idx, axs_mClu_idx].hist(variable, bins=11, range=(0, 11), edgecolor='black')\n",
        "                    axs_mClu[row_idx, axs_mClu_idx].set_title(f\"{'Train' if row_idx == 0 else 'Test'} {label}\")\n",
        "                    axs_mClu_idx += 1\n",
        "\n",
        "                elif label == 'mCluCharge':\n",
        "                    axs_mClu[row_idx, axs_mClu_idx].hist(variable, bins=200, range=(0, 8000), edgecolor='black')\n",
        "                    axs_mClu[row_idx, axs_mClu_idx].set_title(f\"{'Train' if row_idx == 0 else 'Test'} {label}\")\n",
        "                    axs_mClu_idx += 1\n",
        "\n",
        "                elif label == 'Momentum':\n",
        "                    axs[row_idx, axs_idx].hist(variable, bins=50, range=(0, 5), edgecolor='black')\n",
        "                    axs[row_idx, axs_idx].set_title(f\"{'Train' if row_idx == 0 else 'Test'} {label}\")\n",
        "                    axs_idx += 1\n",
        "\n",
        "                else:\n",
        "                    axs[row_idx, axs_idx].hist(variable, bins=bins, range=range_val, edgecolor='black')\n",
        "                    axs[row_idx, axs_idx].set_title(f\"{'Train' if row_idx == 0 else 'Test'} {label}\")\n",
        "                    axs_idx += 1\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "        X_train_variables = {\n",
        "        'Refractive Index': X_train[\"X_train_refractive_index\"],\n",
        "        'Momentum': X_train[\"X_train_momentum\"],\n",
        "        'Phi': X_train[\"X_train_phi\"],\n",
        "        'Theta': X_train[\"X_train_theta\"],\n",
        "        'mCluSize': X_train[\"X_train_mCluSize\"],\n",
        "        \"mCluCharge\": X_train[\"X_train_mCluCharge\"],  # New addition\n",
        "        'MIP Position': X_train[\"X_train_mip_position\"],\n",
        "        'Rad Position': X_train[\"X_train_rad_position\"],\n",
        "        'Pion Candidates': X_train[\"X_train_pion_candidates\"],\n",
        "        'Kaon Candidates': X_train[\"X_train_kaon_candidates\"],\n",
        "        'Proton Candidates': X_train[\"X_train_proton_candidates\"]\n",
        "\n",
        "        }\n",
        "\n",
        "\n",
        "        # add kaon and proton candidates ;\n",
        "        X_test_variables = {\n",
        "        'Refractive Index': X_test[\"X_test_refractive_index\"],\n",
        "        'Momentum': X_test[\"X_test_momentum\"],\n",
        "        'Phi': X_test[\"X_test_phi\"],\n",
        "        'Theta': X_test[\"X_test_theta\"],\n",
        "        'mCluSize': X_test[\"X_test_mCluSize\"],\n",
        "        \"mCluCharge\": X_test[\"X_test_mCluCharge\"],  # New addition\n",
        "        'MIP Position': X_test[\"X_test_mip_position\"],\n",
        "        'Rad Position': X_test[\"X_test_rad_position\"],\n",
        "        'Pion Candidates': X_test[\"X_test_pion_candidates\"],\n",
        "        }\n",
        "\n",
        "        train_data = {\n",
        "        'mCluSize': X_train[\"X_train_mCluSize\"],\n",
        "        \"mCluCharge\": X_train[\"X_train_mCluCharge\"]\n",
        "        }\n",
        "\n",
        "        test_data = {\n",
        "        'mCluSize': X_test[\"X_test_mCluSize\"],\n",
        "        \"mCluCharge\": X_test[\"X_test_mCluCharge\"]\n",
        "        }\n",
        "\n",
        "\n",
        "\n",
        "        plot_routine(X_train_variables, 0)\n",
        "        plot_routine(X_test_variables, 1)\n",
        "\n",
        "        plt.show()\n",
        "\n",
        "    except Exception as e:\n",
        "        warnings.warn(f\"Exception caught during plot_histl: {e}\")\n",
        "\n",
        "import warnings\n",
        "\n",
        "try:\n",
        "\n",
        "    plot_hist(X_train = X_train, X_test =  X_test, y_train = y_train, y_test = y_test,  description = \"unscaled\")\n",
        "except Exception as e:\n",
        "    warnings.warn(f\"Exception caught during first function call: {e}\")\n",
        "\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "9BVd9j2SaJaI"
      },
      "outputs": [],
      "source": [
        "\n",
        "import warnings\n",
        "\n",
        "try:\n",
        "    plot_hist(X_train = X_train, X_test =  X_test, y_train = y_train, y_test = y_test,  description = \"unscaled\")\n",
        "except Exception as e:\n",
        "    warnings.warn(f\"Exception caught during first function call: {e}\")\n",
        "\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "RgrwfICDk7NJ"
      },
      "outputs": [],
      "source": [
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "bjFn4oJgEJnN"
      },
      "outputs": [],
      "source": [
        "threshold = 0.7\n",
        "\n",
        "X_test = X_test\n",
        "y_train = y_train\n",
        "y_test = y_test\n",
        "#X_train_scaled, X_test_scaled, X_train, X_test, y_train, y_test = classifier.preprocess_data()\n",
        "\n",
        "\n",
        "train_variables = [X_train_pion_candidates, X_train_kaon_candidates, X_train_proton_candidates, X_train_non_candidates, X_train_momentum, X_train_refractive_index, X_train_phi, X_train_theta, X_train_mip_position, X_train_rad_position, X_train_mCluCharge, X_train_mCluSize]\n",
        "test_variables = [X_test_pion_candidates, X_test_kaon_candidates, X_test_proton_candidates, X_test_non_candidates, X_test_momentum, X_test_refractive_index, X_test_phi, X_test_theta, X_test_mip_position, X_test_rad_position, X_test_mCluCharge, X_test_mCluSize]\n",
        "\n",
        "y_pred_train = model.predict(train_variables)\n",
        "y_pred_test = model.predict(test_variables)\n",
        "\n",
        "# plot_individual_types(idx=index, x_pion=X_test_pion_candidates, x_kaon=X_test_kaon_candidates, x_proton=X_test_proton_candidates, x_non=X_test_non_candidates, MIP_charge=X_test_mCluCharge, MIP_position=X_test_mip_position, RAD_position=X_test_rad_position, phi=X_test_phi, y_train=y_test, log_scale=True, X_index=X_test_index_particle)\n",
        "\n",
        "\n",
        "#def plot_combined_types(i, x_pion, x_kaon, x_proton, x_non, MIP_position, RAD_position, phiP, thetaP, y_train):\n",
        "#\n",
        "regions = 2\n",
        "\n",
        "class_labels  = [\"pion\", \"kaon\", \"proton\"]\n",
        "i = 0\n",
        "\n",
        "plot_var = \"train\"\n",
        "#if plot_var == \"test\":\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "def process_predictions(y_pred, y_true, X_pion_candidates, X_kaon_candidates, X_proton_candidates, X_non_candidates, MIP_charge, MIP_position, RAD_position, phi, theta, y_train, X_index_particle, regions, prefix=''):\n",
        "    i = 0\n",
        "    for pred, true in zip(y_pred, y_true):\n",
        "        max_prob = np.max(pred)\n",
        "        predicted_class = np.argmax(pred)\n",
        "        if max_prob > threshold:\n",
        "            label = class_labels[predicted_class]  # Assuming class_labels is a list of your labels\n",
        "        else:\n",
        "            label = 'reject'\n",
        "\n",
        "        print(f\"====================================================================================== \\n\")\n",
        "\n",
        "        info_str = f\" predicted_class = {predicted_class}  true class = {true}|  max_prob = {max_prob:.2f} pred = {pred}\"\n",
        "\n",
        "\n",
        "        fig, ax = plt.subplots()\n",
        "\n",
        "        #\n",
        "          # plot_individual_types(idx=index, x_pion=x_pion, x_kaon=x_kaon, x_proton=x_proton, x_non=x_non,\n",
        "          #                       MIP_charge=MIP_charge, MIP_position=MIP_position, RAD_position=RAD_position,\n",
        "          #                       phi=phi, theta = thetaP, y_train=y_train, log_scale=True, X_index=X_index, regions=regions)\n",
        "\n",
        "          # plot_combined_types(index, x_pion, x_kaon, x_proton, x_non, MIP_position, RAD_position, phi, thetaP, y_train=y_train, X_index=X_index, regions=regions)\n",
        "\n",
        "\n",
        "        plot_individual_types(idx=i, x_pion=X_pion_candidates, x_kaon=X_kaon_candidates, x_proton=X_proton_candidates, x_non=X_non_candidates, MIP_charge=MIP_charge, MIP_position=MIP_position, RAD_position=RAD_position, phi=phi, theta = theta, y_train=y_train, log_scale=True, X_index=X_index_particle, regions=regions)\n",
        "        plt.savefig(f'{prefix}_individual_plot_{i}.png')  # Save the individual plot\n",
        "        plt.close()\n",
        "\n",
        "        fig, ax = plt.subplots()\n",
        "        plot_combined_types(i, X_pion_candidates, X_kaon_candidates, X_proton_candidates, X_non_candidates, MIP_position, RAD_position, phi, theta, y_train=y_train, X_index=X_index_particle, regions=regions)\n",
        "\n",
        "        plt.savefig(f'{prefix}_combined_plot_{i}.png')  # Save the combined plot\n",
        "        plt.close()\n",
        "\n",
        "        print(info_str)\n",
        "        i += 1\n",
        "\n",
        "# For test data\n",
        "process_predictions(y_pred_test, y_test, X_test_pion_candidates, X_test_kaon_candidates, X_test_proton_candidates, X_test_non_candidates, X_test_mCluCharge, X_test_mip_position, X_test_rad_position, X_test_phi, X_test_theta, y_test, X_test_index_particle, regions, prefix='test')\n",
        "\n",
        "# For train data\n",
        "process_predictions(y_pred_train, y_train, X_train_pion_candidates, X_train_kaon_candidates, X_train_proton_candidates, X_train_non_candidates, X_train_mCluCharge, X_train_mip_position, X_train_rad_position, X_train_phi, X_train_theta, y_train, X_train_index_particle, regions, prefix='train')\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "zukgX2C29574"
      },
      "outputs": [],
      "source": [
        "\n",
        "\n",
        "mask = [1,1,1,1]\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "fc1_unit = 64\n",
        "units = [fc1_unit * i for i in [64, 32, 16, 16, 8, 4, 4, 2, 2, 1]]\n",
        "units2 = [fc1_unit * i for i in [64, 32, 16, 16, 8, 4, 4, 2, 2, 1]]\n",
        "\n",
        "CNN_units = None\n",
        "\n",
        "classifier.train(X_train = X_train, X_test = X_test, y_train = y_train, y_test = y_test, mask = mask, num_epochs=150, include_cnn = True, units = units, units2 = units2, CNN_units = CNN_units)\n",
        "#classifier.train(X_train = X_train_scaled, X_test = X_test_scaled, y_train = y_train, y_test = y_test, mask = mask, num_epochs=50)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "NoauWOieMnWE"
      },
      "outputs": [],
      "source": [
        "!wget https://raw.githubusercontent.com/eflatlan/CNN_PID/models_sacved/helper_functions.py\n",
        "from helper_functions import *"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "gvEulDjrHxkx"
      },
      "outputs": [],
      "source": [
        "!wget https://raw.githubusercontent.com/eflatlan/CNN_PID/models_sacved/plot_helper_functions.py\n",
        "from plot_helper_functions import *"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "oxRzlwIzxxk6"
      },
      "outputs": [],
      "source": [
        "!wget https://raw.githubusercontent.com/eflatlan/CNN_PID/models_sacved/plot_helper_functions.py\n",
        "from plot_helper_functions import *"
      ]
    }
  ],
  "metadata": {
    "colab": {
      "provenance": [],
      "authorship_tag": "ABX9TyMjBWX6vDvXH6ulQ2UuorwE",
      "include_colab_link": true
    },
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    },
    "language_info": {
      "name": "python"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}